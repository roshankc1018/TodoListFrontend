/**-----------------------------------------------------------------------------------------
* Copyright Â© 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
var ColorPickerComponent_1;
import { Component, HostBinding, Input, Output, EventEmitter, ViewChild, ElementRef, TemplateRef, ViewContainerRef, forwardRef, ChangeDetectorRef, NgZone } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { PopupService } from '@progress/kendo-angular-popup';
import { validatePackage } from '@progress/kendo-licensing';
import { packageMetadata } from '../package-metadata';
import { PreventableEvent, ActiveColorClickEvent } from './models';
import { parseColor } from './utils/color-parser';
import { isPresent } from '../common/utils';
import { Keys, KendoInput } from '@progress/kendo-angular-common';
import { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';
import { PALETTEPRESETS } from './utils/palette-presets';
import { ColorPickerLocalizationService } from './localization/colorpicker-localization.service';
import { ColorGradientComponent } from './color-gradient.component';
const DEFAULT_PRESET = 'office';
const DEFAULT_ACCESSIBLE_PRESET = 'accessible';
let serial = 0;
/**
 * Represents the [Kendo UI ColorPicker component for Angular]({% slug overview_colorpicker %}).
 * Designed to replace the `<input type="color">` HTML5 tag which is not widely supported in browsers.
 */
let ColorPickerComponent = ColorPickerComponent_1 = class ColorPickerComponent {
    constructor(popupService, cdr, localizationService, ngZone) {
        this.popupService = popupService;
        this.cdr = cdr;
        this.localizationService = localizationService;
        this.ngZone = ngZone;
        /**
         * @hidden
         */
        this.hostClasses = true;
        /**
         * @hidden
         */
        this.focusableId = `k-colorpicker-${serial++}`;
        /**
         * Sets what view the ColorPicker will render in the popup.
         */
        this.view = 'gradient';
        /**
         * Sets the read-only state of the ColorPicker.
         */
        this.readonly = false;
        /**
         * Sets the disabled state of the ColorPicker.
         */
        this.disabled = false;
        /**
         * Specifies the output format of the ColorPicker.
         * The input value may be in a different format. However, it will be parsed into the output `format`
         * after the component processes it.
         *
         * If the `gradient` view is used with the `opacity` option set to true, this setting will be ignored and `rgba` will be used instead.
         *
         * The supported values are:
         * * `rgba` (default)
         * * `hex`
         * * [name](https://www.w3.org/wiki/CSS/Properties/color/keywords)
         */
        this.format = 'rgba';
        /**
         * Fires each time the value is changed.
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time the popup is about to open.
         * This event is preventable. If you cancel it, the popup will remain closed.
         */
        this.open = new EventEmitter();
        /**
         * Fires each time the popup is about to close.
         * This event is preventable. If you cancel it, the popup will remain open.
         */
        this.close = new EventEmitter();
        /**
         * Fires each time ColorPicker is focused.
         */
        this.onFocus = new EventEmitter();
        /**
         * Fires each time the ColorPicker is blurred.
         */
        this.onBlur = new EventEmitter();
        /**
         * Fires each time the left side of the ColorPicker wrapper is clicked.
         * The event is triggered regardless of whether a ColorPicker icon is set or not.
         *
         * The [ActiveColorClickEvent]({% slug api_inputs_activecolorclickevent %}) event provides the option to prevent the popup opening.
         */
        this.activeColorClick = new EventEmitter();
        this._tabindex = 0;
        this._popupSettings = { animate: true };
        this._paletteSettings = {};
        this._gradientSettings = { opacity: true, clearButton: false, delay: 0 };
        this.notifyNgTouched = () => { };
        this.notifyNgChanged = () => { };
        validatePackage(packageMetadata);
        this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
    }
    /**
     * Specifies the value of the initially selected color.
     */
    set value(value) {
        this._value = parseColor(value, this.format);
    }
    get value() {
        return this._value;
    }
    /**
     * Configures the popup of the ColorPicker.
     */
    set popupSettings(value) {
        this._popupSettings = Object.assign(this._popupSettings, value);
    }
    get popupSettings() {
        return this._popupSettings;
    }
    /**
     * Configures the palette that is displayed in the ColorPicker popup.
     */
    set paletteSettings(value) {
        this._paletteSettings = Object.assign(this._paletteSettings, value);
    }
    get paletteSettings() {
        return this._paletteSettings;
    }
    /**
     * Configures the gradient that is displayed in the ColorPicker popup.
     */
    set gradientSettings(value) {
        this._gradientSettings = Object.assign(this._gradientSettings, value);
    }
    get gradientSettings() {
        return this._gradientSettings;
    }
    /**
     * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
     */
    set tabindex(value) {
        const tabindex = Number(value);
        const defaultValue = 0;
        this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;
    }
    get tabindex() {
        return !this.disabled ? this._tabindex : undefined;
    }
    /**
     * Indicates whether the ColorPicker popup is open.
     */
    get isOpen() {
        return isPresent(this.popupRef);
    }
    /**
     * @hidden
     */
    get iconStyles() {
        if (this.iconClass) {
            return this.iconClass;
        }
        if (this.icon) {
            return `k-icon k-i-${this.icon}`;
        }
    }
    ngOnInit() {
        const defaultPreset = (this.format !== 'name') ? DEFAULT_PRESET : DEFAULT_ACCESSIBLE_PRESET;
        const settingsPalette = this._paletteSettings.palette;
        const presetColumns = typeof settingsPalette === 'string' && PALETTEPRESETS[settingsPalette] ?
            PALETTEPRESETS[settingsPalette].columns :
            undefined;
        this._paletteSettings = {
            palette: settingsPalette || defaultPreset,
            tileSize: this._paletteSettings.tileSize || 24,
            columns: this._paletteSettings.columns || presetColumns || 10
        };
    }
    ngOnChanges(changes) {
        if (changes.format && changes.format.currentValue === 'name') {
            this.view = 'palette';
        }
        if (this.view === 'gradient' && this.gradientSettings.opacity) {
            this.format = 'rgba';
            this.value = parseColor(this.value, this.format);
        }
    }
    ngOnDestroy() {
        this.closePopup();
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    handleWrapperClick() {
        this.toggleWithEvents(!this.isOpen);
        this.focus();
    }
    /**
     * @hidden
     */
    handleActiveColorClick() {
        this.focus();
        const event = new ActiveColorClickEvent(this.value);
        this.activeColorClick.emit(event);
        if (!event.isOpenPrevented() || this.isOpen) {
            this.handleWrapperClick();
        }
    }
    /**
     * Focuses the wrapper of the ColorPicker.
     */
    focus() {
        if (this.disabled) {
            return;
        }
        this.wrapper.nativeElement.focus();
    }
    /**
     * @hidden
     */
    handleWrapperFocus() {
        if (isPresent(this.palette)) {
            this.palette.nativeElement.focus();
        }
        if (this.isFocused) {
            return;
        }
        this.isFocused = true;
        this.onFocus.emit();
    }
    /**
     * Blurs the ColorPicker.
     */
    blur() {
        this.wrapper.nativeElement.blur();
    }
    /**
     * @hidden
     */
    handleWrapperBlur() {
        if (this.isOpen) {
            return;
        }
        this.isFocused = false;
        this.onBlur.emit();
        this.notifyNgTouched();
    }
    /**
     * Clears the color value of the ColorPicker.
     */
    reset() {
        if (!isPresent(this.value)) {
            return;
        }
        this._value = undefined;
        this.notifyNgChanged(undefined);
    }
    /**
     * Toggles the popup of the ColorPicker.
     * Does not trigger the `open` and `close` events of the component.
     *
     * @param open An optional parameter. Specifies whether the popup will be opened or closed.
     */
    toggle(open) {
        if (this.disabled || this.readonly) {
            return;
        }
        this.closePopup();
        open = isPresent(open) ? open : !this.isOpen;
        if (open) {
            this.openPopup();
        }
    }
    /**
     * @hidden
     */
    handleValueChange(color, closePopup) {
        const parsedColor = parseColor(color, this.format);
        const valueChange = parsedColor !== this.value;
        if (closePopup) {
            this.toggleWithEvents(false);
            this.focus();
        }
        if (valueChange) {
            this.value = parsedColor;
            this.valueChange.emit(parsedColor);
            this.notifyNgChanged(parsedColor);
        }
    }
    /**
     * @hidden
     */
    handlePopupBlur(event) {
        const focusInPopupElement = this.popupRef.popupElement.contains(event.relatedTarget);
        const wrapperClicked = event.relatedTarget === this.wrapper.nativeElement;
        if (!this.isFocused || wrapperClicked || focusInPopupElement) {
            return;
        }
        this.isFocused = false;
        this.onBlur.emit();
        this.notifyNgTouched();
        this.toggleWithEvents(false);
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.value = value;
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.notifyNgChanged = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.notifyNgTouched = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.cdr.markForCheck();
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     */
    handleWrapperKeyDown(event) {
        if (event.keyCode === Keys.ArrowDown || event.keyCode === Keys.Enter) {
            event.preventDefault();
            this.toggleWithEvents(true);
        }
    }
    /**
     * @hidden
     */
    handlePopupKeyDown(event) {
        if (event.keyCode === Keys.Escape) {
            this.toggleWithEvents(false);
            this.wrapper.nativeElement.focus();
        }
        if (event.keyCode === Keys.Tab) {
            const firstElement = this.colorGradient ? this.colorGradient.gradientDragHandle.nativeElement : this.palette.nativeElement;
            const lastElement = this.palette ? this.palette.nativeElement :
                this.colorGradient.inputs.opacityInput.nativeElement.childNodes[1].children[0];
            if (event.shiftKey) {
                if (event.target === firstElement) {
                    event.preventDefault();
                    lastElement.focus();
                    return;
                }
            }
            else {
                if (event.target === lastElement) {
                    event.preventDefault();
                    firstElement.focus();
                    return;
                }
            }
        }
    }
    /**
     * @hidden
     * Used by the TextBoxContainer to determine if the component is empty.
     */
    isEmpty() {
        return false;
    }
    toggleWithEvents(open) {
        const sameState = this.isOpen === open;
        if (this.disabled || this.readonly || sameState) {
            return;
        }
        const eventArgs = new PreventableEvent();
        open ? this.open.emit(eventArgs) : this.close.emit(eventArgs);
        if (!eventArgs.isDefaultPrevented()) {
            this.toggle(open);
        }
        if (open) {
            this.ngZone.runOutsideAngular(() => {
                setTimeout(() => {
                    if (this.colorGradient) {
                        this.colorGradient.gradientDragHandle.nativeElement.focus();
                    }
                });
            });
        }
    }
    openPopup() {
        const horizontalAlign = this.direction === "rtl" ? "right" : "left";
        const anchorPosition = { horizontal: horizontalAlign, vertical: "bottom" };
        const popupPosition = { horizontal: horizontalAlign, vertical: "top" };
        this.popupRef = this.popupService.open({
            anchor: this.wrapper,
            animate: this.popupSettings.animate,
            appendTo: this.popupSettings.appendTo,
            popupAlign: popupPosition,
            anchorAlign: anchorPosition,
            popupClass: 'k-colorpicker-popup',
            content: this.popupTemplate,
            positionMode: 'absolute'
        });
        this.popupRef.popupAnchorViewportLeave.subscribe(() => {
            this.toggleWithEvents(false);
            if (!this.isOpen) {
                this.wrapper.nativeElement.focus({
                    preventScroll: true
                });
            }
        });
    }
    closePopup() {
        if (!this.isOpen) {
            return;
        }
        this.popupRef.close();
        this.popupRef = null;
        this.palette = null;
    }
};
tslib_1.__decorate([
    HostBinding('class.k-widget'),
    HostBinding('class.k-colorpicker'),
    tslib_1.__metadata("design:type", Boolean)
], ColorPickerComponent.prototype, "hostClasses", void 0);
tslib_1.__decorate([
    HostBinding('attr.dir'),
    tslib_1.__metadata("design:type", String)
], ColorPickerComponent.prototype, "direction", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], ColorPickerComponent.prototype, "focusableId", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], ColorPickerComponent.prototype, "view", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], ColorPickerComponent.prototype, "readonly", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], ColorPickerComponent.prototype, "disabled", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], ColorPickerComponent.prototype, "format", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String),
    tslib_1.__metadata("design:paramtypes", [String])
], ColorPickerComponent.prototype, "value", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object),
    tslib_1.__metadata("design:paramtypes", [Object])
], ColorPickerComponent.prototype, "popupSettings", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object),
    tslib_1.__metadata("design:paramtypes", [Object])
], ColorPickerComponent.prototype, "paletteSettings", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object),
    tslib_1.__metadata("design:paramtypes", [Object])
], ColorPickerComponent.prototype, "gradientSettings", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], ColorPickerComponent.prototype, "icon", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object)
], ColorPickerComponent.prototype, "iconClass", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number),
    tslib_1.__metadata("design:paramtypes", [Number])
], ColorPickerComponent.prototype, "tabindex", null);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], ColorPickerComponent.prototype, "valueChange", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], ColorPickerComponent.prototype, "open", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], ColorPickerComponent.prototype, "close", void 0);
tslib_1.__decorate([
    Output('focus'),
    tslib_1.__metadata("design:type", EventEmitter)
], ColorPickerComponent.prototype, "onFocus", void 0);
tslib_1.__decorate([
    Output('blur'),
    tslib_1.__metadata("design:type", EventEmitter)
], ColorPickerComponent.prototype, "onBlur", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], ColorPickerComponent.prototype, "activeColorClick", void 0);
tslib_1.__decorate([
    ViewChild('container', { read: ViewContainerRef, static: true }),
    tslib_1.__metadata("design:type", ViewContainerRef)
], ColorPickerComponent.prototype, "container", void 0);
tslib_1.__decorate([
    ViewChild('wrapper', { static: true }),
    tslib_1.__metadata("design:type", ElementRef)
], ColorPickerComponent.prototype, "wrapper", void 0);
tslib_1.__decorate([
    ViewChild('popupTemplate', { static: true }),
    tslib_1.__metadata("design:type", TemplateRef)
], ColorPickerComponent.prototype, "popupTemplate", void 0);
tslib_1.__decorate([
    ViewChild('palette', { read: ElementRef, static: false }),
    tslib_1.__metadata("design:type", ElementRef)
], ColorPickerComponent.prototype, "palette", void 0);
tslib_1.__decorate([
    ViewChild('colorGradient', { static: false }),
    tslib_1.__metadata("design:type", ColorGradientComponent)
], ColorPickerComponent.prototype, "colorGradient", void 0);
ColorPickerComponent = ColorPickerComponent_1 = tslib_1.__decorate([
    Component({
        selector: 'kendo-colorpicker',
        providers: [{
                multi: true,
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => ColorPickerComponent_1)
            }, {
                provide: KendoInput,
                useExisting: forwardRef(() => ColorPickerComponent_1)
            },
            ColorPickerLocalizationService,
            {
                provide: LocalizationService,
                useExisting: ColorPickerLocalizationService
            },
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.colorpicker'
            }
        ],
        template: `
        <ng-container kendoColorPickerLocalizedMessages
            i18n-colorGradient="kendo.colorpicker.colorGradientNoColor|The aria-label applied to the ColorGradient component when the value is empty."
            colorGradientNoColor="Colorgradient no color chosen"
            i18n-colorGradient="kendo.colorpalette.colorPaletteNoColor|The aria-label applied to the ColorPalette component when the value is empty."
            colorPaletteNoColor="Colorpalette no color chosen"
            i18n-colorGradientHandle="kendo.colorpicker.colorGradientHandle|The title for the gradient color drag handle chooser."
            colorGradientHandle="Choose color"
            i18n-clearButton="kendo.colorpicker.clearButton|The title for the clear button."
            clearButton="Clear value"
            i18n-hueSliderHandle="kendo.colorpicker.hueSliderHandle|The title for the hue slider handle."
            hueSliderHandle="Set hue"
            i18n-opacitySliderHandle="kendo.colorpicker.opacitySliderHandle|The title for the opacity slider handle."
            opacitySliderHandle="Set opacity"
            i18n-hexInputPlaceholder="kendo.colorpicker.hexInputPlaceholder|The placeholder for the HEX color input."
            hexInputPlaceholder="HEX Color"
            i18n-redInputPlaceholder="kendo.colorpicker.redInputPlaceholder|The placeholder for the red color input."
            redInputPlaceholder="Red"
            i18n-greenInputPlaceholder="kendo.colorpicker.greenInputPlaceholder|The placeholder for the green color input."
            greenInputPlaceholder="Green"
            i18n-blueInputPlaceholder="kendo.colorpicker.blueInputPlaceholder|The placeholder for the blue color input."
            blueInputPlaceholder="Blue"
            i18n-alphaInputPlaceholder="kendo.colorpicker.alphaInputPlaceholder|The placeholder for the alpha input."
            alphaInputPlaceholder="Alpha">
        </ng-container>
        <span
            #wrapper
            [ngClass]="{
                'k-picker-wrap': true,
                'k-state-disabled': this.disabled,
                'k-state-focused': this.isFocused
            }"
            role="listbox"
            [attr.aria-expanded]="isOpen"
            [attr.aria-readonly]="readonly"
            [attr.aria-disabled]="disabled"
            [attr.aria-label]="value"
            [id]="focusableId"
            [attr.tabindex]="tabindex"
            (focus)="handleWrapperFocus()"
            (blur)="handleWrapperBlur()"
            (mousedown)="$event.preventDefault()"
            (keydown)="handleWrapperKeyDown($event)"
        >
            <span *ngIf="!iconStyles" class="k-selected-color" [style.background-color]="value" (click)="handleActiveColorClick()">
                <span class="k-icon k-i-line" *ngIf="!value"></span>
            </span>
            <span *ngIf="iconStyles" class="k-tool-icon" [ngClass]="iconStyles" (click)="handleActiveColorClick()">
                <span class="k-selected-color" [style.background-color]="value"></span>
            </span>
            <span class="k-select" (click)="handleWrapperClick()">
                <span class="k-icon k-i-arrow-s"></span>
            </span>
        </span>
        <ng-template #popupTemplate>
            <kendo-colorgradient  #colorGradient
                *ngIf="view === 'gradient' || view === 'combo'"
                [value]="value"
                [format]="format"
                [opacity]="gradientSettings.opacity"
                [clearButton]="gradientSettings.clearButton"
                [delay]="gradientSettings.delay"
                (focusout)="handlePopupBlur($event)"
                (valueChange)="handleValueChange($event, false)"
                (keydown)="handlePopupKeyDown($event)"
            >
            </kendo-colorgradient>
            <kendo-colorpalette
                #palette
                *ngIf="view === 'palette' || view === 'combo'"
                kendoFocusOnDomReady
                [palette]="paletteSettings.palette"
                [columns]="paletteSettings.columns"
                [tileSize]="paletteSettings.tileSize"
                [format]="format"
                [value]="value"
                (blur)="handlePopupBlur($event)"
                (cellSelection)="handleValueChange($event, true)"
                (mousedown)="$event.preventDefault()"
                (keydown)="handlePopupKeyDown($event)"
            >
            </kendo-colorpalette>
        </ng-template>
        <ng-container #container></ng-container>
    `
    }),
    tslib_1.__metadata("design:paramtypes", [PopupService,
        ChangeDetectorRef,
        LocalizationService,
        NgZone])
], ColorPickerComponent);
export { ColorPickerComponent };
