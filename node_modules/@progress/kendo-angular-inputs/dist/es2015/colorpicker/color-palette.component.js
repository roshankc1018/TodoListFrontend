/**-----------------------------------------------------------------------------------------
* Copyright Â© 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
var ColorPaletteComponent_1;
import { Component, Input, EventEmitter, Output, HostBinding, HostListener, forwardRef, ChangeDetectorRef, Renderer2, ElementRef } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { PALETTEPRESETS, parseColor } from './utils';
import { isPresent } from '../common/utils';
import { ColorPaletteService } from './services/color-palette.service';
import { Keys, KendoInput } from '@progress/kendo-angular-common';
import { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';
import { ColorPaletteLocalizationService } from './localization/colorpalette-localization.service';
const DEFAULT_TILE_SIZE = 24;
const DEFAULT_COLUMNS_COUNT = 10;
const DEFAULT_PRESET = 'office';
const DEFAULT_ACCESSIBLE_PRESET = 'accessible';
let serial = 0;
/**
 * The ColorPalette component provides a set of predefined palette presets and enables you to implement a custom color palette.
 * The ColorPalette is independently used by `kendo-colorpicker` and can be directly added to the page.
 */
let ColorPaletteComponent = ColorPaletteComponent_1 = class ColorPaletteComponent {
    constructor(host, service, cdr, renderer, localizationService) {
        this.host = host;
        this.service = service;
        this.cdr = cdr;
        this.renderer = renderer;
        this.localizationService = localizationService;
        /**
         * @hidden
         */
        this.id = `k-colorpalette-${serial++}`;
        /**
         * Specifies the output format of the ColorPaletteComponent.
         * The input value may be in a different format. However, it will be parsed into the output `format`
         * after the component processes it.
         *
         * The supported values are:
         * * (Default) `hex`
         * * `rgba`
         * * `name`
         */
        this.format = 'hex';
        /**
         * Sets the disabled state of the ColorPalette.
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the ColorPalette.
         */
        this.readonly = false;
        /**
         * Specifies the size of a color cell.
         *
         * The possible values are:
         * * (Default) `tileSize = 24`
         * * `{ width: number, height: number }`
         */
        this.tileSize = { width: DEFAULT_TILE_SIZE, height: DEFAULT_TILE_SIZE };
        /**
         * Fires each time the color selection is changed.
         */
        this.selectionChange = new EventEmitter();
        /**
         * Fires each time the value is changed.
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time the user selects a cell with the mouse or presses `Enter`.
         *
         * @hidden
         */
        this.cellSelection = new EventEmitter();
        /**
         * @hidden
         */
        this.hostClasses = true;
        this._tabindex = 0;
        this.notifyNgTouched = () => { };
        this.notifyNgChanged = () => { };
        this.dynamicRTLSubscription = localizationService.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
    }
    /**
     * @hidden
     */
    get paletteId() {
        return this.id;
    }
    /**
     * Specifies the value of the initially selected color.
     */
    set value(value) {
        this._value = parseColor(value, this.format);
    }
    get value() {
        return this._value;
    }
    /**
     * Specifies the number of columns that will be displayed.
     * Defaults to `10`.
     */
    set columns(value) {
        const minColumnsCount = 1;
        this._columns = value > minColumnsCount ? value : minColumnsCount;
    }
    get columns() {
        return this._columns;
    }
    /**
     * The color palette that will be displayed.
     *
     * The supported values are:
     * * The name of the predefined palette preset (for example, `office`, `basic`, and `apex`).
     * * A string with comma-separated colors.
     * * A string array.
     */
    set palette(value) {
        if (!isPresent(value)) {
            value = DEFAULT_PRESET;
        }
        if (typeof value === 'string' && isPresent(PALETTEPRESETS[value])) {
            this.columns = this.columns || PALETTEPRESETS[value].columns;
            value = PALETTEPRESETS[value].colors;
        }
        const colors = (typeof value === 'string') ? value.split(',') : value;
        this._palette = colors.map(color => parseColor(color, this.format, false));
    }
    get palette() {
        return this._palette;
    }
    /**
     * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
     */
    set tabindex(value) {
        const tabindex = Number(value);
        const defaultValue = 0;
        this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;
    }
    get tabindex() {
        return !this.disabled ? this._tabindex : undefined;
    }
    /**
     * @hidden
     */
    get tileLayout() {
        if (typeof this.tileSize !== 'number') {
            return this.tileSize;
        }
        return { width: this.tileSize, height: this.tileSize };
    }
    /**
     * @hidden
     */
    get colorRows() {
        return this.service.colorRows;
    }
    /**
     * @hidden
     */
    get hostTabindex() { return this.tabindex; }
    /**
     * @hidden
     */
    get disabledClass() { return this.disabled; }
    /**
     * @hidden
     */
    get readonlyAttribute() { return this.readonly; }
    ngOnInit() {
        if (this.colorRows.length === 0) {
            const defaultPreset = (this.format !== 'name') ? DEFAULT_PRESET : DEFAULT_ACCESSIBLE_PRESET;
            this.palette = this.palette || defaultPreset;
            this.setRows();
            this.focusedCell = this.service.getCellCoordsFor(this.value);
        }
    }
    ngAfterViewInit() {
        this.setHostElementAriaLabel();
    }
    ngOnDestroy() {
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    }
    ngOnChanges(changes) {
        if (changes.palette || changes.columns) {
            this.setRows();
        }
        if (changes.palette || changes.value || changes.columns) {
            this.focusedCell = this.service.getCellCoordsFor(this.value);
            this.setHostElementAriaLabel();
        }
    }
    /**
     * @hidden
     */
    handleKeydown(event) {
        const isRTL = this.direction === 'rtl';
        switch (event.keyCode) {
            case Keys.ArrowDown:
                this.handleCellNavigation(0, 1);
                break;
            case Keys.ArrowUp:
                this.handleCellNavigation(0, -1);
                break;
            case Keys.ArrowRight:
                this.handleCellNavigation(isRTL ? -1 : 1, 0);
                break;
            case Keys.ArrowLeft:
                this.handleCellNavigation(isRTL ? 1 : -1, 0);
                break;
            case Keys.Enter:
                this.handleEnter();
                break;
            default: return;
        }
        event.preventDefault();
    }
    /**
     * @hidden
     */
    handleHostBlur() {
        this.notifyNgTouched();
    }
    /**
     * @hidden
     */
    handleCellSelection(value, focusedCell) {
        if (this.readonly) {
            return;
        }
        this.focusedCell = focusedCell;
        const parsedColor = parseColor(value, this.format, false);
        this.cellSelection.emit(parsedColor);
        if (this.value !== parsedColor) {
            this.value = parsedColor;
            this.valueChange.emit(parsedColor);
            this.notifyNgChanged(parsedColor);
            this.setHostElementAriaLabel();
        }
        if (this.selection !== parsedColor) {
            this.selection = parsedColor;
            this.selectionChange.emit(parsedColor);
        }
        if (focusedCell) {
            this.activeCellId = `${this.focusedCell.row}${this.focusedCell.col}`;
        }
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.value = value;
        this.focusedCell = this.service.getCellCoordsFor(this.value);
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.notifyNgChanged = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.notifyNgTouched = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.cdr.markForCheck();
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     * Used by the TextBoxContainer to determine if the component is empty.
     */
    isEmpty() {
        return false;
    }
    /**
     * Clears the color value of the ColorPalette.
     */
    reset() {
        this.focusedCell = null;
        if (isPresent(this.value)) {
            this._value = undefined;
            this.notifyNgChanged(undefined);
        }
    }
    setRows() {
        if (!isPresent(this.palette)) {
            return;
        }
        this.columns = this.columns || DEFAULT_COLUMNS_COUNT;
        this.service.setColorMatrix(this.palette, this.columns);
    }
    handleCellNavigation(horizontalStep, verticalStep) {
        if (this.readonly) {
            return;
        }
        this.focusedCell = this.service.getNextCell(this.focusedCell, horizontalStep, verticalStep);
        const selection = this.service.getColorAt(this.focusedCell);
        if (this.selection !== selection) {
            this.selection = selection;
            this.selectionChange.emit(selection);
        }
    }
    setHostElementAriaLabel() {
        const parsed = parseColor(this.value, this.format);
        this.renderer.setAttribute(this.host.nativeElement, 'aria-label', `${this.value ? parsed : this.localizationService.get('colorPaletteNoColor')}`);
    }
    handleEnter() {
        if (!isPresent(this.focusedCell)) {
            return;
        }
        const selectedColor = this.service.getColorAt(this.focusedCell);
        this.handleCellSelection(selectedColor, this.focusedCell);
    }
};
tslib_1.__decorate([
    HostBinding('attr.dir'),
    tslib_1.__metadata("design:type", String)
], ColorPaletteComponent.prototype, "direction", void 0);
tslib_1.__decorate([
    HostBinding('attr.id'),
    tslib_1.__metadata("design:type", String),
    tslib_1.__metadata("design:paramtypes", [])
], ColorPaletteComponent.prototype, "paletteId", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], ColorPaletteComponent.prototype, "id", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], ColorPaletteComponent.prototype, "format", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String),
    tslib_1.__metadata("design:paramtypes", [String])
], ColorPaletteComponent.prototype, "value", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number),
    tslib_1.__metadata("design:paramtypes", [Number])
], ColorPaletteComponent.prototype, "columns", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object),
    tslib_1.__metadata("design:paramtypes", [Object])
], ColorPaletteComponent.prototype, "palette", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number),
    tslib_1.__metadata("design:paramtypes", [Number])
], ColorPaletteComponent.prototype, "tabindex", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], ColorPaletteComponent.prototype, "disabled", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], ColorPaletteComponent.prototype, "readonly", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object)
], ColorPaletteComponent.prototype, "tileSize", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], ColorPaletteComponent.prototype, "selectionChange", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], ColorPaletteComponent.prototype, "valueChange", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], ColorPaletteComponent.prototype, "cellSelection", void 0);
tslib_1.__decorate([
    HostBinding('attr.tabindex'),
    tslib_1.__metadata("design:type", Number),
    tslib_1.__metadata("design:paramtypes", [])
], ColorPaletteComponent.prototype, "hostTabindex", null);
tslib_1.__decorate([
    HostBinding('class.k-widget'),
    HostBinding('class.k-colorpalette'),
    tslib_1.__metadata("design:type", Boolean)
], ColorPaletteComponent.prototype, "hostClasses", void 0);
tslib_1.__decorate([
    HostBinding('attr.aria-disabled'),
    HostBinding('class.k-state-disabled'),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [])
], ColorPaletteComponent.prototype, "disabledClass", null);
tslib_1.__decorate([
    HostBinding('attr.aria-readonly'),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [])
], ColorPaletteComponent.prototype, "readonlyAttribute", null);
tslib_1.__decorate([
    HostListener('keydown', ['$event']),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", void 0)
], ColorPaletteComponent.prototype, "handleKeydown", null);
tslib_1.__decorate([
    HostListener('blur'),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], ColorPaletteComponent.prototype, "handleHostBlur", null);
ColorPaletteComponent = ColorPaletteComponent_1 = tslib_1.__decorate([
    Component({
        selector: 'kendo-colorpalette',
        providers: [
            {
                multi: true,
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => ColorPaletteComponent_1) // tslint:disable-line:no-forward-ref
            }, {
                provide: KendoInput,
                useExisting: forwardRef(() => ColorPaletteComponent_1)
            },
            ColorPaletteService,
            ColorPaletteLocalizationService,
            {
                provide: LocalizationService,
                useExisting: ColorPaletteLocalizationService
            },
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.colorpalette'
            }
        ],
        template: `
        <ng-container kendoColorPaletteLocalizedMessages
            i18n-colorPaletteNoColor="kendo.colorpalette.colorPaletteNoColor|The aria-label applied to the ColorPalette component when the value is empty."
            colorPaletteNoColor="Colorpalette no color chosen">
        </ng-container>
        <div role="listbox"
            [attr.aria-activedescendant]="activeCellId">
            <table class="k-palette k-reset">
                <tbody>
                    <tr *ngFor="let row of colorRows; let rowIndex = index">
                        <td *ngFor="let color of row; let colIndex = index"
                            role="option"
                            [class.k-state-selected]="focusedCell?.row === rowIndex && focusedCell?.col === colIndex"
                            [attr.aria-selected]="focusedCell?.row === rowIndex && focusedCell?.col === colIndex"
                            [attr.aria-label]="color"
                            class="k-item"
                            [id]="rowIndex + '' + colIndex"
                            [attr.value]="color"
                            (click)="handleCellSelection(color, { row: rowIndex, col: colIndex })"
                            [ngStyle]="{
                                backgroundColor: color,
                                width: tileLayout.width + 'px',
                                height: tileLayout.height + 'px',
                                minWidth: tileLayout.width + 'px'
                            }">
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    `
    }),
    tslib_1.__metadata("design:paramtypes", [ElementRef,
        ColorPaletteService,
        ChangeDetectorRef,
        Renderer2,
        LocalizationService])
], ColorPaletteComponent);
export { ColorPaletteComponent };
