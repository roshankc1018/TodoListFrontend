/**-----------------------------------------------------------------------------------------
* Copyright Â© 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
var ColorGradientComponent_1;
import { Component, Input, ViewChild, ElementRef, Renderer2, NgZone, Output, EventEmitter, HostBinding, forwardRef, ChangeDetectorRef } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { parseColor, getHSV, getColorFromHSV, getColorFromHue } from './utils';
import { isPresent, fitIntoBounds } from '../common/utils';
import { isChanged, isDocumentAvailable, KendoInput } from '@progress/kendo-angular-common';
import { containsFocus, isUntouched } from '../common/dom-utils';
import { SliderComponent } from '../slider/slider.component';
const DEFAULT_OUTPUT_FORMAT = 'rgba';
const DEFAULT_BACKGROUND_COLOR = 'rgba(255, 0, 0, 1)';
import { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';
import { Subject } from 'rxjs';
import { ColorGradientLocalizationService } from './localization/colorgradient-localization.service';
import { ColorInputComponent } from './color-input.component';
import { throttleTime } from 'rxjs/operators';
let serial = 0;
const DRAGHANDLE_MOVE_SPEED = 5;
/**
 * The ColorGradient component enables smooth color transitions and provides options for selecting specific colors over the drag handle.
 * The ColorGradient is independently used by `kendo-colorpicker` and can be directly added to the page.
 */
let ColorGradientComponent = ColorGradientComponent_1 = class ColorGradientComponent {
    constructor(host, ngZone, renderer, cdr, localizationService) {
        this.host = host;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.cdr = cdr;
        this.localizationService = localizationService;
        /**
         * @hidden
         */
        this.hostClasses = true;
        /**
         * @hidden
         */
        this.id = `k-colorgradient-${serial++}`;
        /**
         * Defines whether the alpha slider will be displayed.
         */
        this.opacity = true;
        /**
         * Sets the disabled state of the ColorGradient.
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the ColorGradient.
         */
        this.readonly = false;
        /**
         * Specifies whether the ColorGradient should display a 'Clear color' button.
         */
        this.clearButton = false;
        /**
         * Determines the delay time (in milliseconds) before the value is changed on handle drag. A value of 0 indicates no delay.
         *
         * @default 0
         */
        this.delay = 0;
        /**
         * Fires each time the user selects a new color.
         */
        this.valueChange = new EventEmitter();
        /**
         * @hidden
         */
        this.backgroundColor = DEFAULT_BACKGROUND_COLOR;
        /**
         * @hidden
         *
         * Represents the currently selected `hue`, `saturation`, `value`, and `alpha` values.
         * The values are initially set in `ngOnInit` or in `ngOnChanges` and are
         * updated on moving the drag handle or the sliders.
         */
        this.hsva = {};
        /**
         * Specifies the output format of the ColorGradientComponent.
         * The input value may be in a different format. However, it will be parsed into the output `format`
         * after the component processes it.
         *
         * The supported values are:
         * * (Default) `rgba`
         * * `hex`
         */
        this.format = DEFAULT_OUTPUT_FORMAT;
        this._tabindex = 0;
        this.listeners = [];
        this.updateValues = new Subject();
        this.notifyNgChanged = () => { };
        this.notifyNgTouched = () => { };
        this.dynamicRTLSubscription = localizationService.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
    }
    /**
     * @hidden
     */
    get readonlyAttribute() {
        return this.readonly;
    }
    /**
     * @hidden
     */
    get disabledClass() {
        return this.disabled;
    }
    /**
     * @hidden
     */
    get hostTabindex() {
        return this.tabindex;
    }
    /**
     * @hidden
     */
    get gradientId() {
        return this.id;
    }
    /**
     * Specifies the value of the initially selected color.
     */
    set value(value) {
        this._value = parseColor(value, this.format);
    }
    get value() {
        return this._value;
    }
    /**
     * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
     */
    set tabindex(value) {
        const tabindex = Number(value);
        const defaultValue = 0;
        this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;
    }
    get tabindex() {
        return !this.disabled ? this._tabindex : undefined;
    }
    /**
     * Indicates whether the ColorGradient or any of its content is focused.
     */
    get isFocused() {
        if (!(isDocumentAvailable() && isPresent(this.host))) {
            return false;
        }
        return this.host.nativeElement === document.activeElement || this.host.nativeElement.contains(document.activeElement);
    }
    /**
     * @hidden
     */
    get alphaSliderValue() {
        // setting the initial value to undefined to force the slider to recalculate the height of the slider track on the next cdr run
        if (!(isPresent(this.hsva) && isPresent(this.hsva.a))) {
            return;
        }
        return this.hsva.a * 100;
    }
    get gradientRect() {
        return this.gradientWrapper.nativeElement.getBoundingClientRect();
    }
    ngAfterViewInit() {
        this.updateUI();
        this.cdr.detectChanges();
        this.addEventListeners();
        this.subscribeChanges();
    }
    ngOnChanges(changes) {
        if (isChanged('value', changes) && !this.isFocused) {
            this.updateUI();
        }
        if (isChanged('delay', changes)) {
            this.unsubscribeChanges();
            this.subscribeChanges();
        }
    }
    ngOnDestroy() {
        this.listeners.forEach(removeListener => removeListener());
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
        this.unsubscribeChanges();
    }
    /**
     * Focuses the component.
     */
    focus() {
        if (this.disabled) {
            return;
        }
        this.host.nativeElement.focus();
    }
    /**
     * @hidden
     */
    reset() {
        this.handleValueChange(undefined);
        this.updateUI();
        this.host.nativeElement.focus();
    }
    /**
     * @hidden
     */
    handleDragPress(args) {
        if (this.disabled || this.readonly || !isPresent(args.originalEvent)) {
            return;
        }
        this.focus();
        args.originalEvent.preventDefault();
    }
    /**
     * @hidden
     */
    onHandleDrag(args) {
        if (this.disabled || this.readonly) {
            return;
        }
        this.renderer.addClass(this.gradientWrapper.nativeElement, 'k-dragging');
        this.changePosition(args);
    }
    /**
     * @hidden
     */
    onHandleRelease() {
        if (this.disabled || this.readonly) {
            return;
        }
        this.renderer.removeClass(this.gradientWrapper.nativeElement, 'k-dragging');
        this.handleValueChange(getColorFromHSV(this.hsva));
    }
    /**
     * @hidden
     */
    onKeyboardAction(args) {
        if (this.disabled || this.readonly) {
            return;
        }
        if (args.key && args.key.indexOf('Arrow') !== -1) {
            args.preventDefault();
            const dragHandleElement = this.gradientDragHandle.nativeElement;
            this.renderer.addClass(this.gradientWrapper.nativeElement, 'k-dragging');
            let keyboardMoveX = 0;
            let keyboardMoveY = 0;
            switch (args.key) {
                case 'ArrowRight':
                    keyboardMoveX = DRAGHANDLE_MOVE_SPEED;
                    break;
                case 'ArrowLeft':
                    keyboardMoveX = -DRAGHANDLE_MOVE_SPEED;
                    break;
                case 'ArrowUp':
                    keyboardMoveY = -DRAGHANDLE_MOVE_SPEED;
                    break;
                case 'ArrowDown':
                    keyboardMoveY = DRAGHANDLE_MOVE_SPEED;
                    break;
                default: break;
            }
            const newY = parseInt(dragHandleElement.style.top, 10) + keyboardMoveY;
            const newX = parseInt(dragHandleElement.style.left, 10) + keyboardMoveX;
            this.renderer.setStyle(dragHandleElement, 'top', `${newY}px`);
            this.renderer.setStyle(dragHandleElement, 'left', `${newX}px`);
            this.ngZone.run(() => this.moveDragHandle(newX, newY));
        }
    }
    /**
     * @hidden
     */
    changePosition(position) {
        if (this.disabled || this.readonly) {
            return;
        }
        this.gradientDragHandle.nativeElement.focus();
        const newX = position.clientX - this.gradientRect.left;
        const newY = position.clientY - this.gradientRect.top;
        this.ngZone.run(() => this.moveDragHandle(newX, newY));
    }
    /**
     * @hidden
     */
    handleHueSliderChange(hue) {
        this.handleValueChange(getColorFromHSV(this.hsva));
        this.backgroundColor = getColorFromHue(hue);
        this.setAlphaSliderBackground(this.backgroundColor);
    }
    /**
     * @hidden
     */
    handleAlphaSliderChange(alpha) {
        this.hsva.a = alpha / 100;
        this.handleValueChange(getColorFromHSV(this.hsva));
    }
    /**
     * @hidden
     */
    handleInputsValueChange(color) {
        const parsed = parseColor(color, this.format);
        if (this.value !== parsed) {
            this.handleValueChange(parsed);
            this.updateUI();
        }
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.value = value;
        if (isPresent(this.gradientWrapper)) {
            this.updateUI();
        }
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.notifyNgChanged = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.notifyNgTouched = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.cdr.markForCheck();
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     */
    get colorGradientHandleTitle() {
        return this.localizationService.get('colorGradientHandle');
    }
    /**
     * @hidden
     */
    get colorGradientHandleAriaLabel() {
        const parsed = parseColor(this.value, this.format);
        return `${this.value ? parsed : this.localizationService.get('colorGradientHandle')}`;
    }
    /**
     * @hidden
     */
    get hueSliderTitle() {
        return this.localizationService.get('hueSliderHandle');
    }
    /**
     * @hidden
     */
    get opacitySliderTitle() {
        return this.localizationService.get('opacitySliderHandle');
    }
    /**
     * @hidden
     */
    get clearButtonTitle() {
        return this.localizationService.get('clearButton');
    }
    /**
     * @hidden
     * Used by the TextBoxContainer to determine if the component is empty.
     */
    isEmpty() {
        return false;
    }
    moveDragHandle(positionX, positionY) {
        const top = fitIntoBounds(positionY, 0, this.gradientRect.height);
        const left = fitIntoBounds(positionX, 0, this.gradientRect.width);
        this.setDragHandleElementPosition(top, left);
        this.hsva.s = left / this.gradientRect.width;
        this.hsva.v = 1 - top / this.gradientRect.height;
        this.updateValues.next(getColorFromHSV(this.hsva));
        this.setAlphaSliderBackground(getColorFromHSV(Object.assign({}, this.hsva, { a: 1 })));
    }
    updateUI() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.hsva = this.value ? getHSV(this.value) : { h: 0, s: 0, v: 1, a: 1 };
        const top = (1 - this.hsva.v) * this.gradientRect.height;
        const left = this.hsva.s * this.gradientRect.width;
        this.setDragHandleElementPosition(top, left);
        this.backgroundColor = getColorFromHue(this.hsva.h);
        this.setAlphaSliderBackground(this.backgroundColor);
        this.setHostElementAriaLabel();
    }
    handleValueChange(color) {
        if (this.value === color) {
            return;
        }
        this.value = color;
        this.valueChange.emit(color);
        this.notifyNgChanged(color);
        this.setHostElementAriaLabel();
    }
    setDragHandleElementPosition(top, left) {
        const dragHandle = this.gradientDragHandle.nativeElement;
        this.renderer.setStyle(dragHandle, 'top', `${top}px`);
        this.renderer.setStyle(dragHandle, 'left', `${left}px`);
    }
    setAlphaSliderBackground(backgroundColor) {
        if (!isPresent(this.alphaSlider)) {
            return;
        }
        const sliderTrack = this.alphaSlider.track.nativeElement;
        this.renderer.setStyle(sliderTrack, 'background', `linear-gradient(to top, transparent, ${backgroundColor})`);
    }
    setHostElementAriaLabel() {
        const parsed = parseColor(this.value, this.format);
        this.renderer.setAttribute(this.host.nativeElement, 'aria-label', `${this.value ? parsed : this.localizationService.get('colorGradientNoColor')}`);
    }
    addEventListeners() {
        this.ngZone.runOutsideAngular(() => {
            const focusOutListener = this.renderer.listen(this.host.nativeElement, 'focusout', (event) => {
                if (!containsFocus(this.host.nativeElement, event.relatedTarget) && isUntouched(this.host)) {
                    this.ngZone.run(() => this.notifyNgTouched());
                }
            });
            const keydownListener = this.renderer.listen(this.gradientDragHandle.nativeElement, 'keydown', (event) => {
                this.onKeyboardAction(event);
            });
            const keyupListener = this.renderer.listen(this.gradientDragHandle.nativeElement, 'keyup', () => {
                this.renderer.removeClass(this.gradientWrapper.nativeElement, 'k-dragging');
                if (!this.readonly && !this.disabled) {
                    this.ngZone.run(() => this.handleValueChange(getColorFromHSV(this.hsva)));
                }
            });
            const dragHandleFocusInListener = this.renderer.listen(this.gradientDragHandle.nativeElement, 'focusin', () => {
                this.renderer.addClass(this.gradientDragHandle.nativeElement, 'k-state-focus');
            });
            const dragHandleFocusOutListener = this.renderer.listen(this.gradientDragHandle.nativeElement, 'focusout', () => {
                this.renderer.removeClass(this.gradientDragHandle.nativeElement, 'k-state-focus');
            });
            this.listeners.push(focusOutListener, keydownListener, keyupListener, dragHandleFocusInListener, dragHandleFocusOutListener);
        });
    }
    subscribeChanges() {
        this.changeRequestsSubscription = this.updateValues.pipe(throttleTime(this.delay)).subscribe(value => {
            this.handleValueChange(value);
        });
    }
    unsubscribeChanges() {
        if (this.changeRequestsSubscription) {
            this.changeRequestsSubscription.unsubscribe();
        }
    }
};
tslib_1.__decorate([
    HostBinding('class.k-widget'),
    HostBinding('class.k-flatcolorpicker'),
    tslib_1.__metadata("design:type", Boolean)
], ColorGradientComponent.prototype, "hostClasses", void 0);
tslib_1.__decorate([
    HostBinding('attr.aria-readonly'),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [])
], ColorGradientComponent.prototype, "readonlyAttribute", null);
tslib_1.__decorate([
    HostBinding('class.k-state-disabled'),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [])
], ColorGradientComponent.prototype, "disabledClass", null);
tslib_1.__decorate([
    HostBinding('attr.tabindex'),
    tslib_1.__metadata("design:type", Number),
    tslib_1.__metadata("design:paramtypes", [])
], ColorGradientComponent.prototype, "hostTabindex", null);
tslib_1.__decorate([
    HostBinding('attr.id'),
    tslib_1.__metadata("design:type", String),
    tslib_1.__metadata("design:paramtypes", [])
], ColorGradientComponent.prototype, "gradientId", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], ColorGradientComponent.prototype, "id", void 0);
tslib_1.__decorate([
    HostBinding('attr.dir'),
    tslib_1.__metadata("design:type", String)
], ColorGradientComponent.prototype, "direction", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], ColorGradientComponent.prototype, "opacity", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], ColorGradientComponent.prototype, "disabled", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], ColorGradientComponent.prototype, "readonly", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], ColorGradientComponent.prototype, "clearButton", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number)
], ColorGradientComponent.prototype, "delay", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String),
    tslib_1.__metadata("design:paramtypes", [String])
], ColorGradientComponent.prototype, "value", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number),
    tslib_1.__metadata("design:paramtypes", [Number])
], ColorGradientComponent.prototype, "tabindex", null);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], ColorGradientComponent.prototype, "valueChange", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], ColorGradientComponent.prototype, "format", void 0);
tslib_1.__decorate([
    ViewChild('gradientDragHandle', { read: ElementRef, static: false }),
    tslib_1.__metadata("design:type", ElementRef)
], ColorGradientComponent.prototype, "gradientDragHandle", void 0);
tslib_1.__decorate([
    ViewChild('inputs', { static: false }),
    tslib_1.__metadata("design:type", ColorInputComponent)
], ColorGradientComponent.prototype, "inputs", void 0);
tslib_1.__decorate([
    ViewChild('alphaSlider', { static: false }),
    tslib_1.__metadata("design:type", SliderComponent)
], ColorGradientComponent.prototype, "alphaSlider", void 0);
tslib_1.__decorate([
    ViewChild('gradientWrapper', { static: false }),
    tslib_1.__metadata("design:type", ElementRef)
], ColorGradientComponent.prototype, "gradientWrapper", void 0);
ColorGradientComponent = ColorGradientComponent_1 = tslib_1.__decorate([
    Component({
        selector: 'kendo-colorgradient',
        providers: [
            {
                multi: true,
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => ColorGradientComponent_1)
            },
            {
                provide: KendoInput,
                useExisting: forwardRef(() => ColorGradientComponent_1)
            },
            ColorGradientLocalizationService,
            {
                provide: LocalizationService,
                useExisting: ColorGradientLocalizationService
            },
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.colorgradient'
            }
        ],
        template: `
        <ng-container kendoColorGradientLocalizedMessages
            i18n-colorGradientNoColor="kendo.colorgradient.colorGradientNoColor|The aria-label applied to the ColorGradient component when the value is empty."
            colorGradientNoColor="Colorgradient no color chosen"
            i18n-colorGradientHandle="kendo.colorgradient.colorGradientHandle|The title for the gradient color drag handle chooser."
            colorGradientHandle="Choose color"
            i18n-clearButton="kendo.colorgradient.clearButton|The title for the clear button."
            clearButton="Clear value"
            i18n-hueSliderHandle="kendo.colorgradient.hueSliderHandle|The title for the hue slider handle."
            hueSliderHandle="Set hue"
            i18n-opacitySliderHandle="kendo.colorgradient.opacitySliderHandle|The title for the opacity slider handle."
            opacitySliderHandle="Set opacity"
            i18n-hexInputPlaceholder="kendo.colorgradient.hexInputPlaceholder|The placeholder for the HEX color input."
            hexInputPlaceholder="HEX Color"
            i18n-redInputPlaceholder="kendo.colorgradient.redInputPlaceholder|The placeholder for the red color input."
            redInputPlaceholder="Red"
            i18n-greenInputPlaceholder="kendo.colorgradient.greenInputPlaceholder|The placeholder for the green color input."
            greenInputPlaceholder="Green"
            i18n-blueInputPlaceholder="kendo.colorgradient.blueInputPlaceholder|The placeholder for the blue color input."
            blueInputPlaceholder="Blue"
            i18n-alphaInputPlaceholder="kendo.colorgradient.alphaInputPlaceholder|The placeholder for the alpha input."
            alphaInputPlaceholder="Alpha">
        </ng-container>
        <div class="k-hbox k-hsv-wrap">
            <div class="k-hsv-rectangle" [style.background-color]="backgroundColor">
                <div
                    #gradientWrapper
                    kendoDraggable
                    class="k-hsv-gradient"
                    (click)="changePosition($event)"
                    (kendoPress)="handleDragPress($event)"
                    (kendoDrag)="onHandleDrag($event)"
                    (kendoRelease)="onHandleRelease()">
                    <div
                        #gradientDragHandle
                        class="k-draghandle"
                        tabindex="0"
                        [attr.title]="colorGradientHandleTitle"
                        [attr.aria-label]="colorGradientHandleAriaLabel"
                    >
                    </div>
                </div>
            </div>
            <div class="k-hbox k-sliders-wrap {{ clearButton ? 'k-sliders-wrap-clearable' : '' }}">
                <span class="k-clear-color k-button k-bare k-button-icon"
                    *ngIf="clearButton"
                    (click)="reset()"
                    (keydown.enter)="reset()"
                    (keydown.space)="reset()"
                    [attr.aria-label]="clearButtonTitle"
                    [attr.title]="clearButtonTitle"
                    tabindex="0">
                    <span class="k-icon k-i-reset-color"></span>
                </span>
                <kendo-slider
                    class="k-hue-slider"
                    [dragHandleTitle]="hueSliderTitle"
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [showButtons]="false"
                    [tickPlacement]="'none'"
                    [vertical]="true"
                    [min]="0"
                    [max]="360"
                    [smallStep]="5"
                    [largeStep]="10"
                    [(value)]="hsva.h"
                    (valueChange)="handleHueSliderChange($event)"
                >
                </kendo-slider>
                <kendo-slider
                    *ngIf="opacity && format === 'rgba'"
                    #alphaSlider
                    class="k-alpha-slider"
                    [dragHandleTitle]="opacitySliderTitle"
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [showButtons]="false"
                    [tickPlacement]="'none'"
                    [vertical]="true"
                    [min]="0"
                    [max]="100"
                    [smallStep]="1"
                    [largeStep]="10"
                    [value]="alphaSliderValue"
                    (valueChange)="handleAlphaSliderChange($event)"
                >
                </kendo-slider>
            </div>
        </div>
        <kendo-colorinput  #inputs
            [opacity]="opacity"
            [value]="value"
            [disabled]="disabled"
            [readonly]="readonly"
            (valueChange)="handleInputsValueChange($event)"
        >
        </kendo-colorinput>
`
    }),
    tslib_1.__metadata("design:paramtypes", [ElementRef,
        NgZone,
        Renderer2,
        ChangeDetectorRef,
        LocalizationService])
], ColorGradientComponent);
export { ColorGradientComponent };
