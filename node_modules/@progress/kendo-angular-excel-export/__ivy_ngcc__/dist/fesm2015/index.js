/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { __decorate, __metadata, __param } from 'tslib';
import { Input, ContentChildren, QueryList, Component, NgZone, Directive, Optional, TemplateRef, ContentChild, forwardRef, SkipSelf, Host, NgModule } from '@angular/core';
import { saveAs } from '@progress/kendo-file-saver';
import { IntlService, ExcelExporter, Workbook } from '@progress/kendo-ooxml';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@progress/kendo-angular-l10n';
export * from '@progress/kendo-ooxml';
import { toString } from '@telerik/kendo-intl';
import { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';
import { validatePackage } from '@progress/kendo-licensing';

/* tslint:disable align */
/* tslint:disable:no-use-before-declare */
const compileTemplate = (templateRef, context, updateContext) => {
    let embeddedView = templateRef.createEmbeddedView(context);
    const result = (data) => {
        updateContext(context, data);
        embeddedView.detectChanges();
        return embeddedView.rootNodes.reduce((content, rootNode) => {
            return content + rootNode.textContent;
        }, '').trim();
    };
    result.destroy = () => {
        embeddedView.destroy();
        embeddedView = null;
    };
    return result;
};
const updateGroupHeaderContext = (context, data) => {
    context.$implicit = context.group = data;
    context.field = data.field;
    context.value = data.value;
    context.aggregates = data.aggregates;
};
const updateGroupFooterContext = (context, data) => {
    context.group = data.group;
    context.$implicit = context.aggregates = data;
};
const updateFooterContext = (context, data) => {
    context.aggregates = data.aggregates;
};
/**
 * @hidden
 */
const toExporterColumns = (sourceColumns) => {
    const exporterColumns = [];
    let columnIndex = 0;
    const addColumns = (columns, result, level) => {
        columns.forEach((column) => {
            if (column.level === level) {
                const exporterColumn = new ExporterColumn(column, columnIndex);
                result.push(exporterColumn);
                if (column.children && column.children.some(c => c !== column)) {
                    const children = exporterColumn.columns = [];
                    addColumns(column.children, children, level + 1);
                }
                else {
                    columnIndex++;
                }
            }
        });
    };
    addColumns(sourceColumns, exporterColumns, 0);
    return exporterColumns;
};
/**
 * @hidden
 */
const destroyColumns = (columns) => {
    if (columns) {
        columns.forEach(column => {
            column.destroy();
        });
    }
};
/**
 * @hidden
 */
class ExporterColumn {
    constructor(column, columnIndex) {
        this.title = column.title;
        this.field = column.field;
        this.hidden = column.hidden;
        this.locked = column.locked;
        this.width = column.width;
        this.headerCellOptions = column.headerCellOptions;
        this.cellOptions = column.cellOptions;
        this.groupHeaderCellOptions = column.groupHeaderCellOptions;
        this.groupFooterCellOptions = column.groupFooterCellOptions;
        this.footerCellOptions = column.footerCellOptions;
        if (column.footerTemplate) {
            this.footerTemplate = compileTemplate(column.footerTemplate.templateRef, {
                $implicit: column,
                column: column,
                columnIndex: columnIndex
            }, updateFooterContext);
        }
        if (column.groupFooterTemplate) {
            this.groupFooterTemplate = compileTemplate(column.groupFooterTemplate.templateRef, {
                column: column,
                field: column.field
            }, updateGroupFooterContext);
        }
        if (column.groupHeaderTemplate) {
            this.groupHeaderTemplate = compileTemplate(column.groupHeaderTemplate.templateRef, {}, updateGroupHeaderContext);
        }
        if (column.groupHeaderColumnTemplate) {
            this.groupHeaderColumnTemplate = compileTemplate(column.groupHeaderColumnTemplate.templateRef, {}, updateGroupHeaderContext);
        }
    }
    destroy() {
        if (this.footerTemplate) {
            this.footerTemplate.destroy();
        }
        if (this.groupFooterTemplate) {
            this.groupFooterTemplate.destroy();
        }
        if (this.groupHeaderTemplate) {
            this.groupHeaderTemplate.destroy();
        }
        if (this.groupHeaderColumnTemplate) {
            this.groupHeaderColumnTemplate.destroy();
        }
        destroyColumns(this.columns);
    }
}

IntlService.register({ toString });
/**
 *
 * @hidden
 */
const workbookOptions = (options) => {
    const columns = toExporterColumns(options.columns);
    const exporter = new ExcelExporter({
        columns: columns,
        data: options.data,
        filterable: options.filterable,
        groups: options.group,
        paddingCellOptions: options.paddingCellOptions,
        headerPaddingCellOptions: options.headerPaddingCellOptions,
        collapsible: options.collapsible,
        hierarchy: options.hierarchy,
        aggregates: options.aggregates
    });
    const result = exporter.workbook();
    result.creator = options.creator;
    result.date = options.date;
    result.rtl = options.rtl;
    destroyColumns(columns);
    return result;
};
/**
 * @hidden
 */
const toDataURL = (options) => {
    const workbook = new Workbook(options);
    return workbook.toDataURL();
};
/**
 * @hidden
 */
const isWorkbookOptions = (value) => {
    return value && value.sheets;
};

/**
 * @hidden
 */
class ColumnBase {
    constructor(parent) {
        this.parent = parent;
    }
    /**
     * @hidden
     */
    get level() {
        return this.parent ? this.parent.level + 1 : 0;
    }
}
ColumnBase.ɵfac = function ColumnBase_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
ColumnBase.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ColumnBase, contentQueries: function ColumnBase_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ColumnBase, 4);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, inputs: { title: "title", width: "width", locked: "locked", hidden: "hidden", headerCellOptions: "headerCellOptions" } });
__decorate([
    Input(),
    __metadata("design:type", String)
], ColumnBase.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ColumnBase.prototype, "width", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColumnBase.prototype, "locked", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ColumnBase.prototype, "hidden", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ColumnBase.prototype, "headerCellOptions", void 0);
__decorate([
    ContentChildren(ColumnBase),
    __metadata("design:type", QueryList)
], ColumnBase.prototype, "children", void 0);

/**
 * @hidden
 */
const packageMetadata = {
    name: '@progress/kendo-angular-excel-export',
    productName: 'Kendo UI for Angular',
    productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],
    publishDate: 1620213524,
    version: '',
    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'
};

/**
 * Represents the [Kendo UI Excel Export component for Angular]({% slug overview_excelexport %}).
 * Configures the settings for the Excel export of the Kendo UI Grid.
 */
let ExcelExportComponent = class ExcelExportComponent {
    constructor(localization, zone) {
        this.localization = localization;
        this.zone = zone;
        /**
         * Specifies the name of the file that is exported to Excel.
         * @default "Export.xlsx"
         */
        this.fileName = 'Export.xlsx';
        /**
         * @hidden
         */
        this.columns = new QueryList();
        validatePackage(packageMetadata);
        this.saveFile = this.saveFile.bind(this);
    }
    /**
     * Saves the data to Excel.
     *
     * @param exportData - An optional parameter. Can be the data that will be exported or [`WorkbookOptions`]({% slug api_excel-export_workbookoptions %}).
     */
    save(exportData) {
        this.toDataURL(exportData).then(this.saveFile);
    }
    /**
     * Based on the specified columns and data, returns
     * [`WorkbookOptions`]({% slug api_excel-export_workbookoptions %})
     * ([see example]({% slug customrowsandcells_excelexport %})).
     *
     * @param exportData - The optional data to be exported.
     * @returns {WorkbookOptions} - The workbook options.
     */
    workbookOptions(exportData) {
        const currentData = this.getExportData(exportData);
        const options = workbookOptions({
            columns: this.columns,
            data: currentData.data,
            group: currentData.group,
            filterable: this.filterable,
            creator: this.creator,
            date: this.date,
            rtl: this.localization.rtl,
            paddingCellOptions: this.paddingCellOptions,
            headerPaddingCellOptions: this.headerPaddingCellOptions,
            collapsible: this.collapsible
        });
        return options;
    }
    /**
     * Returns a promise which will be resolved with the file data URI
     * ([see example]({% slug filesaving_excelexport %})).
     *
     * @param exportData - The optional data or [`WorkbookOptions`]({% slug api_excel-export_workbookoptions %}) that will be used to generate the data URI.
     * @returns {Promise<string>} - The promise that will be resolved by the file data URI.
     */
    toDataURL(exportData) {
        const options = isWorkbookOptions(exportData) ?
            exportData :
            this.workbookOptions(exportData);
        return this.zone.runOutsideAngular(() => toDataURL(options));
    }
    getExportData(exportData) {
        let result;
        if (exportData) {
            if (Array.isArray(exportData)) {
                result = {
                    data: exportData
                };
            }
            else {
                result = exportData;
            }
        }
        else {
            result = {
                data: this.data,
                group: this.group
            };
        }
        return result;
    }
    saveFile(dataURL) {
        saveAs(dataURL, this.fileName, {
            forceProxy: this.forceProxy,
            proxyURL: this.proxyURL
        });
    }
};
ExcelExportComponent.ɵfac = function ExcelExportComponent_Factory(t) { return new (t || ExcelExportComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
ExcelExportComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ExcelExportComponent, selectors: [["kendo-excelexport"]], contentQueries: function ExcelExportComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ColumnBase, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columns = _t);
    } }, inputs: { fileName: "fileName", filterable: "filterable", collapsible: "collapsible", creator: "creator", date: "date", forceProxy: "forceProxy", proxyURL: "proxyURL", data: "data", group: "group", paddingCellOptions: "paddingCellOptions", headerPaddingCellOptions: "headerPaddingCellOptions" }, exportAs: ["kendoExcelExport"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.excelexport'
            }
        ])], decls: 0, vars: 0, template: function ExcelExportComponent_Template(rf, ctx) { }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", String)
], ExcelExportComponent.prototype, "fileName", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ExcelExportComponent.prototype, "filterable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ExcelExportComponent.prototype, "collapsible", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ExcelExportComponent.prototype, "creator", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], ExcelExportComponent.prototype, "date", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ExcelExportComponent.prototype, "forceProxy", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ExcelExportComponent.prototype, "proxyURL", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], ExcelExportComponent.prototype, "data", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], ExcelExportComponent.prototype, "group", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ExcelExportComponent.prototype, "paddingCellOptions", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ExcelExportComponent.prototype, "headerPaddingCellOptions", void 0);
__decorate([
    ContentChildren(ColumnBase, { descendants: true }),
    __metadata("design:type", QueryList)
], ExcelExportComponent.prototype, "columns", void 0);
ExcelExportComponent = __decorate([ __metadata("design:paramtypes", [LocalizationService, NgZone])
], ExcelExportComponent);

/**
 * Represents the group header cell template of the Excel Export column component
 * ([see example]({% slug columns_excel-export %}#toc-group-header-template)).
 * Enables you to customize the content of the group header item.
 */
let GroupHeaderTemplateDirective = class GroupHeaderTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
GroupHeaderTemplateDirective.ɵfac = function GroupHeaderTemplateDirective_Factory(t) { return new (t || GroupHeaderTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
GroupHeaderTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: GroupHeaderTemplateDirective, selectors: [["", "kendoExcelExportGroupHeaderTemplate", ""]] });
GroupHeaderTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], GroupHeaderTemplateDirective);

/**
 * Represents the group header column template of the Excel Export column component
 * ([see example]({% slug columns_excel-export %}#toc-group-header-column-template)).
 */
let GroupHeaderColumnTemplateDirective = class GroupHeaderColumnTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
GroupHeaderColumnTemplateDirective.ɵfac = function GroupHeaderColumnTemplateDirective_Factory(t) { return new (t || GroupHeaderColumnTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
GroupHeaderColumnTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: GroupHeaderColumnTemplateDirective, selectors: [["", "kendoExcelExportGroupHeaderColumnTemplate", ""]] });
GroupHeaderColumnTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], GroupHeaderColumnTemplateDirective);

/**
 * Represents the group footer cell template of the Excel Export column component
 * ([see example]({% slug columns_excel-export %}#toc-group-footer-template)).
 * Enables you to customize the group footer cell of the column.
 */
let GroupFooterTemplateDirective = class GroupFooterTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
GroupFooterTemplateDirective.ɵfac = function GroupFooterTemplateDirective_Factory(t) { return new (t || GroupFooterTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
GroupFooterTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: GroupFooterTemplateDirective, selectors: [["", "kendoExcelExportGroupFooterTemplate", ""]] });
GroupFooterTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], GroupFooterTemplateDirective);

/**
 * Represents the footer cell template of the Excel Export column component
 * ([see example]({% slug columns_excel-export %}#toc-footer-template)).
 * Enables you to customize the footer cell of the column.
 */
let FooterTemplateDirective = class FooterTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
FooterTemplateDirective.ɵfac = function FooterTemplateDirective_Factory(t) { return new (t || FooterTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
FooterTemplateDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: FooterTemplateDirective, selectors: [["", "kendoExcelExportFooterTemplate", ""]] });
FooterTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], FooterTemplateDirective);

var ColumnComponent_1;
/**
 * Represents the columns of the Kendo UI Excel Export component for Angular.
 */
let ColumnComponent = ColumnComponent_1 = class ColumnComponent extends ColumnBase {
    constructor(parent) {
        super(parent);
    }
};
ColumnComponent.ɵfac = function ColumnComponent_Factory(t) { return new (t || ColumnComponent)(ɵngcc0.ɵɵdirectiveInject(ColumnBase, 13)); };
ColumnComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ColumnComponent, selectors: [["kendo-excelexport-column"]], contentQueries: function ColumnComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, GroupHeaderTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, GroupHeaderColumnTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, GroupFooterTemplateDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.groupHeaderTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.groupHeaderColumnTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.groupFooterTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
    } }, inputs: { field: "field", cellOptions: "cellOptions", groupHeaderCellOptions: "groupHeaderCellOptions", groupFooterCellOptions: "groupFooterCellOptions", footerCellOptions: "footerCellOptions" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: ColumnBase,
                useExisting: forwardRef(() => ColumnComponent_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function ColumnComponent_Template(rf, ctx) { }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", String)
], ColumnComponent.prototype, "field", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ColumnComponent.prototype, "cellOptions", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ColumnComponent.prototype, "groupHeaderCellOptions", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ColumnComponent.prototype, "groupFooterCellOptions", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ColumnComponent.prototype, "footerCellOptions", void 0);
__decorate([
    ContentChild(GroupHeaderTemplateDirective, { static: false }),
    __metadata("design:type", GroupHeaderTemplateDirective)
], ColumnComponent.prototype, "groupHeaderTemplate", void 0);
__decorate([
    ContentChild(GroupHeaderColumnTemplateDirective, { static: false }),
    __metadata("design:type", GroupHeaderColumnTemplateDirective)
], ColumnComponent.prototype, "groupHeaderColumnTemplate", void 0);
__decorate([
    ContentChild(GroupFooterTemplateDirective, { static: false }),
    __metadata("design:type", GroupFooterTemplateDirective)
], ColumnComponent.prototype, "groupFooterTemplate", void 0);
__decorate([
    ContentChild(FooterTemplateDirective, { static: false }),
    __metadata("design:type", FooterTemplateDirective)
], ColumnComponent.prototype, "footerTemplate", void 0);
ColumnComponent = ColumnComponent_1 = __decorate([ __param(0, SkipSelf()), __param(0, Host()), __param(0, Optional()),
    __metadata("design:paramtypes", [ColumnBase])
], ColumnComponent);

var ColumnGroupComponent_1;
/**
 * Represents the column group component of the Kendo UI Excel Export component.
 */
let ColumnGroupComponent = ColumnGroupComponent_1 = class ColumnGroupComponent extends ColumnBase {
    constructor(parent) {
        super(parent);
        this.parent = parent;
    }
};
ColumnGroupComponent.ɵfac = function ColumnGroupComponent_Factory(t) { return new (t || ColumnGroupComponent)(ɵngcc0.ɵɵdirectiveInject(ColumnBase, 13)); };
ColumnGroupComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ColumnGroupComponent, selectors: [["kendo-excelexport-column-group"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: ColumnBase,
                useExisting: forwardRef(() => ColumnGroupComponent_1) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function ColumnGroupComponent_Template(rf, ctx) { }, encapsulation: 2 });
ColumnGroupComponent = ColumnGroupComponent_1 = __decorate([ __param(0, SkipSelf()), __param(0, Host()), __param(0, Optional()),
    __metadata("design:paramtypes", [ColumnBase])
], ColumnGroupComponent);

const declarations = [
    ExcelExportComponent,
    ColumnComponent,
    ColumnGroupComponent,
    FooterTemplateDirective,
    GroupFooterTemplateDirective,
    GroupHeaderTemplateDirective,
    GroupHeaderColumnTemplateDirective
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Excel Export component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the ExcelExportModule module
 * import { ExcelExportModule } from '@progress/kendo-angular-excel-export';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, ExcelExportModule], // import ExcelExportModule module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
let ExcelExportModule = class ExcelExportModule {
};
ExcelExportModule.ɵfac = function ExcelExportModule_Factory(t) { return new (t || ExcelExportModule)(); };
ExcelExportModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: ExcelExportModule });
ExcelExportModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ExcelExportComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoExcelExport',
                selector: 'kendo-excelexport',
                providers: [
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.excelexport'
                    }
                ],
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }, { type: ɵngcc0.NgZone }]; }, { fileName: [{
            type: Input
        }], columns: [{
            type: ContentChildren,
            args: [ColumnBase, { descendants: true }]
        }], filterable: [{
            type: Input
        }], collapsible: [{
            type: Input
        }], creator: [{
            type: Input
        }], date: [{
            type: Input
        }], forceProxy: [{
            type: Input
        }], proxyURL: [{
            type: Input
        }], data: [{
            type: Input
        }], group: [{
            type: Input
        }], paddingCellOptions: [{
            type: Input
        }], headerPaddingCellOptions: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GroupHeaderTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoExcelExportGroupHeaderTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GroupHeaderColumnTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoExcelExportGroupHeaderColumnTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GroupFooterTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoExcelExportGroupFooterTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FooterTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoExcelExportFooterTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColumnComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: ColumnBase,
                        useExisting: forwardRef(() => ColumnComponent_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-excelexport-column',
                template: ``
            }]
    }], function () { return [{ type: ColumnBase, decorators: [{
                type: SkipSelf
            }, {
                type: Host
            }, {
                type: Optional
            }] }]; }, { field: [{
            type: Input
        }], cellOptions: [{
            type: Input
        }], groupHeaderCellOptions: [{
            type: Input
        }], groupFooterCellOptions: [{
            type: Input
        }], footerCellOptions: [{
            type: Input
        }], groupHeaderTemplate: [{
            type: ContentChild,
            args: [GroupHeaderTemplateDirective, { static: false }]
        }], groupHeaderColumnTemplate: [{
            type: ContentChild,
            args: [GroupHeaderColumnTemplateDirective, { static: false }]
        }], groupFooterTemplate: [{
            type: ContentChild,
            args: [GroupFooterTemplateDirective, { static: false }]
        }], footerTemplate: [{
            type: ContentChild,
            args: [FooterTemplateDirective, { static: false }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ColumnGroupComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: ColumnBase,
                        useExisting: forwardRef(() => ColumnGroupComponent_1) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-excelexport-column-group',
                template: ``
            }]
    }], function () { return [{ type: ColumnBase, decorators: [{
                type: SkipSelf
            }, {
                type: Host
            }, {
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ExcelExportModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations],
                exports: [declarations]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ExcelExportModule, { declarations: [ExcelExportComponent, ColumnComponent, ColumnGroupComponent, FooterTemplateDirective, GroupFooterTemplateDirective, GroupHeaderTemplateDirective, GroupHeaderColumnTemplateDirective], exports: [ExcelExportComponent, ColumnComponent, ColumnGroupComponent, FooterTemplateDirective, GroupFooterTemplateDirective, GroupHeaderTemplateDirective, GroupHeaderColumnTemplateDirective] }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { GroupHeaderColumnTemplateDirective, ExcelExportComponent, ExcelExportModule, ColumnBase, ColumnComponent, ColumnGroupComponent, FooterTemplateDirective, GroupFooterTemplateDirective, GroupHeaderTemplateDirective, workbookOptions, toDataURL, isWorkbookOptions };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OzttSUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OzttSEFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQWFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztpTEFBRTtBQUNGLDJDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzttTUFBRTtBQUNGLGlEQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2lMQUFFO0FBQ0YsMkNBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7a0tBQUU7QUFDRixzQ0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lKQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBV0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztzSkFBRTtBQUNGLDREQVdHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z2dCQU1zQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiBDb3B5cmlnaHQgwqkgMjAyMCBQcm9ncmVzcyBTb2Z0d2FyZSBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiogTGljZW5zZWQgdW5kZXIgY29tbWVyY2lhbCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBpbiB0aGUgcHJvamVjdCByb290IGZvciBtb3JlIGluZm9ybWF0aW9uXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBfX2RlY29yYXRlLCBfX21ldGFkYXRhLCBfX3BhcmFtIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgSW5wdXQsIENvbnRlbnRDaGlsZHJlbiwgUXVlcnlMaXN0LCBDb21wb25lbnQsIE5nWm9uZSwgRGlyZWN0aXZlLCBPcHRpb25hbCwgVGVtcGxhdGVSZWYsIENvbnRlbnRDaGlsZCwgZm9yd2FyZFJlZiwgU2tpcFNlbGYsIEhvc3QsIE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBzYXZlQXMgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tZmlsZS1zYXZlcic7XG5pbXBvcnQgeyBJbnRsU2VydmljZSwgRXhjZWxFeHBvcnRlciwgV29ya2Jvb2sgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tb294bWwnO1xuZXhwb3J0ICogZnJvbSAnQHByb2dyZXNzL2tlbmRvLW9veG1sJztcbmltcG9ydCB7IHRvU3RyaW5nIH0gZnJvbSAnQHRlbGVyaWsva2VuZG8taW50bCc7XG5pbXBvcnQgeyBMb2NhbGl6YXRpb25TZXJ2aWNlLCBMMTBOX1BSRUZJWCB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWwxMG4nO1xuaW1wb3J0IHsgdmFsaWRhdGVQYWNrYWdlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWxpY2Vuc2luZyc7XG5cbi8qIHRzbGludDpkaXNhYmxlIGFsaWduICovXG4vKiB0c2xpbnQ6ZGlzYWJsZTpuby11c2UtYmVmb3JlLWRlY2xhcmUgKi9cbmNvbnN0IGNvbXBpbGVUZW1wbGF0ZSA9ICh0ZW1wbGF0ZVJlZiwgY29udGV4dCwgdXBkYXRlQ29udGV4dCkgPT4ge1xuICAgIGxldCBlbWJlZGRlZFZpZXcgPSB0ZW1wbGF0ZVJlZi5jcmVhdGVFbWJlZGRlZFZpZXcoY29udGV4dCk7XG4gICAgY29uc3QgcmVzdWx0ID0gKGRhdGEpID0+IHtcbiAgICAgICAgdXBkYXRlQ29udGV4dChjb250ZXh0LCBkYXRhKTtcbiAgICAgICAgZW1iZWRkZWRWaWV3LmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgcmV0dXJuIGVtYmVkZGVkVmlldy5yb290Tm9kZXMucmVkdWNlKChjb250ZW50LCByb290Tm9kZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQgKyByb290Tm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgfSwgJycpLnRyaW0oKTtcbiAgICB9O1xuICAgIHJlc3VsdC5kZXN0cm95ID0gKCkgPT4ge1xuICAgICAgICBlbWJlZGRlZFZpZXcuZGVzdHJveSgpO1xuICAgICAgICBlbWJlZGRlZFZpZXcgPSBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5jb25zdCB1cGRhdGVHcm91cEhlYWRlckNvbnRleHQgPSAoY29udGV4dCwgZGF0YSkgPT4ge1xuICAgIGNvbnRleHQuJGltcGxpY2l0ID0gY29udGV4dC5ncm91cCA9IGRhdGE7XG4gICAgY29udGV4dC5maWVsZCA9IGRhdGEuZmllbGQ7XG4gICAgY29udGV4dC52YWx1ZSA9IGRhdGEudmFsdWU7XG4gICAgY29udGV4dC5hZ2dyZWdhdGVzID0gZGF0YS5hZ2dyZWdhdGVzO1xufTtcbmNvbnN0IHVwZGF0ZUdyb3VwRm9vdGVyQ29udGV4dCA9IChjb250ZXh0LCBkYXRhKSA9PiB7XG4gICAgY29udGV4dC5ncm91cCA9IGRhdGEuZ3JvdXA7XG4gICAgY29udGV4dC4kaW1wbGljaXQgPSBjb250ZXh0LmFnZ3JlZ2F0ZXMgPSBkYXRhO1xufTtcbmNvbnN0IHVwZGF0ZUZvb3RlckNvbnRleHQgPSAoY29udGV4dCwgZGF0YSkgPT4ge1xuICAgIGNvbnRleHQuYWdncmVnYXRlcyA9IGRhdGEuYWdncmVnYXRlcztcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgdG9FeHBvcnRlckNvbHVtbnMgPSAoc291cmNlQ29sdW1ucykgPT4ge1xuICAgIGNvbnN0IGV4cG9ydGVyQ29sdW1ucyA9IFtdO1xuICAgIGxldCBjb2x1bW5JbmRleCA9IDA7XG4gICAgY29uc3QgYWRkQ29sdW1ucyA9IChjb2x1bW5zLCByZXN1bHQsIGxldmVsKSA9PiB7XG4gICAgICAgIGNvbHVtbnMuZm9yRWFjaCgoY29sdW1uKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29sdW1uLmxldmVsID09PSBsZXZlbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cG9ydGVyQ29sdW1uID0gbmV3IEV4cG9ydGVyQ29sdW1uKGNvbHVtbiwgY29sdW1uSW5kZXgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGV4cG9ydGVyQ29sdW1uKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uLmNoaWxkcmVuICYmIGNvbHVtbi5jaGlsZHJlbi5zb21lKGMgPT4gYyAhPT0gY29sdW1uKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGV4cG9ydGVyQ29sdW1uLmNvbHVtbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgYWRkQ29sdW1ucyhjb2x1bW4uY2hpbGRyZW4sIGNoaWxkcmVuLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uSW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYWRkQ29sdW1ucyhzb3VyY2VDb2x1bW5zLCBleHBvcnRlckNvbHVtbnMsIDApO1xuICAgIHJldHVybiBleHBvcnRlckNvbHVtbnM7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGRlc3Ryb3lDb2x1bW5zID0gKGNvbHVtbnMpID0+IHtcbiAgICBpZiAoY29sdW1ucykge1xuICAgICAgICBjb2x1bW5zLmZvckVhY2goY29sdW1uID0+IHtcbiAgICAgICAgICAgIGNvbHVtbi5kZXN0cm95KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgRXhwb3J0ZXJDb2x1bW4ge1xuICAgIGNvbnN0cnVjdG9yKGNvbHVtbiwgY29sdW1uSW5kZXgpIHtcbiAgICAgICAgdGhpcy50aXRsZSA9IGNvbHVtbi50aXRsZTtcbiAgICAgICAgdGhpcy5maWVsZCA9IGNvbHVtbi5maWVsZDtcbiAgICAgICAgdGhpcy5oaWRkZW4gPSBjb2x1bW4uaGlkZGVuO1xuICAgICAgICB0aGlzLmxvY2tlZCA9IGNvbHVtbi5sb2NrZWQ7XG4gICAgICAgIHRoaXMud2lkdGggPSBjb2x1bW4ud2lkdGg7XG4gICAgICAgIHRoaXMuaGVhZGVyQ2VsbE9wdGlvbnMgPSBjb2x1bW4uaGVhZGVyQ2VsbE9wdGlvbnM7XG4gICAgICAgIHRoaXMuY2VsbE9wdGlvbnMgPSBjb2x1bW4uY2VsbE9wdGlvbnM7XG4gICAgICAgIHRoaXMuZ3JvdXBIZWFkZXJDZWxsT3B0aW9ucyA9IGNvbHVtbi5ncm91cEhlYWRlckNlbGxPcHRpb25zO1xuICAgICAgICB0aGlzLmdyb3VwRm9vdGVyQ2VsbE9wdGlvbnMgPSBjb2x1bW4uZ3JvdXBGb290ZXJDZWxsT3B0aW9ucztcbiAgICAgICAgdGhpcy5mb290ZXJDZWxsT3B0aW9ucyA9IGNvbHVtbi5mb290ZXJDZWxsT3B0aW9ucztcbiAgICAgICAgaWYgKGNvbHVtbi5mb290ZXJUZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5mb290ZXJUZW1wbGF0ZSA9IGNvbXBpbGVUZW1wbGF0ZShjb2x1bW4uZm9vdGVyVGVtcGxhdGUudGVtcGxhdGVSZWYsIHtcbiAgICAgICAgICAgICAgICAkaW1wbGljaXQ6IGNvbHVtbixcbiAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgICAgICBjb2x1bW5JbmRleDogY29sdW1uSW5kZXhcbiAgICAgICAgICAgIH0sIHVwZGF0ZUZvb3RlckNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2x1bW4uZ3JvdXBGb290ZXJUZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5ncm91cEZvb3RlclRlbXBsYXRlID0gY29tcGlsZVRlbXBsYXRlKGNvbHVtbi5ncm91cEZvb3RlclRlbXBsYXRlLnRlbXBsYXRlUmVmLCB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICAgICAgZmllbGQ6IGNvbHVtbi5maWVsZFxuICAgICAgICAgICAgfSwgdXBkYXRlR3JvdXBGb290ZXJDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sdW1uLmdyb3VwSGVhZGVyVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBIZWFkZXJUZW1wbGF0ZSA9IGNvbXBpbGVUZW1wbGF0ZShjb2x1bW4uZ3JvdXBIZWFkZXJUZW1wbGF0ZS50ZW1wbGF0ZVJlZiwge30sIHVwZGF0ZUdyb3VwSGVhZGVyQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbHVtbi5ncm91cEhlYWRlckNvbHVtblRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwSGVhZGVyQ29sdW1uVGVtcGxhdGUgPSBjb21waWxlVGVtcGxhdGUoY29sdW1uLmdyb3VwSGVhZGVyQ29sdW1uVGVtcGxhdGUudGVtcGxhdGVSZWYsIHt9LCB1cGRhdGVHcm91cEhlYWRlckNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmZvb3RlclRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmZvb3RlclRlbXBsYXRlLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ncm91cEZvb3RlclRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwRm9vdGVyVGVtcGxhdGUuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdyb3VwSGVhZGVyVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBIZWFkZXJUZW1wbGF0ZS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBIZWFkZXJDb2x1bW5UZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5ncm91cEhlYWRlckNvbHVtblRlbXBsYXRlLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBkZXN0cm95Q29sdW1ucyh0aGlzLmNvbHVtbnMpO1xuICAgIH1cbn1cblxuSW50bFNlcnZpY2UucmVnaXN0ZXIoeyB0b1N0cmluZyB9KTtcbi8qKlxuICpcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgd29ya2Jvb2tPcHRpb25zID0gKG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBjb2x1bW5zID0gdG9FeHBvcnRlckNvbHVtbnMob3B0aW9ucy5jb2x1bW5zKTtcbiAgICBjb25zdCBleHBvcnRlciA9IG5ldyBFeGNlbEV4cG9ydGVyKHtcbiAgICAgICAgY29sdW1uczogY29sdW1ucyxcbiAgICAgICAgZGF0YTogb3B0aW9ucy5kYXRhLFxuICAgICAgICBmaWx0ZXJhYmxlOiBvcHRpb25zLmZpbHRlcmFibGUsXG4gICAgICAgIGdyb3Vwczogb3B0aW9ucy5ncm91cCxcbiAgICAgICAgcGFkZGluZ0NlbGxPcHRpb25zOiBvcHRpb25zLnBhZGRpbmdDZWxsT3B0aW9ucyxcbiAgICAgICAgaGVhZGVyUGFkZGluZ0NlbGxPcHRpb25zOiBvcHRpb25zLmhlYWRlclBhZGRpbmdDZWxsT3B0aW9ucyxcbiAgICAgICAgY29sbGFwc2libGU6IG9wdGlvbnMuY29sbGFwc2libGUsXG4gICAgICAgIGhpZXJhcmNoeTogb3B0aW9ucy5oaWVyYXJjaHksXG4gICAgICAgIGFnZ3JlZ2F0ZXM6IG9wdGlvbnMuYWdncmVnYXRlc1xuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IGV4cG9ydGVyLndvcmtib29rKCk7XG4gICAgcmVzdWx0LmNyZWF0b3IgPSBvcHRpb25zLmNyZWF0b3I7XG4gICAgcmVzdWx0LmRhdGUgPSBvcHRpb25zLmRhdGU7XG4gICAgcmVzdWx0LnJ0bCA9IG9wdGlvbnMucnRsO1xuICAgIGRlc3Ryb3lDb2x1bW5zKGNvbHVtbnMpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHRvRGF0YVVSTCA9IChvcHRpb25zKSA9PiB7XG4gICAgY29uc3Qgd29ya2Jvb2sgPSBuZXcgV29ya2Jvb2sob3B0aW9ucyk7XG4gICAgcmV0dXJuIHdvcmtib29rLnRvRGF0YVVSTCgpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc1dvcmtib29rT3B0aW9ucyA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5zaGVldHM7XG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQ29sdW1uQmFzZSB7XG4gICAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGxldmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5sZXZlbCArIDEgOiAwO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENvbHVtbkJhc2UucHJvdG90eXBlLCBcInRpdGxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBDb2x1bW5CYXNlLnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENvbHVtbkJhc2UucHJvdG90eXBlLCBcImxvY2tlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENvbHVtbkJhc2UucHJvdG90eXBlLCBcImhpZGRlblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ29sdW1uQmFzZS5wcm90b3R5cGUsIFwiaGVhZGVyQ2VsbE9wdGlvbnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihDb2x1bW5CYXNlKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuXSwgQ29sdW1uQmFzZS5wcm90b3R5cGUsIFwiY2hpbGRyZW5cIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHBhY2thZ2VNZXRhZGF0YSA9IHtcbiAgICBuYW1lOiAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItZXhjZWwtZXhwb3J0JyxcbiAgICBwcm9kdWN0TmFtZTogJ0tlbmRvIFVJIGZvciBBbmd1bGFyJyxcbiAgICBwcm9kdWN0Q29kZXM6IFsnS0VORE9VSUFOR1VMQVInLCAnS0VORE9VSUNPTVBMRVRFJ10sXG4gICAgcHVibGlzaERhdGU6IDE2MjAyMTM1MjQsXG4gICAgdmVyc2lvbjogJycsXG4gICAgbGljZW5zaW5nRG9jc1VybDogJ2h0dHBzOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvbXktbGljZW5zZS8/dXRtX21lZGl1bT1wcm9kdWN0JnV0bV9zb3VyY2U9a2VuZG9hbmd1bGFyJnV0bV9jYW1wYWlnbj1rZW5kby11aS1hbmd1bGFyLXB1cmNoYXNlLWxpY2Vuc2Uta2V5cy13YXJuaW5nJ1xufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgRXhjZWwgRXhwb3J0IGNvbXBvbmVudCBmb3IgQW5ndWxhcl0oeyUgc2x1ZyBvdmVydmlld19leGNlbGV4cG9ydCAlfSkuXG4gKiBDb25maWd1cmVzIHRoZSBzZXR0aW5ncyBmb3IgdGhlIEV4Y2VsIGV4cG9ydCBvZiB0aGUgS2VuZG8gVUkgR3JpZC5cbiAqL1xubGV0IEV4Y2VsRXhwb3J0Q29tcG9uZW50ID0gY2xhc3MgRXhjZWxFeHBvcnRDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbiwgem9uZSkge1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgbmFtZSBvZiB0aGUgZmlsZSB0aGF0IGlzIGV4cG9ydGVkIHRvIEV4Y2VsLlxuICAgICAgICAgKiBAZGVmYXVsdCBcIkV4cG9ydC54bHN4XCJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsZU5hbWUgPSAnRXhwb3J0Lnhsc3gnO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2x1bW5zID0gbmV3IFF1ZXJ5TGlzdCgpO1xuICAgICAgICB2YWxpZGF0ZVBhY2thZ2UocGFja2FnZU1ldGFkYXRhKTtcbiAgICAgICAgdGhpcy5zYXZlRmlsZSA9IHRoaXMuc2F2ZUZpbGUuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2F2ZXMgdGhlIGRhdGEgdG8gRXhjZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXhwb3J0RGF0YSAtIEFuIG9wdGlvbmFsIHBhcmFtZXRlci4gQ2FuIGJlIHRoZSBkYXRhIHRoYXQgd2lsbCBiZSBleHBvcnRlZCBvciBbYFdvcmtib29rT3B0aW9uc2BdKHslIHNsdWcgYXBpX2V4Y2VsLWV4cG9ydF93b3JrYm9va29wdGlvbnMgJX0pLlxuICAgICAqL1xuICAgIHNhdmUoZXhwb3J0RGF0YSkge1xuICAgICAgICB0aGlzLnRvRGF0YVVSTChleHBvcnREYXRhKS50aGVuKHRoaXMuc2F2ZUZpbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGNvbHVtbnMgYW5kIGRhdGEsIHJldHVybnNcbiAgICAgKiBbYFdvcmtib29rT3B0aW9uc2BdKHslIHNsdWcgYXBpX2V4Y2VsLWV4cG9ydF93b3JrYm9va29wdGlvbnMgJX0pXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBjdXN0b21yb3dzYW5kY2VsbHNfZXhjZWxleHBvcnQgJX0pKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBleHBvcnREYXRhIC0gVGhlIG9wdGlvbmFsIGRhdGEgdG8gYmUgZXhwb3J0ZWQuXG4gICAgICogQHJldHVybnMge1dvcmtib29rT3B0aW9uc30gLSBUaGUgd29ya2Jvb2sgb3B0aW9ucy5cbiAgICAgKi9cbiAgICB3b3JrYm9va09wdGlvbnMoZXhwb3J0RGF0YSkge1xuICAgICAgICBjb25zdCBjdXJyZW50RGF0YSA9IHRoaXMuZ2V0RXhwb3J0RGF0YShleHBvcnREYXRhKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHdvcmtib29rT3B0aW9ucyh7XG4gICAgICAgICAgICBjb2x1bW5zOiB0aGlzLmNvbHVtbnMsXG4gICAgICAgICAgICBkYXRhOiBjdXJyZW50RGF0YS5kYXRhLFxuICAgICAgICAgICAgZ3JvdXA6IGN1cnJlbnREYXRhLmdyb3VwLFxuICAgICAgICAgICAgZmlsdGVyYWJsZTogdGhpcy5maWx0ZXJhYmxlLFxuICAgICAgICAgICAgY3JlYXRvcjogdGhpcy5jcmVhdG9yLFxuICAgICAgICAgICAgZGF0ZTogdGhpcy5kYXRlLFxuICAgICAgICAgICAgcnRsOiB0aGlzLmxvY2FsaXphdGlvbi5ydGwsXG4gICAgICAgICAgICBwYWRkaW5nQ2VsbE9wdGlvbnM6IHRoaXMucGFkZGluZ0NlbGxPcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyUGFkZGluZ0NlbGxPcHRpb25zOiB0aGlzLmhlYWRlclBhZGRpbmdDZWxsT3B0aW9ucyxcbiAgICAgICAgICAgIGNvbGxhcHNpYmxlOiB0aGlzLmNvbGxhcHNpYmxlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb21pc2Ugd2hpY2ggd2lsbCBiZSByZXNvbHZlZCB3aXRoIHRoZSBmaWxlIGRhdGEgVVJJXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBmaWxlc2F2aW5nX2V4Y2VsZXhwb3J0ICV9KSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXhwb3J0RGF0YSAtIFRoZSBvcHRpb25hbCBkYXRhIG9yIFtgV29ya2Jvb2tPcHRpb25zYF0oeyUgc2x1ZyBhcGlfZXhjZWwtZXhwb3J0X3dvcmtib29rb3B0aW9ucyAlfSkgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGRhdGEgVVJJLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IC0gVGhlIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIGJ5IHRoZSBmaWxlIGRhdGEgVVJJLlxuICAgICAqL1xuICAgIHRvRGF0YVVSTChleHBvcnREYXRhKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBpc1dvcmtib29rT3B0aW9ucyhleHBvcnREYXRhKSA/XG4gICAgICAgICAgICBleHBvcnREYXRhIDpcbiAgICAgICAgICAgIHRoaXMud29ya2Jvb2tPcHRpb25zKGV4cG9ydERhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHRvRGF0YVVSTChvcHRpb25zKSk7XG4gICAgfVxuICAgIGdldEV4cG9ydERhdGEoZXhwb3J0RGF0YSkge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAoZXhwb3J0RGF0YSkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXhwb3J0RGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGV4cG9ydERhdGFcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXhwb3J0RGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICAgICAgICAgICAgZ3JvdXA6IHRoaXMuZ3JvdXBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc2F2ZUZpbGUoZGF0YVVSTCkge1xuICAgICAgICBzYXZlQXMoZGF0YVVSTCwgdGhpcy5maWxlTmFtZSwge1xuICAgICAgICAgICAgZm9yY2VQcm94eTogdGhpcy5mb3JjZVByb3h5LFxuICAgICAgICAgICAgcHJveHlVUkw6IHRoaXMucHJveHlVUkxcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEV4Y2VsRXhwb3J0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWxlTmFtZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEV4Y2VsRXhwb3J0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJhYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRXhjZWxFeHBvcnRDb21wb25lbnQucHJvdG90eXBlLCBcImNvbGxhcHNpYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBFeGNlbEV4cG9ydENvbXBvbmVudC5wcm90b3R5cGUsIFwiY3JlYXRvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSlcbl0sIEV4Y2VsRXhwb3J0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgRXhjZWxFeHBvcnRDb21wb25lbnQucHJvdG90eXBlLCBcImZvcmNlUHJveHlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEV4Y2VsRXhwb3J0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJwcm94eVVSTFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBFeGNlbEV4cG9ydENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBFeGNlbEV4cG9ydENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JvdXBcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEV4Y2VsRXhwb3J0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJwYWRkaW5nQ2VsbE9wdGlvbnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEV4Y2VsRXhwb3J0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJoZWFkZXJQYWRkaW5nQ2VsbE9wdGlvbnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihDb2x1bW5CYXNlLCB7IGRlc2NlbmRhbnRzOiB0cnVlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG5dLCBFeGNlbEV4cG9ydENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sdW1uc1wiLCB2b2lkIDApO1xuRXhjZWxFeHBvcnRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBleHBvcnRBczogJ2tlbmRvRXhjZWxFeHBvcnQnLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWV4Y2VsZXhwb3J0JyxcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEwxME5fUFJFRklYLFxuICAgICAgICAgICAgICAgIHVzZVZhbHVlOiAna2VuZG8uZXhjZWxleHBvcnQnXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHRlbXBsYXRlOiBgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTG9jYWxpemF0aW9uU2VydmljZSwgTmdab25lXSlcbl0sIEV4Y2VsRXhwb3J0Q29tcG9uZW50KTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBncm91cCBoZWFkZXIgY2VsbCB0ZW1wbGF0ZSBvZiB0aGUgRXhjZWwgRXhwb3J0IGNvbHVtbiBjb21wb25lbnRcbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgY29sdW1uc19leGNlbC1leHBvcnQgJX0jdG9jLWdyb3VwLWhlYWRlci10ZW1wbGF0ZSkpLlxuICogRW5hYmxlcyB5b3UgdG8gY3VzdG9taXplIHRoZSBjb250ZW50IG9mIHRoZSBncm91cCBoZWFkZXIgaXRlbS5cbiAqL1xubGV0IEdyb3VwSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUgPSBjbGFzcyBHcm91cEhlYWRlclRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufTtcbkdyb3VwSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0V4Y2VsRXhwb3J0R3JvdXBIZWFkZXJUZW1wbGF0ZV0nXG4gICAgfSksXG4gICAgX19wYXJhbSgwLCBPcHRpb25hbCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1RlbXBsYXRlUmVmXSlcbl0sIEdyb3VwSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGdyb3VwIGhlYWRlciBjb2x1bW4gdGVtcGxhdGUgb2YgdGhlIEV4Y2VsIEV4cG9ydCBjb2x1bW4gY29tcG9uZW50XG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGNvbHVtbnNfZXhjZWwtZXhwb3J0ICV9I3RvYy1ncm91cC1oZWFkZXItY29sdW1uLXRlbXBsYXRlKSkuXG4gKi9cbmxldCBHcm91cEhlYWRlckNvbHVtblRlbXBsYXRlRGlyZWN0aXZlID0gY2xhc3MgR3JvdXBIZWFkZXJDb2x1bW5UZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn07XG5Hcm91cEhlYWRlckNvbHVtblRlbXBsYXRlRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9FeGNlbEV4cG9ydEdyb3VwSGVhZGVyQ29sdW1uVGVtcGxhdGVdJ1xuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgT3B0aW9uYWwoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZl0pXG5dLCBHcm91cEhlYWRlckNvbHVtblRlbXBsYXRlRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBncm91cCBmb290ZXIgY2VsbCB0ZW1wbGF0ZSBvZiB0aGUgRXhjZWwgRXhwb3J0IGNvbHVtbiBjb21wb25lbnRcbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgY29sdW1uc19leGNlbC1leHBvcnQgJX0jdG9jLWdyb3VwLWZvb3Rlci10ZW1wbGF0ZSkpLlxuICogRW5hYmxlcyB5b3UgdG8gY3VzdG9taXplIHRoZSBncm91cCBmb290ZXIgY2VsbCBvZiB0aGUgY29sdW1uLlxuICovXG5sZXQgR3JvdXBGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSA9IGNsYXNzIEdyb3VwRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59O1xuR3JvdXBGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvRXhjZWxFeHBvcnRHcm91cEZvb3RlclRlbXBsYXRlXSdcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIE9wdGlvbmFsKCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVGVtcGxhdGVSZWZdKVxuXSwgR3JvdXBGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgZm9vdGVyIGNlbGwgdGVtcGxhdGUgb2YgdGhlIEV4Y2VsIEV4cG9ydCBjb2x1bW4gY29tcG9uZW50XG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGNvbHVtbnNfZXhjZWwtZXhwb3J0ICV9I3RvYy1mb290ZXItdGVtcGxhdGUpKS5cbiAqIEVuYWJsZXMgeW91IHRvIGN1c3RvbWl6ZSB0aGUgZm9vdGVyIGNlbGwgb2YgdGhlIGNvbHVtbi5cbiAqL1xubGV0IEZvb3RlclRlbXBsYXRlRGlyZWN0aXZlID0gY2xhc3MgRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59O1xuRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0V4Y2VsRXhwb3J0Rm9vdGVyVGVtcGxhdGVdJ1xuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgT3B0aW9uYWwoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZl0pXG5dLCBGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSk7XG5cbnZhciBDb2x1bW5Db21wb25lbnRfMTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgY29sdW1ucyBvZiB0aGUgS2VuZG8gVUkgRXhjZWwgRXhwb3J0IGNvbXBvbmVudCBmb3IgQW5ndWxhci5cbiAqL1xubGV0IENvbHVtbkNvbXBvbmVudCA9IENvbHVtbkNvbXBvbmVudF8xID0gY2xhc3MgQ29sdW1uQ29tcG9uZW50IGV4dGVuZHMgQ29sdW1uQmFzZSB7XG4gICAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENvbHVtbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiZmllbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENvbHVtbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiY2VsbE9wdGlvbnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENvbHVtbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JvdXBIZWFkZXJDZWxsT3B0aW9uc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ29sdW1uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncm91cEZvb3RlckNlbGxPcHRpb25zXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDb2x1bW5Db21wb25lbnQucHJvdG90eXBlLCBcImZvb3RlckNlbGxPcHRpb25zXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoR3JvdXBIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBHcm91cEhlYWRlclRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgQ29sdW1uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncm91cEhlYWRlclRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoR3JvdXBIZWFkZXJDb2x1bW5UZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBHcm91cEhlYWRlckNvbHVtblRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgQ29sdW1uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncm91cEhlYWRlckNvbHVtblRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoR3JvdXBGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBHcm91cEZvb3RlclRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgQ29sdW1uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncm91cEZvb3RlclRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBDb2x1bW5Db21wb25lbnQucHJvdG90eXBlLCBcImZvb3RlclRlbXBsYXRlXCIsIHZvaWQgMCk7XG5Db2x1bW5Db21wb25lbnQgPSBDb2x1bW5Db21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IENvbHVtbkJhc2UsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ29sdW1uQ29tcG9uZW50XzEpIC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tZm9yd2FyZC1yZWZcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1leGNlbGV4cG9ydC1jb2x1bW4nLFxuICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIFNraXBTZWxmKCkpLCBfX3BhcmFtKDAsIEhvc3QoKSksIF9fcGFyYW0oMCwgT3B0aW9uYWwoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb2x1bW5CYXNlXSlcbl0sIENvbHVtbkNvbXBvbmVudCk7XG5cbnZhciBDb2x1bW5Hcm91cENvbXBvbmVudF8xO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBjb2x1bW4gZ3JvdXAgY29tcG9uZW50IG9mIHRoZSBLZW5kbyBVSSBFeGNlbCBFeHBvcnQgY29tcG9uZW50LlxuICovXG5sZXQgQ29sdW1uR3JvdXBDb21wb25lbnQgPSBDb2x1bW5Hcm91cENvbXBvbmVudF8xID0gY2xhc3MgQ29sdW1uR3JvdXBDb21wb25lbnQgZXh0ZW5kcyBDb2x1bW5CYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICAgICAgc3VwZXIocGFyZW50KTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxufTtcbkNvbHVtbkdyb3VwQ29tcG9uZW50ID0gQ29sdW1uR3JvdXBDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IENvbHVtbkJhc2UsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ29sdW1uR3JvdXBDb21wb25lbnRfMSkgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWV4Y2VsZXhwb3J0LWNvbHVtbi1ncm91cCcsXG4gICAgICAgIHRlbXBsYXRlOiBgYFxuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgU2tpcFNlbGYoKSksIF9fcGFyYW0oMCwgSG9zdCgpKSwgX19wYXJhbSgwLCBPcHRpb25hbCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbHVtbkJhc2VdKVxuXSwgQ29sdW1uR3JvdXBDb21wb25lbnQpO1xuXG5jb25zdCBkZWNsYXJhdGlvbnMgPSBbXG4gICAgRXhjZWxFeHBvcnRDb21wb25lbnQsXG4gICAgQ29sdW1uQ29tcG9uZW50LFxuICAgIENvbHVtbkdyb3VwQ29tcG9uZW50LFxuICAgIEZvb3RlclRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIEdyb3VwRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgR3JvdXBIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBHcm91cEhlYWRlckNvbHVtblRlbXBsYXRlRGlyZWN0aXZlXG5dO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgRXhjZWwgRXhwb3J0IGNvbXBvbmVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzLW5vLXJ1blxuICogLy8gSW1wb3J0IHRoZSBFeGNlbEV4cG9ydE1vZHVsZSBtb2R1bGVcbiAqIGltcG9ydCB7IEV4Y2VsRXhwb3J0TW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItZXhjZWwtZXhwb3J0JztcbiAqXG4gKiAvLyBUaGUgYnJvd3NlciBwbGF0Zm9ybSB3aXRoIGEgY29tcGlsZXJcbiAqIGltcG9ydCB7IHBsYXRmb3JtQnJvd3NlckR5bmFtaWMgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMnO1xuICpcbiAqIGltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogLy8gSW1wb3J0IHRoZSBhcHAgY29tcG9uZW50XG4gKiBpbXBvcnQgeyBBcHBDb21wb25lbnQgfSBmcm9tICcuL2FwcC5jb21wb25lbnQnO1xuICpcbiAqIC8vIERlZmluZSB0aGUgYXBwIG1vZHVsZVxuICogX0BOZ01vZHVsZSh7XG4gKiAgICAgZGVjbGFyYXRpb25zOiBbQXBwQ29tcG9uZW50XSwgLy8gZGVjbGFyZSBhcHAgY29tcG9uZW50XG4gKiAgICAgaW1wb3J0czogICAgICBbQnJvd3Nlck1vZHVsZSwgRXhjZWxFeHBvcnRNb2R1bGVdLCAvLyBpbXBvcnQgRXhjZWxFeHBvcnRNb2R1bGUgbW9kdWxlXG4gKiAgICAgYm9vdHN0cmFwOiAgICBbQXBwQ29tcG9uZW50XVxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUge31cbiAqXG4gKiAvLyBDb21waWxlIGFuZCBsYXVuY2ggdGhlIG1vZHVsZVxuICogcGxhdGZvcm1Ccm93c2VyRHluYW1pYygpLmJvb3RzdHJhcE1vZHVsZShBcHBNb2R1bGUpO1xuICpcbiAqIGBgYFxuICovXG5sZXQgRXhjZWxFeHBvcnRNb2R1bGUgPSBjbGFzcyBFeGNlbEV4cG9ydE1vZHVsZSB7XG59O1xuRXhjZWxFeHBvcnRNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogW2RlY2xhcmF0aW9uc10sXG4gICAgICAgIGV4cG9ydHM6IFtkZWNsYXJhdGlvbnNdXG4gICAgfSlcbl0sIEV4Y2VsRXhwb3J0TW9kdWxlKTtcblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cbiAqL1xuXG5leHBvcnQgeyBHcm91cEhlYWRlckNvbHVtblRlbXBsYXRlRGlyZWN0aXZlLCBFeGNlbEV4cG9ydENvbXBvbmVudCwgRXhjZWxFeHBvcnRNb2R1bGUsIENvbHVtbkJhc2UsIENvbHVtbkNvbXBvbmVudCwgQ29sdW1uR3JvdXBDb21wb25lbnQsIEZvb3RlclRlbXBsYXRlRGlyZWN0aXZlLCBHcm91cEZvb3RlclRlbXBsYXRlRGlyZWN0aXZlLCBHcm91cEhlYWRlclRlbXBsYXRlRGlyZWN0aXZlLCB3b3JrYm9va09wdGlvbnMsIHRvRGF0YVVSTCwgaXNXb3JrYm9va09wdGlvbnMgfTtcbiJdfQ==