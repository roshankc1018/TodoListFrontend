/**-----------------------------------------------------------------------------------------
* Copyright Â© 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { __decorate, __metadata, __assign, __param, __extends } from 'tslib';
import { Input, Output, EventEmitter, ViewChild, ElementRef, HostBinding, Component, Renderer2, Directive, TemplateRef, Injectable, ViewChildren, QueryList, ChangeDetectorRef, NgZone, InjectionToken, forwardRef, isDevMode, ContentChild, ViewContainerRef, Optional, Inject, KeyValueDiffers, ContentChildren, ChangeDetectionStrategy, NgModule, HostListener } from '@angular/core';
import { isDocumentAvailable, Keys, isChanged, hasObservers, KendoInput, anyChanged, guid, ResizeSensorModule, EventsModule } from '@progress/kendo-angular-common';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import { validatePackage } from '@progress/kendo-licensing';
import { getter, pointers, touchEnabled } from '@progress/kendo-common';
import { LocalizationService, L10N_PREFIX, ComponentMessages } from '@progress/kendo-angular-l10n';
import { fromEvent, merge, Subject, of, Subscription, interval } from 'rxjs';
import { PopupService, PopupModule } from '@progress/kendo-angular-popup';
export { PopupComponent } from '@progress/kendo-angular-popup';
import { auditTime, tap, map, switchMap, take, filter, partition, throttleTime, catchError, skipWhile, concatMap, takeUntil } from 'rxjs/operators';
import { TreeViewComponent, DataBoundComponent, ExpandableComponent, FlatDataBindingDirective, HierarchyBindingDirective, ExpandDirective, TreeViewModule } from '@progress/kendo-angular-treeview';
import { CommonModule } from '@angular/common';

/**
 * @hidden
 */
var packageMetadata = {
    name: '@progress/kendo-angular-dropdowns',
    productName: 'Kendo UI for Angular',
    productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],
    publishDate: 1631260317,
    version: '',
    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'
};

/* tslint:disable:no-bitwise */
/**
 * @hidden
 */
var isPresent = function (value) { return value !== null && value !== undefined; };
/**
 * @hidden
 */
var isNumber = function (value) { return !isNaN(value); };
/**
 * @hidden
 */
var guid$1 = function () {
    var id = "";
    var i;
    var random;
    for (i = 0; i < 32; i++) {
        random = Math.random() * 16 | 0;
        if (i === 8 || i === 12 || i === 16 || i === 20) {
            id += "-";
        }
        id += (i === 12 ? 4 : (i === 16 ? (random & 3 | 8) : random)).toString(16);
    }
    return id;
};
/**
 * @hidden
 */
var combineStr = function (begin, end) {
    return begin.concat(end.substr(end.toLowerCase().indexOf(begin.toLowerCase()) + begin.length));
};
/**
 * @hidden
 */
var isArray = function (value) { return Array.isArray(value); };
/**
 * @hidden
 */
var isObject = function (value) { return isPresent(value) && typeof value === 'object'; };
/**
 * @hidden
 */
var isEmptyString = function (value) { return typeof value === 'string' && value.length === 0; };
/**
 * @hidden
 */
var resolveValuesInArray = function (values, data, valueField) {
    if (data === void 0) { data = []; }
    return values
        .map(function (value) {
        return data.find(function (item) { return getter$1(item, valueField) === value; });
    })
        .filter(function (value) { return value !== undefined; });
};
/**
 * @hidden
 */
var validateComplexValues = function (values, valueField) {
    return isArray(values) && values.filter(function (item) {
        return isObject(item) && isPresent(getter$1(item, valueField));
    });
};
/**
 * @hidden
 */
var resolveAllValues = function (value, data, valueField) {
    var customValues = validateComplexValues(value, valueField) || [];
    var resolvedValues = resolveValuesInArray(value, data, valueField) || [];
    return resolvedValues.concat(customValues);
};
/**
 * @hidden
 */
var isObjectArray = function (values) {
    return isArray(values) && values.every(function (item) { return isObject(item); });
};
/**
 * @hidden
 */
var selectedIndices = function (values, data, valueField) {
    var extractedValues = data.map(function (item) {
        return isPresent(item) && isPresent(getter$1(item, valueField)) ? getter$1(item, valueField) : item;
    });
    return values.reduce(function (arr, item) {
        var value = isPresent(item) && isPresent(getter$1(item, valueField)) ? getter$1(item, valueField) : item;
        var index = extractedValues.indexOf(value);
        if (index !== -1) {
            arr.push(index);
        }
        return arr;
    }, []);
};
/**
 * @hidden
 */
var getter$1 = function (dataItem, field) {
    if (!isPresent(dataItem)) {
        return null;
    }
    if (!isPresent(field) || !isObject(dataItem)) {
        return dataItem;
    }
    // creates a field accessor supporting nested fields processing
    var valueFrom = getter(field);
    return valueFrom(dataItem);
};
/**
 * @hidden
 */
var sameCharsOnly = function (word, character) {
    for (var idx = 0; idx < word.length; idx++) {
        if (word.charAt(idx) !== character) {
            return false;
        }
    }
    return true;
};
/**
 * @hidden
 */
var shuffleData = function (data, splitIndex, defaultItem) {
    var result = data;
    if (defaultItem) {
        result = [defaultItem].concat(result);
    }
    return result.slice(splitIndex).concat(result.slice(0, splitIndex));
};
/**
 * @hidden
 */
var matchText = function (text, word, ignoreCase) {
    if (!isPresent(text)) {
        return false;
    }
    var temp = String(text);
    if (ignoreCase) {
        temp = temp.toLowerCase();
    }
    return temp.indexOf(word) === 0;
};
/**
 * @hidden
 *
 * Checks whether the passed object has all of the listed properties.
 */
var hasProps = function (obj, props) {
    if (!isPresent(obj)) {
        return false;
    }
    return props.every(function (prop) { return obj.hasOwnProperty(prop); });
};
/**
 * @hidden
 *
 * Checks whether an element is untouched by looking for the ng-untouched css class
 */
var isUntouched = function (element) { return element.className.includes('ng-untouched'); };
/**
 * @hidden
 */
var noop = function (_) { };
/**
 * IE element `matches` polyfill.
 * https://developer.mozilla.org/en-US/docs/Web/API/Element/matches
 */
var matches = function (element, selector) {
    var matcher = element.matches || element.msMatchesSelector || element.webkitMatchesSelector;
    if (!matcher) {
        return false;
    }
    return matcher.call(element, selector);
};
/**
 * @hidden
 *
 * IE element `closest` polyfill.
 * https://developer.mozilla.org/en-US/docs/Web/API/Element/closest
 */
var closest = function (element, selector) {
    var parent = element;
    while (parent !== null && parent.nodeType === 1) {
        if (matches(parent, selector)) {
            return parent;
        }
        parent = parent.parentElement || parent.parentNode;
    }
    return null;
};
/**
 * @hidden
 *
 * Parses a provided value to its type 'number' representation.
 * If the parsed value (via Number(value)) is NaN, the provided default value is returned.
 * Uses 0 as default value if a second param is not provided.
 */
var parseNumber = function (num, defaultValue) {
    if (defaultValue === void 0) { defaultValue = 0; }
    var normalizedValue = Number(num);
    return isNaN(normalizedValue) ? defaultValue : normalizedValue;
};
/**
 * @hidden
 *
 * Checks whether the passed target element is inside the provided host or popupRef.
 */
var inDropDown = function (host, target, popupRef) {
    return host.nativeElement.contains(target) || (popupRef && popupRef.popupElement.contains(target));
};
/**
 * @hidden
 *
 * Calculates the hierarchical level of an item, based on the provided index.
 * The result level is zero-based (starts from 0).
 */
var getHierarchicalItemLevel = function (index) {
    return (index || '').split('_').length - 1;
};
/**
 * @hidden
 *
 * Retrieves all descendant nodes' lookups which are currently registered in the provided lookup item as a flat array.
 */
var fetchDescendentNodes = function (lookup, filterExpression) {
    if (!isPresent(lookup) || lookup.children.length === 0) {
        return [];
    }
    var descendants = lookup.children;
    if (isPresent(filterExpression)) {
        descendants = descendants.filter(function (descendent) { return filterExpression(descendent.item); });
    }
    descendants.forEach(function (child) {
        return descendants = descendants.concat(fetchDescendentNodes(child, filterExpression));
    });
    return descendants;
};
/**
 * @hidden
 *
 * Retrieves the correct value based on the item's level and the provided value field/s.
 * Used in the MultiSelectTree component.
 */
var valueFrom = function (_a, valueField) {
    var dataItem = _a.dataItem, index = _a.index, level = _a.level;
    var fields = Array.isArray(valueField) ? valueField : [valueField];
    // either use the explicitly provided value level, or infer it from the item index
    var valueLevel = isPresent(level) ? level : getHierarchicalItemLevel(index);
    // fall-back to the last available one, if the current node is in a deeper level
    var normalizedLevel = Math.min(valueLevel, fields.length - 1);
    var field = fields[normalizedLevel];
    return getter(field)(dataItem);
};

/* tslint:disable:member-ordering */
/**
 * @hidden
 */
var SearchBarComponent = /** @class */ (function () {
    function SearchBarComponent(localization, renderer) {
        this.localization = localization;
        this.valueChange = new EventEmitter();
        this.onBlur = new EventEmitter();
        this.onFocus = new EventEmitter();
        this.onClick = new EventEmitter();
        this.onNavigate = new EventEmitter();
        this.searchBarClass = true;
        this._userInput = "";
        this._previousValue = "";
        this._placeholder = "";
        this.direction = localization.rtl ? 'rtl' : 'ltr';
        this.renderer = renderer;
    }
    Object.defineProperty(SearchBarComponent.prototype, "userInput", {
        get: function () {
            return this._userInput;
        },
        set: function (userInput) {
            this._userInput = userInput || "";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchBarComponent.prototype, "value", {
        get: function () {
            return this.input.nativeElement.value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchBarComponent.prototype, "placeholder", {
        get: function () {
            return this._placeholder;
        },
        set: function (text) {
            this._placeholder = text || '';
            this.setInputSize();
        },
        enumerable: true,
        configurable: true
    });
    SearchBarComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.localizationChangeSubscription = this.localization
            .changes.subscribe(function (_a) {
            var rtl = _a.rtl;
            return _this.direction = rtl ? 'rtl' : 'ltr';
        });
    };
    SearchBarComponent.prototype.ngOnChanges = function (changes) {
        var previousUserInput;
        if (this.input && (changes.userInput || changes.suggestedText)) {
            if (changes.userInput && changes.userInput.previousValue) {
                if (this._previousValue === changes.userInput.previousValue) {
                    previousUserInput = this._previousValue;
                }
                else {
                    previousUserInput = changes.userInput.currentValue || "";
                }
            }
            else {
                previousUserInput = this._previousValue;
            }
            var caretIndex = this.input.nativeElement.selectionStart;
            var caretAtEnd = previousUserInput.length === caretIndex;
            this.writeInputValue(this.suggestedText ? combineStr(this.userInput, this.suggestedText) : this.userInput);
            if (this.suggestedText) {
                this.setInputSelection(this.userInput.length, this.suggestedText.length);
            }
            else if (caretAtEnd) {
                this.setInputSelection(this.userInput.length, this.userInput.length);
            }
            else {
                this.setInputSelection(caretIndex, caretIndex);
            }
            this._previousValue = this.userInput;
        }
    };
    SearchBarComponent.prototype.ngOnDestroy = function () {
        if (this.localizationChangeSubscription) {
            this.localizationChangeSubscription.unsubscribe();
        }
    };
    SearchBarComponent.prototype.writeInputValue = function (text) {
        if (isDocumentAvailable()) {
            this.renderer.setProperty(this.input.nativeElement, 'value', text);
        }
    };
    SearchBarComponent.prototype.setInputSelection = function (start, end) {
        if (isDocumentAvailable() && this.input.nativeElement === document.activeElement) {
            try {
                this.input.nativeElement.setSelectionRange(start, end);
            }
            catch (e) {
                //Make sure that the element is in the DOM before you invoke its methods
            }
        }
    };
    SearchBarComponent.prototype.handleInput = function (event) {
        var value = event.target.value;
        if (value !== this.userInput) {
            this._previousValue = value;
            this.valueChange.emit(value);
        }
    };
    SearchBarComponent.prototype.handleFocus = function (event) {
        this.onFocus.emit(event);
    };
    SearchBarComponent.prototype.handleBlur = function (event) {
        this.onBlur.emit(event);
    };
    SearchBarComponent.prototype.handleKeydown = function (event) {
        var keyCode = event.keyCode;
        var keys = [Keys.ArrowUp, Keys.ArrowDown, Keys.ArrowLeft, Keys.ArrowRight, Keys.Enter,
            Keys.Escape, Keys.Delete, Keys.Backspace, Keys.Home, Keys.End];
        if (keys.indexOf(keyCode) > -1) {
            this.onNavigate.emit(event);
        }
    };
    SearchBarComponent.prototype.focus = function () {
        if (isDocumentAvailable()) {
            this.input.nativeElement.focus();
        }
    };
    SearchBarComponent.prototype.blur = function () {
        if (isDocumentAvailable()) {
            this.input.nativeElement.blur();
        }
    };
    SearchBarComponent.prototype.setInputSize = function () {
        var lengthOf = function (x) { return x ? x.length : 0; };
        var input = this.input.nativeElement;
        var placeholderLength = lengthOf(this.placeholder);
        var textLength = lengthOf(this.value);
        var size = Math.max(placeholderLength, textLength, 1);
        this.renderer.setAttribute(input, 'size', size.toString());
    };
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SearchBarComponent.prototype, "id", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SearchBarComponent.prototype, "listId", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SearchBarComponent.prototype, "tagListId", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SearchBarComponent.prototype, "activeDescendant", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SearchBarComponent.prototype, "noDataLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SearchBarComponent.prototype, "disabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SearchBarComponent.prototype, "readonly", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], SearchBarComponent.prototype, "tabIndex", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SearchBarComponent.prototype, "popupOpen", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SearchBarComponent.prototype, "role", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], SearchBarComponent.prototype, "userInput", null);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SearchBarComponent.prototype, "suggestedText", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], SearchBarComponent.prototype, "valueChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], SearchBarComponent.prototype, "onBlur", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], SearchBarComponent.prototype, "onFocus", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], SearchBarComponent.prototype, "onClick", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], SearchBarComponent.prototype, "onNavigate", void 0);
    __decorate([
        ViewChild('input', { static: true }),
        __metadata("design:type", ElementRef)
    ], SearchBarComponent.prototype, "input", void 0);
    __decorate([
        HostBinding('class.k-searchbar'),
        __metadata("design:type", Boolean)
    ], SearchBarComponent.prototype, "searchBarClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], SearchBarComponent.prototype, "placeholder", null);
    SearchBarComponent = __decorate([
        Component({
            selector: 'kendo-searchbar',
            template: "\n        <input #input\n            autocomplete=\"off\"\n            [id]=\"id\"\n            [disabled]=\"disabled\"\n            [readonly]=\"readonly\"\n            [placeholder]=\"placeholder\"\n            [class]=\"'k-input'\"\n            (input)=\"handleInput($event)\"\n            (keydown)=\"handleKeydown($event)\"\n            [kendoEventsOutsideAngular]=\"{\n                focus: handleFocus,\n                blur: handleBlur\n            }\"\n            [scope]=\"this\"\n            [attr.tabIndex]=\"tabIndex\"\n            [attr.dir]=\"direction\"\n            [attr.role]=\"role\"\n            [attr.aria-disabled]=\"disabled\"\n            [attr.aria-readonly]=\"readonly\"\n            aria-haspopup=\"listbox\"\n            [attr.aria-expanded]=\"popupOpen\"\n            [attr.aria-owns]=\"listId\"\n            [attr.aria-describedby]=\"tagListId\"\n            [attr.aria-activedescendant]=\"activeDescendant\"\n            [attr.aria-label]=\"noDataLabel\"\n        />\n   "
        }),
        __metadata("design:paramtypes", [LocalizationService,
            Renderer2])
    ], SearchBarComponent);
    return SearchBarComponent;
}());

/**
 * Renders the list item content. To define the item template, nest an `<ng-template>` tag
 * with the `kendo<ComponentName>ItemTemplate` directive inside the component tag. The template context is
 * set to the current component. To get a reference to the current data item, use the `let-dataItem` directive.
 *
 * - [Using `ItemTemplate` with the AutoComplete]({% slug templates_autocomplete %}#toc-item-template)
 * - [Using `ItemTemplate` with the ComboBox]({% slug templates_combobox %}#toc-item-template)
 * - [Using `ItemTemplate` with the DropDownList]({% slug templates_ddl %}#toc-item-template)
 * - [Using `ItemTemplate` with the MultiSelect]({% slug templates_multiselect %}#toc-item-template)
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-combobox [data]="listItems">
 *    <ng-template kendoComboBoxItemTemplate let-dataItem>
 *      <span>{{dataItem}} option</span>
 *    </ng-template>
 *  </kendo-combobox>
 * `
 * })
 * class AppComponent {
 *   public listItems: Array<string> = ["Item 1", "Item 2", "Item 3", "Item 4"];
 * }
 * ```
 */
var ItemTemplateDirective = /** @class */ (function () {
    function ItemTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    ItemTemplateDirective = __decorate([
        Directive({
            selector: '[kendoDropDownListItemTemplate],[kendoComboBoxItemTemplate],[kendoAutoCompleteItemTemplate],[kendoMultiSelectItemTemplate]'
        }),
        __metadata("design:paramtypes", [TemplateRef])
    ], ItemTemplateDirective);
    return ItemTemplateDirective;
}());

/**
 * Renders the header content of the list. To define the header template, nest an `<ng-template>` tag
 * with the `kendo<ComponentName>HeaderTemplate` directive inside the component tag.
 *
 * - [Using `HeaderTemplate` with the AutoComplete]({% slug templates_autocomplete %}#toc-header-template)
 * - [Using `HeaderTemplate` with the ComboBox]({% slug templates_combobox %}#toc-header-template)
 * - [Using `HeaderTemplate` with the MultiColumnComboBox]({% slug templates_multicolumncombobox %}#toc-header-template)
 * - [Using `HeaderTemplate` with the DropDownList]({% slug templates_ddl %}#toc-header-template)
 * - [Using `HeaderTemplate` with the DropDownTree]({% slug templates_ddt %}#toc-header-template)
 * - [Using `HeaderTemplate` with the MultiSelect]({% slug templates_multiselect %}#toc-header-template)
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-combobox [data]="listItems">
 *    <ng-template kendoComboBoxHeaderTemplate>
 *      <h4>Header template</h4>
 *    </ng-template>
 *  </kendo-combobox>
 * `
 * })
 * class AppComponent {
 *   public listItems: Array<string> = ["Item 1", "Item 2", "Item 3", "Item 4"];
 * }
 * ```
 */
var HeaderTemplateDirective = /** @class */ (function () {
    function HeaderTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    HeaderTemplateDirective = __decorate([
        Directive({
            selector: '[kendoDropDownListHeaderTemplate],[kendoComboBoxHeaderTemplate],[kendoDropDownTreeHeaderTemplate],[kendoMultiColumnComboBoxHeaderTemplate],[kendoAutoCompleteHeaderTemplate],[kendoMultiSelectHeaderTemplate],[kendoMultiSelectTreeHeaderTemplate]'
        }),
        __metadata("design:paramtypes", [TemplateRef])
    ], HeaderTemplateDirective);
    return HeaderTemplateDirective;
}());

/**
 * Renders the footer content of the list. To define the footer template, nest an `<ng-template>` tag
 * with the `kendo<ComponentName>FooterTemplate` directive inside the component tag.
 *
 * - [Using `FooterTemplate` with the AutoComplete]({% slug templates_autocomplete %}#toc-footer-template)
 * - [Using `FooterTemplate` with the ComboBox]({% slug templates_combobox %}#toc-footer-template)
 * - [Using `FooterTemplate` with the MultiColumnComboBox]({% slug templates_multicolumncombobox %}#toc-footer-template)
 * - [Using `FooterTemplate` with the DropDownList]({% slug templates_ddl %}#toc-footer-template)
 * - [Using `FooterTemplate` with the DropDownTree]({% slug templates_ddt %}#toc-footer-template)
 * - [Using `FooterTemplate` with the MultiSelect]({% slug templates_multiselect %}#toc-footer-template)
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-combobox [data]="listItems">
 *    <ng-template kendoComboBoxFooterTemplate>
 *      <h4>Footer template</h4>
 *    </ng-template>
 *  </kendo-combobox>
 * `
 * })
 * class AppComponent {
 *   public listItems: Array<string> = ["Item 1", "Item 2", "Item 3", "Item 4"];
 * }
 * ```
 */
var FooterTemplateDirective = /** @class */ (function () {
    function FooterTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    FooterTemplateDirective = __decorate([
        Directive({
            selector: '[kendoDropDownListFooterTemplate],[kendoComboBoxFooterTemplate],[kendoDropDownTreeFooterTemplate],[kendoMultiColumnComboBoxFooterTemplate],[kendoAutoCompleteFooterTemplate],[kendoMultiSelectFooterTemplate],[kendoMultiSelectTreeFooterTemplate]'
        }),
        __metadata("design:paramtypes", [TemplateRef])
    ], FooterTemplateDirective);
    return FooterTemplateDirective;
}());

/**
 * Renders the group header content. To define the group template, nest an `<ng-template>` tag
 * with the `kendo<ComponentName>GroupTemplate` directive inside the component tag. The template context is
 * set to the current component. To get a reference to the current data item, use the `let-groupName` directive.
 *
 * - [Using `GroupTemplate` with the AutoComplete]({% slug templates_autocomplete %}#toc-group-template)
 * - [Using `GroupTemplate` with the ComboBox]({% slug templates_combobox %}#toc-group-template)
 * - [Using `GroupTemplate` with the MultiColumnComboBox]({% slug templates_multicolumncombobox %}#toc-group-template)
 * - [Using `GroupTemplate` with the DropDownList]({% slug templates_ddl %}#toc-group-template)
 * - [Using `GroupTemplate` with the MultiSelect]({% slug templates_multiselect %}#toc-group-template)
 *
 * @example
 * ```ts
 * import { groupBy } from '@progress/kendo-data-query';
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-combobox [data]="groupedData" textField="name" valueField="name">
 *    <ng-template kendoComboBoxGroupTemplate let-groupName>
 *      <span>Food type: {{groupName}} option</span>
 *    </ng-template>
 *  </kendo-combobox>
 * `
 * })
 * class AppComponent {
 *   public data = [
 *       { name: "Pork", category: "Food", subcategory: "Meat" },
 *       { name: "Pepper", category: "Food", subcategory: "Vegetables" },
 *       { name: "Beef", category: "Food", subcategory: "Meat" }
 *   ];
 *   public groupedData = groupBy(this.data, [{field: "subcategory"}]);
 * }
 * ```
 */
var GroupTemplateDirective = /** @class */ (function () {
    function GroupTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    GroupTemplateDirective = __decorate([
        Directive({
            selector: '[kendoDropDownListGroupTemplate],[kendoComboBoxGroupTemplate],[kendoMultiColumnComboBoxGroupTemplate],[kendoAutoCompleteGroupTemplate],[kendoMultiSelectGroupTemplate]'
        }),
        __metadata("design:paramtypes", [TemplateRef])
    ], GroupTemplateDirective);
    return GroupTemplateDirective;
}());

/**
 * Renders the fixed group header content. To define the fixed group template, nest an `<ng-template>` tag
 * with the `kendo<ComponentName>FixedGroupTemplate` directive inside the component tag. The template context is
 * set to the current component. To get a reference to the current data item, use the `let-groupName` directive.
 *
 * - [Using `FixedGroupTemplate` with the AutoComplete]({% slug templates_autocomplete %}#toc-fixed-group-template)
 * - [Using `FixedGroupTemplate` with the ComboBox]({% slug templates_combobox %}#toc-fixed-group-template)
 * - [Using `FixedGroupTemplate` with the MultiColumnComboBox]({% slug templates_multicolumncombobox %}#toc-fixed-group-template)
 * - [Using `FixedGroupTemplate` with the DropDownList]({% slug templates_ddl %}#toc-fixed-group-template)
 * - [Using `FixedGroupTemplate` with the MultiSelect]({% slug templates_multiselect %}#toc-fixed-group-template)
 *
 * @example
 * ```ts
 * import { groupBy } from '@progress/kendo-data-query';
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-combobox [data]="groupedData" textField="name" valueField="name">
 *    <ng-template kendoComboBoxFixedGroupTemplate let-groupName>
 *      <span>Food type: {{groupName}} option</span>
 *    </ng-template>
 *  </kendo-combobox>
 * `
 * })
 * class AppComponent {
 *   public data = [
 *       { name: "Pork", category: "Food", subcategory: "Meat" },
 *       { name: "Pepper", category: "Food", subcategory: "Vegetables" },
 *       { name: "Beef", category: "Food", subcategory: "Meat" }
 *   ];
 *   public groupedData = groupBy(this.data, [{field: "subcategory"}]);
 * }
 * ```
 */
var FixedGroupTemplateDirective = /** @class */ (function () {
    function FixedGroupTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    FixedGroupTemplateDirective = __decorate([
        Directive({
            selector: '[kendoDropDownListFixedGroupTemplate],[kendoComboBoxFixedGroupTemplate],[kendoMultiColumnComboBoxFixedGroupTemplate],[kendoAutoCompleteFixedGroupTemplate],[kendoMultiSelectFixedGroupTemplate]'
        }),
        __metadata("design:paramtypes", [TemplateRef])
    ], FixedGroupTemplateDirective);
    return FixedGroupTemplateDirective;
}());

/**
 * @hidden
 */
var SelectionService = /** @class */ (function () {
    function SelectionService() {
        this.onSelect = new EventEmitter();
        this.onChange = new EventEmitter();
        this.onFocus = new EventEmitter();
        this.total = 0;
        this.selectedIndices = [];
    }
    SelectionService.prototype.getTotal = function () {
        return this.total;
    };
    SelectionService.prototype.isSelected = function (index) {
        return isPresent(this.selectedIndices.find(function (current) { return current === index; }));
    };
    SelectionService.prototype.isFocused = function (index) {
        return index === this.focused;
    };
    SelectionService.prototype.focus = function (index) {
        if (this.isFocused(index)) {
            return;
        }
        this.focused = index;
        this.onFocus.emit(index);
    };
    SelectionService.prototype.select = function (index) {
        if (this.isSelected(index)) {
            return;
        }
        this.selectedIndices = [index];
        this.focused = index;
        this.onSelect.emit({
            indices: [index],
            newSelection: isPresent(index)
        });
    };
    SelectionService.prototype.add = function (index) {
        if (this.isSelected(index)) {
            return;
        }
        this.selectedIndices.push(index);
        this.focused = index;
        this.onChange.emit({
            added: index,
            indices: this.selectedIndices.slice()
        });
    };
    SelectionService.prototype.unselect = function (index) {
        if (!this.isSelected(index)) {
            return;
        }
        var position = this.selectedIndices.indexOf(index);
        this.selectedIndices.splice(position, 1);
        this.focused = index;
        this.onChange.emit({
            indices: this.selectedIndices.slice(),
            removed: index
        });
    };
    SelectionService.prototype.change = function (index) {
        var newSelection = isPresent(index) && !this.isSelected(index);
        this.selectedIndices = [index];
        this.focused = index;
        this.onChange.emit({
            indices: [index],
            newSelection: newSelection
        });
    };
    SelectionService.prototype.resetSelection = function (index) {
        this.selectedIndices = index instanceof Array ? index : [index];
        this.focused = this.selectedIndices[this.selectedIndices.length - 1];
    };
    Object.defineProperty(SelectionService.prototype, "selected", {
        get: function () {
            return this.selectedIndices.slice();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionService.prototype, "focused", {
        get: function () {
            return this.focusedIndex;
        },
        set: function (index) {
            if (this.focusedIndex !== index) {
                this.focusedIndex = index;
                this.onFocus.emit(index);
            }
        },
        enumerable: true,
        configurable: true
    });
    SelectionService = __decorate([
        Injectable()
    ], SelectionService);
    return SelectionService;
}());

/**
 * @hidden
 */
var NavigationAction;
(function (NavigationAction) {
    NavigationAction[NavigationAction["Undefined"] = 0] = "Undefined";
    NavigationAction[NavigationAction["Open"] = 1] = "Open";
    NavigationAction[NavigationAction["Close"] = 2] = "Close";
    NavigationAction[NavigationAction["Enter"] = 3] = "Enter";
    NavigationAction[NavigationAction["Tab"] = 4] = "Tab";
    NavigationAction[NavigationAction["Esc"] = 5] = "Esc";
    NavigationAction[NavigationAction["Delete"] = 6] = "Delete";
    NavigationAction[NavigationAction["Backspace"] = 7] = "Backspace";
    NavigationAction[NavigationAction["Home"] = 8] = "Home";
    NavigationAction[NavigationAction["End"] = 9] = "End";
    NavigationAction[NavigationAction["Up"] = 10] = "Up";
    NavigationAction[NavigationAction["Down"] = 11] = "Down";
    NavigationAction[NavigationAction["Left"] = 12] = "Left";
    NavigationAction[NavigationAction["Right"] = 13] = "Right";
})(NavigationAction || (NavigationAction = {}));

/**
 * @hidden
 */
var DataService = /** @class */ (function () {
    function DataService() {
        this.grouped = false;
        this.groupIndices = [];
    }
    Object.defineProperty(DataService.prototype, "data", {
        get: function () {
            if (this.grouped) {
                return this._flatData;
            }
            return this._data;
        },
        set: function (data) {
            this._data = data;
            this.grouped = this.isGrouped(data);
            if (this.grouped) {
                this.groupIndices = this.getGroupIndices(data);
                this._flatData = this.flatten(data);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataService.prototype, "itemsCount", {
        /**
         * @hidden
         * Used to get the actual items count, i.e. excluding the header items in case of grouping.
         */
        get: function () {
            if (!isPresent(this.data) || this.data.length === 0) {
                return 0;
            }
            var items = this.grouped ? this._flatData.filter(function (item) { return !item.header; }) : this.data;
            return items.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     * Used to determine if the component received grouped data.
     */
    DataService.prototype.isGrouped = function (data) {
        // GroupResult { aggregates: AggregateResult, field: string, items: object[], value: any }
        // https://www.telerik.com/kendo-angular-ui/components/dataquery/api/GroupResult/
        return (isPresent(data) && data.length !== 0) && isPresent(data[0]) && hasProps(data[0], ['aggregates', 'field', 'items', 'value']);
    };
    /**
     * @hidden
     * Used to calculate the last item index of each group.
     */
    DataService.prototype.getGroupIndices = function (data) {
        var groupIndices = [];
        for (var i = 0; i <= data.length - 1; i++) {
            groupIndices[i] = (groupIndices[i - 1] || 0) + data[i].items.length;
        }
        return groupIndices;
    };
    /**
     * @hidden
     * Used to get a flat array containing all items matching certain criteria.
     */
    DataService.prototype.filter = function (predicate) {
        var result = [];
        if (this.isGrouped(this.data)) {
            for (var i = 0; i <= this.groupIndices.length - 1; i++) {
                var matches = this.data[i].items.filter(predicate);
                if (matches) {
                    result = result.concat(matches);
                }
            }
        }
        else {
            result = this.data.filter(predicate);
        }
        return result;
    };
    /**
     * @hidden
     * Used to get the index of a given data item.
     */
    DataService.prototype.indexOf = function (item, startFrom) {
        if (startFrom === void 0) { startFrom = 0; }
        var predicate = function (element) {
            return element === item;
        };
        if (this.grouped) {
            predicate = function (element) {
                return element.value === item;
            };
        }
        return this.findIndex(predicate, startFrom);
    };
    /**
     * @hidden
     * Used to get the index of a data item based on an expression.
     */
    DataService.prototype.findIndex = function (predicate, startFrom) {
        if (startFrom === void 0) { startFrom = 0; }
        var index = -1;
        if (this.grouped) {
            var data = this._flatData.filter(function (item) { return !item.header && item.offsetIndex >= startFrom; });
            index = data.findIndex(predicate);
            index = data[index] ? data[index].offsetIndex : -1;
        }
        else {
            var data = this.data.slice(startFrom);
            var itemIndex = data.findIndex(predicate);
            index = itemIndex !== -1 ? itemIndex + startFrom : -1;
        }
        return index;
    };
    /**
     * @hidden
     * Used to get the closest group header prior to an item index.
     */
    DataService.prototype.closestGroup = function (index) {
        for (var i = index; i >= 0; i--) {
            if (this._flatData[i].header) {
                return this._flatData[i];
            }
        }
    };
    /**
     * @hidden
     * Used to get the first item matching the criteria.
     */
    DataService.prototype.find = function (predicate) {
        var index = this.findIndex(predicate);
        return this.itemAt(index);
    };
    /**
     * @hidden
     * Used to get the true index in a flattened data array.
     */
    DataService.prototype.flatIndex = function (index) {
        if (this.itemsCount === 0) {
            return -1;
        }
        if (this.grouped) {
            var match = this._flatData.find(function (item) { return !item.header && item.offsetIndex === index; });
            if (match) {
                return match.index;
            }
        }
        else {
            return index;
        }
        return -1;
    };
    /**
     * @hidden
     * Used to get the item at the provided index.
     */
    DataService.prototype.itemAt = function (index) {
        var dataItem;
        if (this.itemsCount === 0) {
            return dataItem;
        }
        if (this.grouped) {
            var match = this._flatData.find(function (item) { return !item.header && item.offsetIndex === index; });
            if (match) {
                dataItem = match.value;
            }
        }
        else {
            dataItem = this.data[index];
        }
        return dataItem;
    };
    /**
     * @hidden
     * Used to get the group at the provided index.
     */
    DataService.prototype.groupAt = function (index) {
        if (this.itemsCount === 0 || !this.isGrouped) {
            return;
        }
        return this._flatData.find(function (item) { return item.header && item.index === index; });
    };
    /**
     * @hidden
     * Used to get the field by which the data is grouped.
     */
    DataService.prototype.groupField = function () {
        if (this.itemsCount === 0 || !this.isGrouped) {
            return null;
        }
        return this._data[0].field;
    };
    /**
     * @hidden
     * Used to get the group to which a dataItem belongs.
     */
    DataService.prototype.itemGroup = function (item) {
        if (!item || this.itemsCount === 0 || !this.isGrouped) {
            return;
        }
        var fieldName = this.groupField();
        if (fieldName) {
            return getter$1(item, fieldName);
        }
    };
    DataService.prototype.flatten = function (data, group, offset, groupIndex) {
        if (group === void 0) { group = undefined; }
        if (offset === void 0) { offset = 0; }
        if (groupIndex === void 0) { groupIndex = 0; }
        var flat = [];
        if (isPresent(group)) {
            flat.push({
                header: true,
                index: groupIndex + offset,
                offsetIndex: groupIndex,
                value: group
            });
        }
        for (var i = 0; i < data.length; i++) {
            var result = [];
            if (data[i].items) {
                result = this.flatten(data[i].items, data[i].value, offset, i);
                offset = offset + data[i].items.length;
            }
            else {
                result.push({
                    header: false,
                    index: groupIndex + offset + i + 1,
                    offsetIndex: offset + i,
                    value: data[i]
                });
            }
            flat = flat.concat(result);
        }
        return flat;
    };
    DataService = __decorate([
        Injectable()
    ], DataService);
    return DataService;
}());

/**
 * @hidden
 */
var DisabledItemsService = /** @class */ (function () {
    function DisabledItemsService(dataService) {
        this.dataService = dataService;
        this.itemDisabled = null;
    }
    DisabledItemsService.prototype.isIndexDisabled = function (index) {
        if (this.itemDisabled) {
            var item = this.dataService.itemAt(index);
            if (isPresent(item)) {
                return this.itemDisabled({ dataItem: item, index: index });
            }
            else if (isPresent(this.defaultItem)) {
                return this.itemDisabled({ dataItem: this.defaultItem, index: -1 });
            }
        }
    };
    DisabledItemsService.prototype.isItemDisabled = function (item) {
        if (this.itemDisabled) {
            var index = this.dataService.indexOf(item);
            if (index !== -1) {
                return this.itemDisabled({ dataItem: item, index: index });
            }
            else if (isPresent(this.defaultItem)) {
                return this.itemDisabled({ dataItem: this.defaultItem, index: -1 });
            }
        }
    };
    DisabledItemsService = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [DataService])
    ], DisabledItemsService);
    return DisabledItemsService;
}());

var MIN_INDEX = 0;
/**
 * @hidden
 */
var NavigationEvent = /** @class */ (function () {
    /**
     * The index of the item to which the user navigated.
     */
    function NavigationEvent(index, originalEvent) {
        this.index = index;
        this.originalEvent = originalEvent;
    }
    return NavigationEvent;
}());
/**
 * @hidden
 */
var NavigationService = /** @class */ (function () {
    function NavigationService(disabledItemsService, selectionService) {
        this.disabledItemsService = disabledItemsService;
        this.selectionService = selectionService;
        this.open = new EventEmitter();
        this.close = new EventEmitter();
        this.enter = new EventEmitter();
        this.tab = new EventEmitter();
        this.esc = new EventEmitter();
        this.up = new EventEmitter();
        this.right = new EventEmitter();
        this.down = new EventEmitter();
        this.left = new EventEmitter();
        this.delete = new EventEmitter();
        this.backspace = new EventEmitter();
        this.home = new EventEmitter();
        this.end = new EventEmitter();
    }
    NavigationService.prototype.process = function (args) {
        var keyCode = args.originalEvent.keyCode;
        var altKey = args.originalEvent.altKey;
        var index;
        var action = NavigationAction.Undefined;
        if (altKey && keyCode === Keys.ArrowDown) {
            action = NavigationAction.Open;
        }
        else if (altKey && keyCode === Keys.ArrowUp) {
            action = NavigationAction.Close;
        }
        else if (keyCode === Keys.Enter) {
            action = NavigationAction.Enter;
        }
        else if (keyCode === Keys.Escape) {
            action = NavigationAction.Esc;
        }
        else if (keyCode === Keys.Tab) {
            action = NavigationAction.Tab;
        }
        else if (keyCode === Keys.ArrowUp) {
            index = this.next({ current: args.current, start: args.min, end: args.max, step: -1 });
            action = NavigationAction.Up;
        }
        else if (keyCode === Keys.ArrowLeft) {
            index = this.next({ current: args.current, start: args.min, end: args.max, step: -1 });
            action = NavigationAction.Left;
        }
        else if (keyCode === Keys.ArrowDown) {
            index = this.next({ current: args.current, start: args.min, end: args.max, step: 1 });
            action = NavigationAction.Down;
        }
        else if (keyCode === Keys.ArrowRight) {
            index = this.next({ current: args.current, start: args.min, end: args.max, step: 1 });
            action = NavigationAction.Right;
        }
        else if (keyCode === Keys.Home) {
            index = this.isDisabled(MIN_INDEX) ? args.current : MIN_INDEX;
            action = NavigationAction.Home;
        }
        else if (keyCode === Keys.End) {
            index = this.isDisabled(args.max) ? args.current : args.max;
            action = NavigationAction.End;
        }
        else if (keyCode === Keys.Delete) {
            action = NavigationAction.Delete;
        }
        else if (keyCode === Keys.Backspace) {
            action = NavigationAction.Backspace;
        }
        var eventData = new NavigationEvent(index, args.originalEvent);
        if (action !== NavigationAction.Undefined) {
            this[NavigationAction[action].toLowerCase()].emit(eventData);
        }
        return action;
    };
    NavigationService.prototype.next = function (args) {
        var current = args.current, start = args.start, end = args.end, step = args.step;
        var nextIndex = !isPresent(current) ? start : this.clampIndex(current + step, start, end);
        var firstFocusableIndex = this.firstFocusableIndex(nextIndex, start, end, step);
        if (isPresent(firstFocusableIndex)) {
            return firstFocusableIndex;
        }
        if (this.selectionService.isSelected(current) && current >= start) {
            return current;
        }
        var inversedStep = -1 * step;
        return this.firstFocusableIndex(nextIndex, start, end, inversedStep);
    };
    NavigationService.prototype.clampIndex = function (index, min, max) {
        if (!isPresent(index) || index < min) {
            return min;
        }
        if (index > max) {
            return max;
        }
        return index;
    };
    NavigationService.prototype.firstFocusableIndex = function (startIndex, min, max, step) {
        while (min <= startIndex && startIndex <= max) {
            if (!this.isDisabled(startIndex)) {
                return startIndex;
            }
            startIndex += step;
        }
        return undefined;
    };
    NavigationService.prototype.isDisabled = function (index) {
        if (this.disabledItemsService) {
            return this.disabledItemsService.isIndexDisabled(index);
        }
    };
    NavigationService = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [DisabledItemsService,
            SelectionService])
    ], NavigationService);
    return NavigationService;
}());

/**
 * Renders content when no data is available. To define the no-data template, nest a `<ng-template>` tag
 * with the `kendo<ComponentName>NoDataTemplate` directive inside the component tag.
 *
 * - [Using `NoDataTemplate` with the AutoComplete]({% slug templates_autocomplete %}#toc-no-data-template)
 * - [Using `NoDataTemplate` with the ComboBox]({% slug templates_combobox %}#toc-no-data-template)
 * - [Using `NoDataTemplate` with the MultiColumnComboBox]({% slug templates_multicolumncombobox %}#toc-no-data-template)
 * - [Using `NoDataTemplate` with the DropDownList]({% slug templates_ddl %}#toc-no-data-template)
 * - [Using `NoDataTemplate` with the DropDownTree]({% slug templates_ddt %}#toc-no-data-template)
 * - [Using `NoDataTemplate` with the MultiSelect]({% slug templates_multiselect %}#toc-no-data-template)
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-combobox [data]="listItems">
 *    <ng-template kendoComboBoxNoDataTemplate>
 *      <h4>No data!</h4>
 *    </ng-template>
 *  </kendo-combobox>
 * `
 * })
 * class AppComponent {
 *   public listItems: Array<string> = [];
 * }
 * ```
 */
var NoDataTemplateDirective = /** @class */ (function () {
    function NoDataTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    NoDataTemplateDirective = __decorate([
        Directive({
            selector: '[kendoDropDownListNoDataTemplate],[kendoDropDownTreeNoDataTemplate],[kendoComboBoxNoDataTemplate],[kendoMultiColumnComboBoxNoDataTemplate],[kendoAutoCompleteNoDataTemplate],[kendoMultiSelectNoDataTemplate],[kendoMultiSelectTreeNoDataTemplate]'
        }),
        __metadata("design:paramtypes", [TemplateRef])
    ], NoDataTemplateDirective);
    return NoDataTemplateDirective;
}());

/**
 * @hidden
 */
var PreventableEvent = /** @class */ (function () {
    function PreventableEvent() {
        this.prevented = false;
    }
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses the built-in behavior that follows the event.
     */
    PreventableEvent.prototype.preventDefault = function () {
        this.prevented = true;
    };
    /**
     * If the event is prevented by any of its subscribers, returns `true`.
     *
     * @returns `true` if the default action was prevented. Otherwise, returns `false`.
     */
    PreventableEvent.prototype.isDefaultPrevented = function () {
        return this.prevented;
    };
    return PreventableEvent;
}());

/**
 * Defines the mandatory properties of the `kendoDropDownFilter` directive
 * so that `kendoDropDownFilter` can be used with any of the DropDowns components
 * which implement the `FilterableDropDownComponentBase` class.
 *
 * @hidden
 */
var FilterableComponent = /** @class */ (function () {
    function FilterableComponent() {
    }
    return FilterableComponent;
}());

/**
 * @hidden
 */
var ListItemDirective = /** @class */ (function () {
    function ListItemDirective(element) {
        this.element = element;
    }
    ListItemDirective = __decorate([
        Directive({
            selector: '"li[role=option], li[role=group]"' // tslint:disable-line
        }),
        __metadata("design:paramtypes", [ElementRef])
    ], ListItemDirective);
    return ListItemDirective;
}());

/**
 * @hidden
 */
var ListComponent = /** @class */ (function () {
    /* tslint:disable:member-ordering */
    function ListComponent(dataService, wrapper, selectionService, disabledItemsService, cdr, zone, renderer) {
        var _this = this;
        this.dataService = dataService;
        this.wrapper = wrapper;
        this.selectionService = selectionService;
        this.disabledItemsService = disabledItemsService;
        this.cdr = cdr;
        this.zone = zone;
        this.renderer = renderer;
        this.selected = [];
        this.focused = -1;
        this.show = true;
        this.multipleSelection = false;
        this.listClass = 'k-list k-reset';
        this.checkboxes = { enabled: false };
        this.onClick = new EventEmitter();
        this.pageChange = new EventEmitter();
        this.listResize = new EventEmitter();
        this.startFrom = 0;
        this.lastLoaded = 0;
        this.lastScrollTop = 0;
        this.scrollToFocused = false;
        this.selectSubscription = merge(this.selectionService.onSelect.pipe(map(function (args) { return args.indices[0]; })), this.selectionService.onFocus)
            .pipe(
        // handle only the very last onSelect/onFocus emission
        switchMap(function (event) { return _this.zone.onStable.pipe(take(1), map(function () { return event; })); }))
            .subscribe(this.scrollToItem.bind(this));
    }
    Object.defineProperty(ListComponent.prototype, "data", {
        get: function () {
            return this._data;
        },
        set: function (data) {
            this._data = data[0] && data[0].header ? data.slice(0) : data;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ListComponent.prototype, "pageSize", {
        get: function () {
            if (this.virtual.pageSize) {
                return this.virtual.pageSize;
            }
            var size = Math.round(this.height / this.virtual.itemHeight);
            return size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ListComponent.prototype, "scrollHeight", {
        get: function () {
            return (this.dataService.grouped ? this.virtual.total - 1 : this.virtual.total) * this.virtual.itemHeight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ListComponent.prototype, "overflowY", {
        get: function () {
            if (isPresent(this.virtual)) {
                var overflow = this.hasVirtualScrollbar() ? 'scroll' : 'hidden';
                return overflow;
            }
        },
        enumerable: true,
        configurable: true
    });
    ListComponent.prototype.ngOnChanges = function (changes) {
        if (isChanged('data', changes, false)) {
            if (this.lastLoaded <= 0) {
                this.lastLoaded = this.data.length - 1;
                this.scrollToFocused = !changes.data.isFirstChange();
            }
        }
    };
    ListComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        this.zone.runOutsideAngular(function () {
            _this.scrollSubscription = fromEvent(_this.content.nativeElement, "scroll").pipe(auditTime(100), tap(_this.prefetchData.bind(_this)), tap(_this.findCurrentGroup.bind(_this))).subscribe(function () {
                _this.lastScrollTop = _this.content.nativeElement.scrollTop;
            });
        });
    };
    ListComponent.prototype.ngAfterViewChecked = function () {
        if (this.virtual) {
            this.positionItems();
        }
        if (this.items && this.scrollToFocused) {
            this.scrollToFocused = false;
            var scrollTarget = this.items.length && this.selectionService.focused === -1 ? 0 : this.selectionService.focused;
            this.scrollToItem(scrollTarget);
        }
        if (this.dataService.grouped) {
            this.findCurrentGroup();
        }
    };
    ListComponent.prototype.ngOnDestroy = function () {
        this.selectSubscription.unsubscribe();
        if (this.scrollSubscription) {
            this.scrollSubscription.unsubscribe();
        }
    };
    ListComponent.prototype.onCheckedChange = function (e, index) {
        var isChecked = e.target['checked'];
        if (isChecked && !this.selectionService.isSelected(index)) {
            this.selectionService.add(index);
        }
        if (!isChecked && this.selectionService.isSelected(index)) {
            this.selectionService.unselect(index);
        }
    };
    ListComponent.prototype.isChecked = function (index) {
        var normalizedIndex = this.virtual ? index + this.virtual.skip : index;
        return this.selectionService.isSelected(normalizedIndex);
    };
    ListComponent.prototype.firstVisibleItem = function () {
        var _this = this;
        var content = this.content.nativeElement;
        var rect = content.getBoundingClientRect();
        // IE9 hack
        var disabled = Array.prototype.slice.call(content.querySelectorAll(".k-state-disabled"));
        // This is a workaround for finding elements with pointer-events: none;
        disabled.forEach(function (el) { return _this.renderer.setStyle(el, "pointer-events", "auto"); });
        var item = document.elementFromPoint(rect.left + 1, rect.top + 1);
        disabled.forEach(function (el) { return _this.renderer.setStyle(el, "pointer-events", "none"); });
        // return the closest `li` item to cover the custom template scenario
        return closest(item, 'li');
    };
    ListComponent.prototype.findCurrentGroup = function () {
        if (!this.dataService.grouped) {
            this.currentGroup = undefined;
            return;
        }
        var item = this.firstVisibleItem();
        if (item) {
            var index = void 0;
            if (item.getAttribute("role") === "group") {
                index = parseInt(item.getAttribute("group-index"), 10);
                this.currentGroup = this.dataService.groupAt(index).value;
            }
            else {
                index = parseInt(item.getAttribute("index"), 10);
                this.currentGroup = this.dataService.itemGroup(this.dataService.itemAt(index));
            }
        }
        else {
            this.currentGroup = undefined;
        }
        this.cdr.detectChanges();
    };
    ListComponent.prototype.prefetchData = function () {
        if (!this.virtual) {
            return;
        }
        var visibleItems = Math.trunc(this.content.nativeElement.clientHeight / this.virtual.itemHeight);
        var offsetY = this.content.nativeElement.scrollTop;
        var start = Math.trunc(offsetY / this.virtual.itemHeight);
        var down = offsetY > this.lastScrollTop;
        var nextPage = (start + visibleItems >= this.lastLoaded) && this.lastLoaded < this.virtual.total - 1;
        var leftOver = this.pageSize - (this.lastLoaded - this.startFrom);
        var prevPage = this.lastLoaded - this.pageSize + visibleItems >= start - leftOver;
        if (down && nextPage) {
            this.changePage(start);
        }
        if (!down && prevPage) {
            this.changePage(start - this.pageSize + visibleItems + 1);
        }
    };
    ListComponent.prototype.changePage = function (start) {
        var _this = this;
        this.zone.run(function () {
            var end = _this.pageSize + start;
            if (end > _this.virtual.total) {
                start--;
                end = _this.virtual.total;
            }
            if (start < 0) {
                start = 0;
            }
            _this.startFrom = start;
            _this.lastLoaded = end;
            _this.pageChange.emit({ skip: start, take: _this.pageSize });
        });
    };
    ListComponent.prototype.index = function (groupIndex, itemIndex) {
        return groupIndex > 0 ? (this.dataService.groupIndices[groupIndex - 1] + itemIndex) : itemIndex;
    };
    ListComponent.prototype.getText = function (dataItem) {
        return getter$1(dataItem, this.textField);
    };
    ListComponent.prototype.getValue = function (dataItem) {
        return getter$1(dataItem, this.valueField);
    };
    ListComponent.prototype.isDisabled = function (index) {
        if (isPresent(this.virtual)) {
            index += this.virtual.skip;
        }
        return this.disabledItemsService.isIndexDisabled(index);
    };
    ListComponent.prototype.scrollToItem = function (index) {
        var flatIndex = index;
        if (this.dataService.grouped) {
            // takes into account the group header items
            flatIndex = this.dataService.flatIndex(index);
            /* The first group header item is not rendered in the list (see template), so subtract 1 when calulating the flat index.
               With virtualization enabled, the first group header could be in a previous page, in which case don't subtract anything. */
            var groupHeaderOffset = this.firstGroupHeaderInTargetedPage(flatIndex) ? -1 : 0;
            flatIndex += groupHeaderOffset;
        }
        if (this.virtual && flatIndex > -1) {
            this.scrollToIndex(flatIndex);
            return;
        }
        var items = this.items.toArray();
        if (isPresent(items[flatIndex]) && flatIndex !== -1) {
            this.scroll(items[flatIndex].element);
        }
    };
    ListComponent.prototype.scrollToIndex = function (index) {
        var content = this.content.nativeElement;
        var contentScrollTop = content.scrollTop;
        var itemOffsetTop = index * this.virtual.itemHeight;
        var itemOffsetHeight = this.virtual.itemHeight;
        var contentOffsetHeight = content.clientHeight;
        var bottomDistance = itemOffsetTop + itemOffsetHeight;
        if (contentScrollTop > itemOffsetTop) {
            contentScrollTop = itemOffsetTop;
        }
        else if (bottomDistance > (contentScrollTop + contentOffsetHeight)) {
            contentScrollTop = (bottomDistance - contentOffsetHeight);
        }
        content.scrollTop = contentScrollTop;
    };
    ListComponent.prototype.scroll = function (item) {
        if (!item) {
            return;
        }
        var nativeElement = item.nativeElement;
        var content = this.content.nativeElement, itemOffsetTop = nativeElement.offsetTop, itemOffsetHeight = nativeElement.offsetHeight, contentScrollTop = content.scrollTop, contentOffsetHeight = content.clientHeight, bottomDistance = itemOffsetTop + itemOffsetHeight;
        if (contentScrollTop > itemOffsetTop) {
            contentScrollTop = itemOffsetTop;
        }
        else if (bottomDistance > (contentScrollTop + contentOffsetHeight)) {
            contentScrollTop = (bottomDistance - contentOffsetHeight);
        }
        content.scrollTop = contentScrollTop;
    };
    /**
     * Indicates whether a scrollbar is currently rendered in the list.
     */
    ListComponent.prototype.hasScrollbar = function () {
        if (!(isPresent(this.items) && this.items.length && isPresent(this.list) && isPresent(this.content))) {
            return false;
        }
        var hasVirtualScroll = isPresent(this.virtual) && this.hasVirtualScrollbar();
        return hasVirtualScroll || this.list.nativeElement.scrollHeight > this.content.nativeElement.offsetHeight;
    };
    /**
     * Indicates whether the scrollbar should be visible in virtual mode.
     */
    ListComponent.prototype.hasVirtualScrollbar = function () {
        var contentOffsetHeight = this.content.nativeElement.offsetHeight;
        var virtualOffsetHeight = this.virtualContainer && this.virtualContainer.nativeElement.offsetHeight;
        return this.virtualContainer && virtualOffsetHeight > contentOffsetHeight;
    };
    ListComponent.prototype.positionItems = function () {
        var _this = this;
        this.items.forEach(function (item, index) {
            var offsetY = (index + _this.startFrom) * _this.virtual.itemHeight;
            _this.renderer.setStyle(item.element.nativeElement, "transform", "translateY(" + offsetY + "px");
        });
    };
    /**
     * Indicates whether the first group header from the data set is in the targeted virtual page.
     */
    ListComponent.prototype.firstGroupHeaderInTargetedPage = function (itemIndex) {
        if (!isPresent(this.virtual)) {
            return true;
        }
        return this.virtual.skip === 0 && (this.virtual.pageSize > itemIndex);
    };
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], ListComponent.prototype, "selected", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], ListComponent.prototype, "focused", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ListComponent.prototype, "textField", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ListComponent.prototype, "valueField", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], ListComponent.prototype, "height", void 0);
    __decorate([
        Input(),
        __metadata("design:type", ItemTemplateDirective)
    ], ListComponent.prototype, "template", void 0);
    __decorate([
        Input(),
        __metadata("design:type", GroupTemplateDirective)
    ], ListComponent.prototype, "groupTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", FixedGroupTemplateDirective)
    ], ListComponent.prototype, "fixedGroupTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], ListComponent.prototype, "show", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ListComponent.prototype, "id", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ListComponent.prototype, "optionPrefix", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], ListComponent.prototype, "multipleSelection", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ListComponent.prototype, "virtual", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ListComponent.prototype, "listClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ListComponent.prototype, "checkboxes", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array),
        __metadata("design:paramtypes", [Array])
    ], ListComponent.prototype, "data", null);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], ListComponent.prototype, "onClick", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], ListComponent.prototype, "pageChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], ListComponent.prototype, "listResize", void 0);
    __decorate([
        ViewChildren(ListItemDirective),
        __metadata("design:type", QueryList)
    ], ListComponent.prototype, "items", void 0);
    __decorate([
        ViewChild('content', { static: true }),
        __metadata("design:type", ElementRef)
    ], ListComponent.prototype, "content", void 0);
    __decorate([
        ViewChild('list', { static: true }),
        __metadata("design:type", ElementRef)
    ], ListComponent.prototype, "list", void 0);
    __decorate([
        ViewChild('virtualContainer', { static: false }),
        __metadata("design:type", ElementRef)
    ], ListComponent.prototype, "virtualContainer", void 0);
    ListComponent = __decorate([
        Component({
            selector: 'kendo-list',
            template: "\n    <div *ngIf=\"dataService.grouped\"\n        class='k-outer-group-header k-first'\n        [ngClass]=\"{'k-virtual-item': virtual}\"\n        [ngStyle]=\"{\n            'height.px': virtual?.itemHeight,\n            'minHeight.px' : virtual?.itemHeight,\n            'boxSizing' : virtual ? 'border-box' : 'inherit'}\"\n        >\n        <ng-template *ngIf=\"fixedGroupTemplate\"\n            [templateContext]=\"{\n                templateRef: fixedGroupTemplate.templateRef,\n                $implicit: currentGroup\n            }\">\n        </ng-template>\n        <ng-template [ngIf]=\"!fixedGroupTemplate\"><strong>{{ currentGroup }}</strong> </ng-template>\n    </div>\n    <div #content\n         [ngClass]=\"{ 'k-virtual-content': virtual, 'k-list-scroller': !virtual }\"\n         [style.maxHeight.px]=\"height\"\n         [style.overflowY]=\"overflowY\"\n         unselectable=\"on\">\n    <ul #list\n        role=\"listbox\"\n        [class]=\"listClass\"\n        [ngClass]=\"{ 'k-virtual-list': virtual }\"\n        [attr.id]=\"id\"\n        [attr.aria-hidden]=\"!show\">\n         <ng-template *ngIf=\"!dataService.grouped && show\" ngFor let-dataItem let-itemIndex=\"index\" [ngForOf]=\"data\">\n            <li\n                role=\"option\"\n                kendoDropDownsSelectable\n                [checkboxes]=\"checkboxes\"\n                [height]=\"virtual?.itemHeight\"\n                [index]=\"itemIndex + startFrom\"\n                [multipleSelection]=\"multipleSelection\"\n                [attr.id]=\"optionPrefix + '-' + getValue(dataItem)\"\n                [attr.tabIndex]=\"-1\"\n                class=\"k-item\"\n                [ngClass]=\"{ 'k-virtual-item': virtual, 'k-state-disabled': isDisabled(itemIndex) }\">\n                <label *ngIf=\"checkboxes.enabled\"\n                    class=\"k-checkbox-label\">\n                    <input type=\"checkbox\"\n                        class=\"k-checkbox\"\n                        (change)=\"onCheckedChange($event, itemIndex)\"\n                        [checked]=\"isChecked(itemIndex)\"\n                    />\n                </label>\n                <ng-template *ngIf=\"template\"\n                    [templateContext]=\"{\n                        templateRef: template.templateRef,\n                        $implicit: dataItem\n                    }\">\n                </ng-template>\n                <ng-template [ngIf]=\"!template\">{{ getText(dataItem) }}</ng-template>\n            </li>\n         </ng-template>\n         <ng-template *ngIf=\"dataService.grouped\" ngFor let-dataItem let-itemIndex=\"index\" [ngForOf]=\"data\">\n            <li\n                *ngIf=\"dataItem.header && dataItem.index > 0\"\n                role=\"group\"\n                class='k-outer-group-header'\n                [ngClass]=\"{ 'k-virtual-item': virtual }\"\n                [ngStyle]=\"{\n                    'height.px': virtual?.itemHeight,\n                    'minHeight.px' : virtual?.itemHeight,\n                    'boxSizing' : virtual ? 'border-box' : 'inherit'}\"\n                [attr.group-index]=\"dataItem.index\"\n                [attr.id]=\"optionPrefix + '-' + getValue(dataItem.value)\"\n                [attr.tabIndex]=\"-1\">\n                    <ng-template *ngIf=\"groupTemplate\"\n                          [templateContext]=\"{\n                            templateRef: groupTemplate.templateRef,\n                            $implicit: dataItem.value\n                    }\">\n                    </ng-template>\n                    <ng-template [ngIf]=\"!groupTemplate\"><strong> {{ dataItem.value }}</strong> </ng-template>\n              </li>\n              <li\n                *ngIf=\"!dataItem.header\"\n                role=\"option\"\n                kendoDropDownsSelectable\n                [height]=\"virtual?.itemHeight\"\n                [index]=\"dataItem.offsetIndex\"\n                [multipleSelection]=\"multipleSelection\"\n                [attr.absolute-index]=\"dataItem.index\"\n                [attr.id]=\"optionPrefix + '-' + getValue(dataItem.value)\"\n                [attr.tabIndex]=\"-1\"\n                class=\"k-item\"\n                [ngClass]=\"{ 'k-virtual-item': virtual, 'k-state-disabled': isDisabled(dataItem.offsetIndex) }\">\n                <ng-template *ngIf=\"template\"\n                    [templateContext]=\"{\n                        templateRef: template.templateRef,\n                        $implicit: dataItem.value\n                    }\">\n                </ng-template>\n                <ng-template [ngIf]=\"!template\">{{ getText(dataItem.value) }}</ng-template>\n            </li>\n        </ng-template>\n        <kendo-resize-sensor\n            *ngIf=\"!virtual\"\n            (resize)=\"listResize.emit()\"\n        >\n        </kendo-resize-sensor>\n    </ul>\n    <div *ngIf=\"virtual\" #virtualContainer class=\"k-height-container\" role=\"presentation\">\n        <div [style.height.px]=\"scrollHeight\">\n            <kendo-resize-sensor (resize)=\"listResize.emit()\"></kendo-resize-sensor>\n        </div>\n    </div>\n    </div>\n  "
        }),
        __metadata("design:paramtypes", [DataService,
            ElementRef,
            SelectionService,
            DisabledItemsService,
            ChangeDetectorRef,
            NgZone,
            Renderer2])
    ], ListComponent);
    return ListComponent;
}());

/**
 * @hidden
 */
var DEFAULTS = {
    pageSize: 50,
    itemHeight: 28
};
/**
 * @hidden
 */
var normalizeVirtualizationSettings = function (settings, defaultOverrides) {
    var defaults = Object.assign({}, DEFAULTS, defaultOverrides);
    if (settings === true) {
        return defaults;
    }
    if (!settings) {
        return null;
    }
    return __assign({ pageSize: DEFAULTS.pageSize }, settings);
};

/**
 * @hidden
 */
var TOUCH_ENABLED = new InjectionToken('dropdowns-touch-enabled');

/* tslint:disable:member-ordering */
var NO_VALUE = "";
/**
 * @hidden
 */
var AUTOCOMPLETE_VALUE_ACCESSOR = {
    multi: true,
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return AutoCompleteComponent; })
};
/**
 * Represents the [Kendo UI AutoComplete component for Angular]({% slug overview_autocomplete %}).
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-autocomplete
 *      [data]="listItems"
 *      [placeholder]="placeholder"
 *  >
 * `
 * })
 * class AppComponent {
 *   public placeholder: string = 'Type "it" for suggestions';
 *   public listItems: Array<string> = ["Item 1", "Item 2", "Item 3", "Item 4"];
 * }
 * ```
 */
var AutoCompleteComponent = /** @class */ (function () {
    function AutoCompleteComponent(localization, dataService, popupService, selectionService, navigationService, disabledItemsService, _zone, cdr, renderer, hostElement, touchEnabled$$1) {
        this.localization = localization;
        this.dataService = dataService;
        this.popupService = popupService;
        this.selectionService = selectionService;
        this.navigationService = navigationService;
        this.disabledItemsService = disabledItemsService;
        this._zone = _zone;
        this.cdr = cdr;
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.touchEnabled = touchEnabled$$1;
        /**
         * Defines whether the first match from the suggestions list will be automatically focused.
         * By default, `highlightFirst` is set to `true`.
         */
        this.highlightFirst = true;
        /**
         * @hidden
         */
        this.focusableId = "k-" + guid$1();
        /**
         * The hint which is displayed when the component is empty.
         */
        this.placeholder = "";
        /**
         * Sets the height of the suggestions list. By default, `listHeight` is 200px.
         *
         * > The `listHeight` property affects only the list of suggestions and not the whole popup container.
         * > To set the height of the popup container, use `popupSettings.height`.
         */
        this.listHeight = 200;
        /**
         * @hidden
         *
         * If set to `true`, renders a button on hovering over the component.
         * Clicking this button resets the value of the component to `undefined` and triggers the `change` event.
         */
        this.clearButton = true;
        /**
         * Sets the disabled state of the component.
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the component.
         */
        this.readonly = false;
        /**
         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        this.tabindex = 0;
        /**
         * Enables the [filtering]({% slug filtering_autocomplete %}) functionality.
         * If set to `true`, the component emits the `filterChange` event.
         */
        this.filterable = false;
        /**
         * Fires each time the value is changed&mdash;
         * when the component is blurred or the value is cleared through the **Clear** button
         * ([see example]({% slug overview_autocomplete %}#toc-events)).
         * When the value of the component is programmatically changed to `ngModel` or `formControl`
         * through its API or form binding, the `valueChange` event is not triggered because it
         * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time the user types in the input field.
         * You can filter the source based on the passed filtration value
         * ([see example]({% slug overview_autocomplete %}#toc-events)).
         */
        this.filterChange = new EventEmitter();
        /**
         * Fires each time the popup is about to open.
         * This event is preventable. If you cancel it, the popup will remain closed.
         */
        this.open = new EventEmitter();
        /**
         * Fires after the popup has been opened.
         */
        this.opened = new EventEmitter();
        /**
         * Fires each time the popup is about to close.
         * This event is preventable. If you cancel it, the popup will remain open.
         */
        this.close = new EventEmitter();
        /**
         * Fires after the popup has been closed.
         */
        this.closed = new EventEmitter();
        /**
         * Fires each time the user focuses the AutoComplete.
         */
        this.onFocus = new EventEmitter();
        /**
         * Fires each time the AutoComplete gets blurred.
         */
        this.onBlur = new EventEmitter();
        this.widgetClasses = true;
        this.listBoxId = guid$1();
        this.optionPrefix = guid$1();
        this.onChangeCallback = noop;
        this.onTouchedCallback = noop;
        this.popupMouseDownHandler = function (event) { return event.preventDefault(); };
        this._popupSettings = { animate: true };
        this._open = false;
        this._value = "";
        this.valueChangeSubject = new Subject();
        this._isFocused = false;
        validatePackage(packageMetadata);
        this.direction = localization.rtl ? 'rtl' : 'ltr';
        this.wrapper = this.hostElement.nativeElement;
        this.data = [];
        this.subscribeEvents();
        this.subscribeTouchEvents();
        this.selectionService.resetSelection([-1]);
    }
    AutoCompleteComponent_1 = AutoCompleteComponent;
    Object.defineProperty(AutoCompleteComponent.prototype, "width", {
        get: function () {
            var wrapperOffsetWidth = 0;
            if (isDocumentAvailable()) {
                wrapperOffsetWidth = this.wrapper.offsetWidth;
            }
            var width = this.popupSettings.width || wrapperOffsetWidth;
            var minWidth = isNaN(wrapperOffsetWidth) ? wrapperOffsetWidth : wrapperOffsetWidth + "px";
            var maxWidth = isNaN(width) ? width : width + "px";
            return { min: minWidth, max: maxWidth };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteComponent.prototype, "height", {
        get: function () {
            var popupHeight = this.popupSettings.height;
            return isPresent(popupHeight) ? popupHeight + "px" : 'auto';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteComponent.prototype, "listContainerClasses", {
        get: function () {
            var containerClasses = ['k-list-container', 'k-reset'];
            if (this.popupSettings.popupClass) {
                containerClasses.push(this.popupSettings.popupClass);
            }
            return containerClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteComponent.prototype, "suggestion", {
        get: function () {
            if (!this.text || !this.suggestedText) {
                this.suggestedText = undefined;
                return;
            }
            var hasMatch = this.suggestedText.toLowerCase().startsWith(this.text.toLowerCase());
            var shouldSuggest = this.suggest && !this.backspacePressed;
            if (shouldSuggest && hasMatch) {
                return this.suggestedText;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteComponent.prototype, "appendTo", {
        get: function () {
            var appendTo = this.popupSettings.appendTo;
            if (!appendTo || appendTo === 'root') {
                return undefined;
            }
            return appendTo === 'component' ? this.container : appendTo;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteComponent.prototype, "clearButtonVisiblity", {
        get: function () {
            if (this.touchEnabled) {
                return 'visible';
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Toggles the visibility of the popup.
     * If you use the `toggle` method to open or close the popup, the `open` and `close` events will not be fired.
     *
     * @param open - The state of the popup.
     */
    AutoCompleteComponent.prototype.toggle = function (open) {
        var _this = this;
        Promise.resolve(null).then(function () {
            var shouldOpen = isPresent(open) ? open : !_this._open;
            _this._toggle(shouldOpen);
        });
    };
    Object.defineProperty(AutoCompleteComponent.prototype, "isOpen", {
        /**
         * Returns the current open state of the popup.
         */
        get: function () {
            return this._open;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    AutoCompleteComponent.prototype.togglePopup = function (open) {
        var isDisabled = this.disabled || this.readonly;
        var sameState = this.isOpen === open;
        if (isDisabled || sameState) {
            return;
        }
        var isDefaultPrevented = this.triggerPopupEvents(open);
        if (!isDefaultPrevented) {
            this._toggle(open);
        }
    };
    Object.defineProperty(AutoCompleteComponent.prototype, "activeDescendant", {
        get: function () {
            if (!this.isOpen || !isPresent(this.selectionService.focused) || this.selectionService.focused === -1) {
                return null;
            }
            var dataItem = this.dataService.itemAt(this.selectionService.focused);
            return this.optionPrefix + "-" + getter$1(dataItem, this.valueField);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteComponent.prototype, "noDataLabel", {
        get: function () {
            if (this.data.length === 0) {
                return this.noDataText;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteComponent.prototype, "clearTitle", {
        get: function () {
            return this.localization.get('clearTitle');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteComponent.prototype, "data", {
        get: function () {
            var virtual = this.virtual;
            if (virtual) {
                var start = virtual.skip || 0;
                var end = start + virtual.pageSize;
                // Use length instead of itemsCount because of the grouping.
                virtual.total = this.dataService.data.length;
                return this.dataService.data.slice(start, end);
            }
            return this.dataService.data;
        },
        /**
         * Sets the data of the AutoComplete.
         *
         * > The data has to be provided in an array-like list.
         */
        set: function (data) {
            this.dataService.data = data || [];
            if (this.virtual) {
                this.virtual.skip = 0;
            }
            if (this.filterable) {
                this.selectionService.focused = this.isOpen && this.data.length && this.highlightFirst ? this.firstFocusableIndex(0) : -1;
            }
            if (this.suggest && this.dataService.itemsCount > 0) {
                this.suggestedText = getter$1(this.dataService.itemAt(0), this.valueField);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteComponent.prototype, "value", {
        get: function () {
            return this._value || NO_VALUE;
        },
        /**
         * Sets the value of the AutoComplete.
         */
        set: function (newValue) {
            this.verifySettings(newValue);
            this._value = newValue || NO_VALUE;
            this.text = this.value;
            this.cdr.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteComponent.prototype, "popupSettings", {
        get: function () {
            return this._popupSettings;
        },
        /**
         * Configures the popup of the AutoComplete.
         *
         * The available options are:
         * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
         * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped. The `auto` mode is not supported when virtual scrolling is enabled.
         * - `height: Number`&mdash;Sets the height of the popup container.
         * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
         * - `appendTo: "root" | "component" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.
         */
        set: function (settings) {
            this._popupSettings = Object.assign({ animate: true }, settings);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteComponent.prototype, "itemDisabled", {
        /**
         * Defines a Boolean function that is executed for each data item in the component
         * ([see examples]({% slug disableditems_autocomplete %})).
         * Determines whether the item will be disabled.
         */
        set: function (fn) {
            if (typeof fn !== 'function') {
                throw new Error("itemDisabled must be a function, but received " + JSON.stringify(fn) + ".");
            }
            this.disabledItemsService.itemDisabled = fn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteComponent.prototype, "tabIndex", {
        get: function () {
            return this.tabindex;
        },
        /**
         * @hidden
         */
        set: function (tabIndex) {
            this.tabindex = tabIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteComponent.prototype, "virtual", {
        get: function () {
            return this._virtualSettings;
        },
        /**
         * Enables the [virtualization]({% slug virtualization_autocomplete %}) functionality.
         */
        set: function (settings) {
            this._virtualSettings = normalizeVirtualizationSettings(settings);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteComponent.prototype, "isFocused", {
        get: function () {
            return this._isFocused;
        },
        set: function (isFocused) {
            this.renderer[isFocused ? 'addClass' : 'removeClass'](this.wrapper, "k-state-focused");
            this._isFocused = isFocused;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteComponent.prototype, "isDisabled", {
        get: function () {
            return this.disabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutoCompleteComponent.prototype, "dir", {
        get: function () {
            return this.direction;
        },
        enumerable: true,
        configurable: true
    });
    AutoCompleteComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.renderer.removeAttribute(this.wrapper, "tabindex");
        this.localizationChangeSubscription = this.localization
            .changes
            .subscribe(function (_a) {
            var rtl = _a.rtl;
            _this.direction = rtl ? 'rtl' : 'ltr';
            _this.setMessages();
        });
        this.setMessages();
    };
    AutoCompleteComponent.prototype.ngOnDestroy = function () {
        this.destroyPopup();
        this.unsubscribeEvents();
        clearTimeout(this.messagesTimeout);
        if (this.localizationChangeSubscription) {
            this.localizationChangeSubscription.unsubscribe();
        }
    };
    AutoCompleteComponent.prototype.ngOnChanges = function (changes) {
        var virtual = this.virtual;
        var requestInitialData = virtual && changes.data && changes.data.isFirstChange();
        if (requestInitialData) {
            this.pageChange({ skip: 0, take: virtual.pageSize });
        }
    };
    /**
     * Resets the value of the AutoComplete.
     * If you use the `reset` method to clear the value of the component,
     * the model will not update automatically and the `selectionChange` and `valueChange` events will not be fired.
     */
    AutoCompleteComponent.prototype.reset = function () {
        this.value = NO_VALUE;
    };
    /**
     * @hidden
     */
    AutoCompleteComponent.prototype.clearValue = function (event) {
        event.stopImmediatePropagation();
        this.focus();
        this.change(NO_VALUE);
        if (this.filterable) {
            this.filterChange.emit('');
        }
        this.selectionService.resetSelection([]);
    };
    /**
     * @hidden
     */
    AutoCompleteComponent.prototype.writeValue = function (value) {
        this.value = value;
    };
    /**
     * @hidden
     */
    AutoCompleteComponent.prototype.registerOnChange = function (fn) {
        this.onChangeCallback = fn;
    };
    /**
     * @hidden
     */
    AutoCompleteComponent.prototype.registerOnTouched = function (fn) {
        this.onTouchedCallback = fn;
    };
    /**
     * @hidden
     */
    AutoCompleteComponent.prototype.setDisabledState = function (isDisabled) {
        this.disabled = isDisabled;
    };
    /**
     * Focuses a specific item of the AutoComplete based on a provided index.
     * If null or invalid index is provided the focus will be removed.
     */
    AutoCompleteComponent.prototype.focusItemAt = function (index) {
        var isInRange = index >= 0 && index < this.data.length;
        if (isPresent(index) && isInRange && !this.disabledItemsService.isIndexDisabled(index)) {
            this.selectionService.focus(index);
        }
        else {
            this.selectionService.focus(-1);
        }
    };
    /**
     * Focuses the AutoComplete.
     */
    AutoCompleteComponent.prototype.focus = function () {
        if (!this.disabled) {
            this.searchbar.focus();
        }
    };
    /**
     * Blurs the AutoComplete.
     */
    AutoCompleteComponent.prototype.blur = function () {
        if (!this.disabled) {
            this.searchbar.blur();
        }
    };
    /**
     * @hidden
     */
    AutoCompleteComponent.prototype.onResize = function () {
        if (this._open) {
            var popupWrapper = this.popupRef.popupElement;
            var _a = this.width, min = _a.min, max = _a.max;
            popupWrapper.style.minWidth = min;
            popupWrapper.style.width = max;
        }
    };
    AutoCompleteComponent.prototype.emitChange = function (value) {
        this.onChangeCallback(value);
        this.valueChange.emit(value);
    };
    AutoCompleteComponent.prototype.verifySettings = function (newValue) {
        if (!isDevMode()) {
            return;
        }
        if (isPresent(newValue) && typeof newValue !== "string") {
            throw new Error("Expected value of type string. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/autocomplete/value-binding/");
        }
    };
    AutoCompleteComponent.prototype.search = function (text, startFrom) {
        if (startFrom === void 0) { startFrom = 0; }
        var index;
        if (text.length && this.dataService.itemsCount) {
            index = this.dataService.findIndex(this.findIndexPredicate(text), startFrom);
        }
        else {
            index = -1;
        }
        if (this.disabledItemsService.isIndexDisabled(index)) {
            if (index + 1 < this.dataService.itemsCount) {
                this.search(text, index + 1);
            }
            else {
                this.selectionService.focus(-1);
            }
        }
        else {
            this.selectionService.focus(index);
            if (this.suggest) {
                this.suggestedText = getter$1(this.dataService.itemAt(index), this.valueField);
            }
        }
    };
    AutoCompleteComponent.prototype.navigate = function (index) {
        if (!this.isOpen) {
            return;
        }
        this.selectionService.focus(index);
    };
    /**
     * @hidden
     */
    AutoCompleteComponent.prototype.handleNavigate = function (event) {
        var focused = isNaN(this.selectionService.focused) ? this.firstFocusableIndex(0) : this.selectionService.focused;
        if (this.disabled || this.readonly || isNaN(focused)) {
            return;
        }
        var action = this.navigationService.process({
            current: focused,
            max: this.dataService.itemsCount - 1,
            min: 0,
            originalEvent: event
        });
        if (action !== NavigationAction.Undefined &&
            action !== NavigationAction.Backspace &&
            action !== NavigationAction.Delete &&
            action !== NavigationAction.Home &&
            action !== NavigationAction.End &&
            action !== NavigationAction.Left &&
            action !== NavigationAction.Right &&
            ((action === NavigationAction.Enter && this.isOpen) || action !== NavigationAction.Enter)) {
            event.preventDefault();
        }
    };
    AutoCompleteComponent.prototype.handleEnter = function (event) {
        var focused = this.selectionService.focused;
        var value;
        if (this.isOpen) {
            event.originalEvent.preventDefault();
        }
        if (focused >= 0) {
            value = getter$1(this.dataService.itemAt(focused), this.valueField);
        }
        else {
            var match = this.suggest && this.suggestedText && this.data.length &&
                getter$1(this.dataService.itemAt(0), this.valueField).toLowerCase() === this.searchbar.value.toLowerCase();
            if (this.isOpen && match) {
                value = this.suggestedText;
            }
            else {
                value = this.searchbar.value;
            }
        }
        this.change(value);
    };
    AutoCompleteComponent.prototype.handleEscape = function () {
        this.togglePopup(false);
        this.selectionService.focused = -1;
        this.suggestedText = null;
    };
    /**
     * @hidden
     */
    AutoCompleteComponent.prototype.searchBarChange = function (text) {
        var currentTextLength = isPresent(this.text) ? this.text.length : 0;
        this.backspacePressed = (text.length < currentTextLength) ? true : false;
        this.text = text;
        this.togglePopup(text.length > 0);
        if (!this.highlightFirst) {
            this.selectionService.focused = -1;
        }
        if (this.filterable) {
            this.filterChange.emit(text);
        }
        else if (this.highlightFirst) {
            this.search(text);
        }
    };
    /**
     * @hidden
     */
    AutoCompleteComponent.prototype.handleFocus = function () {
        var _this = this;
        this.isFocused = true;
        if (hasObservers(this.onFocus)) {
            this._zone.run(function () {
                _this.onFocus.emit();
            });
        }
    };
    /**
     * @hidden
     */
    AutoCompleteComponent.prototype.handleBlur = function () {
        var _this = this;
        var focused = this.filterable ? this.selectionService.focused : -1;
        this.searchbar.input.nativeElement.scrollLeft = 0; // Firefox doesn't auto-scroll to the left on blur like other browsers
        var dataItem;
        var text;
        if (focused !== -1) {
            dataItem = this.dataService.itemAt(focused);
            text = getter$1(dataItem, this.valueField) || "";
        }
        else {
            text = this.searchbar.value;
        }
        var exactMatch = text === this.searchbar.value;
        var insensitiveMatch = text.toLowerCase() === this.searchbar.value.toLowerCase();
        if (!exactMatch && insensitiveMatch) {
            this.selectionService.resetSelection([]);
        }
        this.isFocused = false;
        var valueHasChanged = this.value !== this.text;
        var runInZone = hasObservers(this.onBlur) || hasObservers(this.close) || isUntouched(this.wrapper) || valueHasChanged;
        if (runInZone) {
            this._zone.run(function () {
                if (valueHasChanged) {
                    _this.change(_this.searchbar.value);
                }
                _this.onBlur.emit();
                _this.onTouchedCallback();
                _this.togglePopup(false);
            });
        }
        else {
            this.togglePopup(false);
        }
    };
    /**
     * @hidden
     */
    AutoCompleteComponent.prototype.pageChange = function (event) {
        var virtual = this.virtual;
        virtual.skip = event.skip;
    };
    AutoCompleteComponent.prototype.change = function (value) {
        this.togglePopup(false);
        this.valueChangeSubject.next(value);
    };
    AutoCompleteComponent.prototype.subscribeEvents = function () {
        var _this = this;
        if (!isDocumentAvailable()) {
            return;
        }
        this.valueChangeSubscription = this.valueChangeSubject
            .subscribe(function (value) {
            var hasChange = _this.value !== value;
            _this.value = value;
            _this.text = value;
            // emit change after assigning `this.value` => allows the user to modify the component value on `valueChange`
            if (hasChange) {
                _this.emitChange(value);
            }
        });
        this.changeSubscription = this.selectionService.onChange.subscribe(this.handleItemChange.bind(this));
        this.focusSubscription = this.selectionService.onFocus.subscribe(this.handleItemFocus.bind(this));
        this.navigationSubscription = merge(this.navigationService.up, this.navigationService.down).subscribe(function (event) { return _this.navigate(event.index); });
        this.closeSubscription = this.navigationService.close.subscribe(function () { return _this.togglePopup(false); });
        this.enterSubscription = this.navigationService.enter.subscribe(this.handleEnter.bind(this));
        this.escSubscription = this.navigationService.esc.subscribe(this.handleEscape.bind(this));
    };
    AutoCompleteComponent.prototype.subscribeTouchEvents = function () {
        var _this = this;
        if (!isDocumentAvailable() || !this.touchEnabled) {
            return;
        }
        this._zone.runOutsideAngular(function () {
            // Roll up AutoComplete on iOS when tapped outside
            return _this.touchstartDisposeHandler = _this.renderer.listen(document, 'touchstart', function (e) {
                var target = e.target;
                if (_this.isFocused && !inDropDown(_this.hostElement, target, _this.popupRef)) {
                    _this._zone.run(function () { return _this.blur(); });
                }
            });
        });
    };
    AutoCompleteComponent.prototype.unsubscribeEvents = function () {
        if (!isDocumentAvailable()) {
            return;
        }
        this.changeSubscription.unsubscribe();
        this.navigationSubscription.unsubscribe();
        this.closeSubscription.unsubscribe();
        this.enterSubscription.unsubscribe();
        this.escSubscription.unsubscribe();
        this.valueChangeSubscription.unsubscribe();
        this.focusSubscription.unsubscribe();
        if (this.touchstartDisposeHandler) {
            this.touchstartDisposeHandler();
        }
    };
    AutoCompleteComponent.prototype.handleItemChange = function (event) {
        var index = event.indices.length ? event.indices[0] : undefined;
        this.selectionService.resetSelection([-1]);
        if (!isPresent(index)) {
            return;
        }
        var text = getter$1(this.dataService.itemAt(index), this.valueField);
        this.change(text);
    };
    AutoCompleteComponent.prototype.handleItemFocus = function (_event) {
        var focused = this.selectionService.focused;
        var shouldSuggest = Boolean(this.suggest && this.data && this.data.length && focused >= 0);
        if (shouldSuggest) {
            this.suggestedText = getter$1(this.dataService.itemAt(focused), this.valueField);
        }
    };
    AutoCompleteComponent.prototype.createPopup = function () {
        var _this = this;
        if (this.virtual) {
            this.virtual.skip = 0;
        }
        var horizontalAlign = this.direction === "rtl" ? "right" : "left";
        var anchorPosition = { horizontal: horizontalAlign, vertical: "bottom" };
        var popupPosition = { horizontal: horizontalAlign, vertical: "top" };
        this.popupRef = this.popupService.open({
            anchor: this.wrapper,
            animate: this.popupSettings.animate,
            appendTo: this.appendTo,
            content: this.popupTemplate,
            popupClass: this.listContainerClasses,
            positionMode: 'absolute',
            popupAlign: popupPosition,
            anchorAlign: anchorPosition
        });
        var popupWrapper = this.popupRef.popupElement;
        var _a = this.width, min = _a.min, max = _a.max;
        popupWrapper.addEventListener('mousedown', this.popupMouseDownHandler);
        popupWrapper.style.minWidth = min;
        popupWrapper.style.width = max;
        popupWrapper.style.height = this.height;
        popupWrapper.setAttribute("dir", this.direction);
        this.popupRef.popupOpen.subscribe(function () {
            _this.cdr.detectChanges();
            _this.optionsList.scrollToItem(_this.selectionService.focused);
            _this.opened.emit();
        });
        this.popupRef.popupClose.subscribe(function () {
            _this.closed.emit();
        });
        this.popupRef.popupAnchorViewportLeave.subscribe(function () { return _this.togglePopup(false); });
    };
    AutoCompleteComponent.prototype.destroyPopup = function () {
        if (this.popupRef) {
            this.popupRef.popupElement
                .removeEventListener('mousedown', this.popupMouseDownHandler);
            this.popupRef.close();
            this.popupRef = null;
        }
    };
    AutoCompleteComponent.prototype._toggle = function (open) {
        this._open = open;
        this.destroyPopup();
        if (this._open) {
            this.createPopup();
        }
    };
    AutoCompleteComponent.prototype.triggerPopupEvents = function (open) {
        var eventArgs = new PreventableEvent();
        if (open) {
            this.open.emit(eventArgs);
        }
        else {
            this.close.emit(eventArgs);
        }
        return eventArgs.isDefaultPrevented();
    };
    AutoCompleteComponent.prototype.firstFocusableIndex = function (index) {
        var maxIndex = this.data.length - 1;
        if (this.disabledItemsService.isIndexDisabled(index)) {
            return (index < maxIndex) ? this.firstFocusableIndex(index + 1) : undefined;
        }
        else {
            return index;
        }
    };
    AutoCompleteComponent.prototype.findIndexPredicate = function (text) {
        var _this = this;
        if (this.dataService.grouped) {
            return function (item) {
                var itemText = getter$1(item.value, _this.valueField);
                itemText = !isPresent(itemText) ? "" : itemText.toString().toLowerCase();
                return itemText.startsWith(text.toLowerCase());
            };
        }
        else {
            return function (item) {
                var itemText = getter$1(item, _this.valueField);
                itemText = !isPresent(itemText) ? "" : itemText.toString().toLowerCase();
                return itemText.startsWith(text.toLowerCase());
            };
        }
    };
    AutoCompleteComponent.prototype.setMessages = function () {
        var _this = this;
        this._zone.runOutsideAngular(function () {
            clearTimeout(_this.messagesTimeout);
            _this.messagesTimeout = setTimeout(function () {
                _this.noDataText = _this.localization.get('noDataText');
                _this.cdr.detectChanges();
            });
        });
    };
    var AutoCompleteComponent_1;
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AutoCompleteComponent.prototype, "highlightFirst", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AutoCompleteComponent.prototype, "focusableId", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], AutoCompleteComponent.prototype, "data", null);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], AutoCompleteComponent.prototype, "value", null);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AutoCompleteComponent.prototype, "valueField", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AutoCompleteComponent.prototype, "placeholder", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], AutoCompleteComponent.prototype, "popupSettings", null);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AutoCompleteComponent.prototype, "listHeight", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AutoCompleteComponent.prototype, "loading", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AutoCompleteComponent.prototype, "clearButton", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AutoCompleteComponent.prototype, "suggest", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AutoCompleteComponent.prototype, "disabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Function])
    ], AutoCompleteComponent.prototype, "itemDisabled", null);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AutoCompleteComponent.prototype, "readonly", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AutoCompleteComponent.prototype, "tabindex", void 0);
    __decorate([
        Input("tabIndex"),
        __metadata("design:type", Number),
        __metadata("design:paramtypes", [Number])
    ], AutoCompleteComponent.prototype, "tabIndex", null);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AutoCompleteComponent.prototype, "filterable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], AutoCompleteComponent.prototype, "virtual", null);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AutoCompleteComponent.prototype, "valueChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AutoCompleteComponent.prototype, "filterChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AutoCompleteComponent.prototype, "open", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AutoCompleteComponent.prototype, "opened", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AutoCompleteComponent.prototype, "close", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AutoCompleteComponent.prototype, "closed", void 0);
    __decorate([
        Output('focus'),
        __metadata("design:type", EventEmitter)
    ], AutoCompleteComponent.prototype, "onFocus", void 0);
    __decorate([
        Output('blur'),
        __metadata("design:type", EventEmitter)
    ], AutoCompleteComponent.prototype, "onBlur", void 0);
    __decorate([
        ContentChild(ItemTemplateDirective, { static: false }),
        __metadata("design:type", ItemTemplateDirective)
    ], AutoCompleteComponent.prototype, "template", void 0);
    __decorate([
        ContentChild(HeaderTemplateDirective, { static: false }),
        __metadata("design:type", HeaderTemplateDirective)
    ], AutoCompleteComponent.prototype, "headerTemplate", void 0);
    __decorate([
        ContentChild(FooterTemplateDirective, { static: false }),
        __metadata("design:type", FooterTemplateDirective)
    ], AutoCompleteComponent.prototype, "footerTemplate", void 0);
    __decorate([
        ContentChild(NoDataTemplateDirective, { static: false }),
        __metadata("design:type", NoDataTemplateDirective)
    ], AutoCompleteComponent.prototype, "noDataTemplate", void 0);
    __decorate([
        ContentChild(GroupTemplateDirective, { static: false }),
        __metadata("design:type", GroupTemplateDirective)
    ], AutoCompleteComponent.prototype, "groupTemplate", void 0);
    __decorate([
        ContentChild(FixedGroupTemplateDirective, { static: false }),
        __metadata("design:type", FixedGroupTemplateDirective)
    ], AutoCompleteComponent.prototype, "fixedGroupTemplate", void 0);
    __decorate([
        ViewChild('container', { read: ViewContainerRef, static: true }),
        __metadata("design:type", ViewContainerRef)
    ], AutoCompleteComponent.prototype, "container", void 0);
    __decorate([
        ViewChild('popupTemplate', { static: true }),
        __metadata("design:type", TemplateRef)
    ], AutoCompleteComponent.prototype, "popupTemplate", void 0);
    __decorate([
        ViewChild(SearchBarComponent, { static: true }),
        __metadata("design:type", SearchBarComponent)
    ], AutoCompleteComponent.prototype, "searchbar", void 0);
    __decorate([
        ViewChild('optionsList', { static: false }),
        __metadata("design:type", ListComponent)
    ], AutoCompleteComponent.prototype, "optionsList", void 0);
    __decorate([
        HostBinding('class.k-widget'),
        HostBinding('class.k-autocomplete'),
        __metadata("design:type", Boolean)
    ], AutoCompleteComponent.prototype, "widgetClasses", void 0);
    __decorate([
        HostBinding('class.k-state-disabled'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], AutoCompleteComponent.prototype, "isDisabled", null);
    __decorate([
        HostBinding('attr.dir'),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [])
    ], AutoCompleteComponent.prototype, "dir", null);
    AutoCompleteComponent = AutoCompleteComponent_1 = __decorate([
        Component({
            exportAs: 'kendoAutoComplete',
            providers: [
                AUTOCOMPLETE_VALUE_ACCESSOR,
                DataService,
                SelectionService,
                NavigationService,
                DisabledItemsService,
                LocalizationService,
                {
                    provide: L10N_PREFIX,
                    useValue: 'kendo.autocomplete'
                },
                {
                    provide: FilterableComponent,
                    useExisting: forwardRef(function () { return AutoCompleteComponent_1; })
                },
                {
                    provide: KendoInput,
                    useExisting: forwardRef(function () { return AutoCompleteComponent_1; })
                }
            ],
            selector: 'kendo-autocomplete',
            template: "\n        <ng-container kendoAutoCompleteLocalizedMessages\n            i18n-noDataText=\"kendo.autocomplete.noDataText|The text displayed in the popup when there are no items\"\n            noDataText=\"NO DATA FOUND\"\n\n            i18n-clearTitle=\"kendo.autocomplete.clearTitle|The title of the clear button\"\n            clearTitle=\"clear\"\n        >\n        </ng-container>\n        <kendo-searchbar #searchbar\n            [role]=\"'combobox'\"\n            [id]=\"focusableId\"\n            [listId]=\"listBoxId\"\n            [activeDescendant]=\"activeDescendant\"\n            [noDataLabel]=\"noDataLabel\"\n            [userInput]=\"text\"\n            [suggestedText]=\"suggestion\"\n            [disabled]=\"disabled\"\n            [readonly]=\"readonly\"\n            [tabIndex]=\"tabIndex\"\n            [popupOpen]=\"isOpen\"\n            [placeholder]=\"placeholder\"\n            (onNavigate)=\"handleNavigate($event)\"\n            (valueChange)=\"searchBarChange($event)\"\n            (onBlur)=\"handleBlur()\"\n            (onFocus)=\"handleFocus()\"\n        ></kendo-searchbar>\n        <span\n            *ngIf=\"!loading && !readonly && (clearButton && text?.length)\"\n            class=\"k-icon k-clear-value k-i-close\"\n            [style.visibility]=\"clearButtonVisiblity\"\n            [attr.title]=\"clearTitle\"\n            role=\"button\"\n            tabindex=\"-1\"\n            (click)=\"clearValue($event)\"\n            (mousedown)=\"$event.preventDefault()\"\n        >\n</span>\n        <span *ngIf=\"loading\" class=\"k-icon k-i-loading\"></span>\n        <ng-template #popupTemplate>\n            <!--header template-->\n            <ng-template *ngIf=\"headerTemplate\"\n                [templateContext]=\"{\n                    templateRef: headerTemplate.templateRef\n                }\">\n            </ng-template>\n            <!--list-->\n            <kendo-list\n                #optionsList\n                [id]=\"listBoxId\"\n                [optionPrefix]=\"optionPrefix\"\n                [data]=\"data\"\n                [textField]=\"valueField\"\n                [valueField]=\"valueField\"\n                [template]=\"template\"\n                [groupTemplate]=\"groupTemplate\"\n                [fixedGroupTemplate]=\"fixedGroupTemplate\"\n                [height]=\"listHeight\"\n                [show]=\"isOpen\"\n                [virtual]=\"virtual\"\n                (pageChange)=\"pageChange($event)\"\n            >\n            </kendo-list>\n            <!--no-data template-->\n            <div class=\"k-nodata\" *ngIf=\"data.length === 0\">\n                <ng-template [ngIf]=\"noDataTemplate\"\n                    [templateContext]=\"{\n                        templateRef: noDataTemplate?.templateRef\n                    }\">\n                </ng-template>\n                <ng-template [ngIf]=\"!noDataTemplate\">\n                    <div>{{ noDataText }}</div>\n                </ng-template>\n            </div>\n            <!--footer template-->\n            <ng-template *ngIf=\"footerTemplate\"\n                [templateContext]=\"{\n                    templateRef: footerTemplate.templateRef\n                }\">\n            </ng-template>\n        </ng-template>\n        <ng-template [ngIf]=\"isOpen\">\n            <kendo-resize-sensor (resize)=\"onResize()\"></kendo-resize-sensor>\n        </ng-template>\n        <ng-container #container></ng-container>\n  "
        }),
        __param(10, Optional()), __param(10, Inject(TOUCH_ENABLED)),
        __metadata("design:paramtypes", [LocalizationService,
            DataService,
            PopupService,
            SelectionService,
            NavigationService,
            DisabledItemsService,
            NgZone,
            ChangeDetectorRef,
            Renderer2,
            ElementRef, Boolean])
    ], AutoCompleteComponent);
    return AutoCompleteComponent;
}());

/* tslint:disable:variable-name */
/**
 * @hidden
 */
var MultiselectMessages = {
    'array': 'Expected values of array type. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselect/#value-selection',
    'object': 'Expected values of Object type. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselect/#value-selection',
    'primitive': 'Expected values of primitive type. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselect/#value-selection',
    'textAndValue': 'Expected textField and valueField options to be set. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselect/#toc-bind-to-arrays-of-complex-data'
};
/**
 * @hidden
 */
var MultiSelectTreeMessages = {
    'array': 'Expected values of array type. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselecttree/#value-selection',
    'primitive': 'Expected values of primitive type. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselecttree/value-binding/#toc-primitive-values',
    'object': 'Expected values of type Object. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselecttree/value-binding/#toc-object-values',
    'dataItems': 'Expected dataItems of type Object[] to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/api/MultiSelectTreeComponent/#toc-dataitems',
    'dataItemsLength': 'Expected dataItems length to match the number of provided values. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/api/MultiSelectTreeComponent/#toc-dataitems',
    'textAndValue': 'Expected textField and valueField options to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselecttree/value-binding',
    'valueDepth': 'Expected valueDepth of type number[] to be set. See https://www.telerik.com/kendo-angular-ui-develop/components/dropdowns/api/MultiSelectTreeComponent/#toc-valuedepth',
    'valueDepthLength': 'Expected valueDepth length to match the number of provided values. See https://www.telerik.com/kendo-angular-ui-develop/components/dropdowns/api/MultiSelectTreeComponent/#toc-valuedepth'
};
/**
 * @hidden
 */
var ComboBoxMessages = {
    'object': 'Expected value of type Object. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/combobox/#toc-value-selection',
    'primitive': 'Expected value of primitive type. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/combobox/#toc-value-selection',
    'textAndValue': 'Expected textField and valueField options to be set. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/combobox/#toc-bind-to-arrays-of-complex-data',
    'noItemHeight': 'Expected virtual.itemHeight of type number.'
};
/**
 * @hidden
 */
var MultiColumnComboBoxMessages = {
    'data': 'Provided data must consist only of objects. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multicolumncombobox/data-binding/',
    'textAndValue': 'Expected textField and valueField options to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multicolumncombobox/data-binding/#toc-fields-configuration'
};
/**
 * @hidden
 */
var DropDownListMessages = {
    'defaultItem': 'defaultItem and data items must be of same type. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/api/DropDownListComponent/#toc-defaultitem',
    'object': 'Expected value of type Object. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdownlist/#toc-value-selection',
    'primitive': 'Expected value of primitive type. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdownlist/#toc-value-selection',
    'textAndValue': 'Expected textField and valueField options to be set. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdownlist/#toc-bind-to-arrays-of-complex-data'
};
/**
 * @hidden
 */
var DropDownTreeMessages = {
    'primitive': 'Expected value of primitive type. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdowntree/value-binding/#toc-primitive-values',
    'object': 'Expected value of type Object. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdowntree/value-binding/#toc-object-values',
    'dataItem': 'Expected dataItem of type Object to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/api/DropDownTreeComponent/#toc-dataitem',
    'textAndValue': 'Expected textField and valueField options to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdowntree/value-binding',
    'valueDepth': 'Expected valueDepth to be set. See https://www.telerik.com/kendo-angular-ui-develop/components/dropdowns/api/DropDownTreeComponent/#toc-valuedepth'
};

/* tslint:disable:member-ordering */
/**
 * @hidden
 */
var COMBOBOX_VALUE_ACCESSOR = {
    multi: true,
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return ComboBoxComponent; })
};
/**
 * Represents the [Kendo UI ComboBox component for Angular]({% slug overview_combobox %}).
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-combobox [data]="listItems">
 *  </kendo-combobox>
 * `
 * })
 * class AppComponent {
 *   public listItems: Array<string> = ["Item 1", "Item 2", "Item 3", "Item 4"];
 * }
 * ```
 */
var ComboBoxComponent = /** @class */ (function () {
    function ComboBoxComponent(localization, popupService, selectionService, navigationService, disabledItemsService, dataService, zone, cdr, renderer, hostElement, touchEnabled$$1) {
        this.localization = localization;
        this.popupService = popupService;
        this.selectionService = selectionService;
        this.navigationService = navigationService;
        this.disabledItemsService = disabledItemsService;
        this.dataService = dataService;
        this.zone = zone;
        this.cdr = cdr;
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.touchEnabled = touchEnabled$$1;
        this.selected = [];
        /**
         * @hidden
         */
        this.focusableId = "k-" + guid$1();
        /**
         * Specifies whether the ComboBox allows user-defined values that are not present in the dataset
         * ([more information and examples]({% slug custom_values_combobox %})).
         * Defaults to `false`.
         */
        this.allowCustom = false;
        /**
         * A user-defined callback which returns normalized custom values.
         * Typically used when the data items are different from type `string`.
         * @param { Any } value - The custom value defined by the user.
         * @returns { Any }
         *
         * @example
         * ```ts
         * import { map } from 'rxjs/operators';
         *
         * _@Component({
         * selector: 'my-app',
         * template: `
         *   <kendo-combobox
         *       [allowCustom]="true"
         *       [data]="listItems"
         *       textField="text"
         *       valueField="value"
         *       [valueNormalizer]="valueNormalizer"
         *       (valueChange)="onValueChange($event)"
         *   >
         *   </kendo-combobox>
         * `
         * })
         *
         * class AppComponent {
         *   public listItems: Array<{ text: string, value: number }> = [
         *       { text: "Small", value: 1 },
         *       { text: "Medium", value: 2 },
         *       { text: "Large", value: 3 }
         *   ];
         *
         *   public onValueChange(value) {
         *       console.log("valueChange : ", value);
         *   }
         *
         *   public valueNormalizer = (text$: Observable<string>) => text$.pipe(map((text: string) => {
         *      return { ProductID: null, ProductName: text };
         *   }));
         *
         * }
         * ```
         */
        this.valueNormalizer = function (text) {
            return text.pipe(map(function (userInput) { return userInput; }));
        };
        /**
         * The hint that is displayed when the component is empty.
         *
         */
        this.placeholder = "";
        /**
         * Sets the height of the suggestions list. By default, `listHeight` is 200px.
         *
         * > The `listHeight` property affects only the list of suggestions and not the whole popup container.
         * > To set the height of the popup container, use `popupSettings.height`.
         */
        this.listHeight = 200;
        /**
         * Enables the auto-completion of the text based on the first data item.
         */
        this.suggest = false;
        /**
         * If set to `true`, renders a button on hovering over the component.
         * Clicking this button resets the value of the component to `undefined` and triggers the `change` event.
         */
        this.clearButton = true;
        /**
         * Sets the disabled state of the component.
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the component.
         */
        this.readonly = false;
        /**
         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        this.tabindex = 0;
        /**
         * Enables the [filtering]({% slug filtering_combobox %}) functionality.
         * If set to `true`, the component emits the `filterChange` event.
         */
        this.filterable = false;
        /**
         * Fires each time the value is changed&mdash;
         * when the component is blurred or the value is cleared through the **Clear** button
         * ([see example]({% slug overview_combobox %}#toc-events)).
         * When the value of the component is programmatically changed to `ngModel` or `formControl`
         * through its API or form binding, the `valueChange` event is not triggered because it
         * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time an item selection is changed
         * ([see example]({% slug overview_combobox %}#toc-events)).
         */
        this.selectionChange = new EventEmitter();
        /**
         * Fires each time the user types in the input field.
         * You can filter the source based on the passed filtration value
         * ([see example]({% slug overview_combobox %}#toc-events)).
         */
        this.filterChange = new EventEmitter();
        /**
         * Fires each time the popup is about to open.
         * This event is preventable. If you cancel it, the popup will remain closed.
         */
        this.open = new EventEmitter();
        /**
         * Fires after the popup has been opened.
         */
        this.opened = new EventEmitter();
        /**
         * Fires each time the popup is about to close.
         * This event is preventable. If you cancel it, the popup will remain open.
         */
        this.close = new EventEmitter();
        /**
         * Fires after the popup has been closed.
         */
        this.closed = new EventEmitter();
        /**
         * Fires each time the user focuses the ComboBox.
         */
        this.onFocus = new EventEmitter();
        /**
         * Fires each time the ComboBox gets blurred.
         */
        this.onBlur = new EventEmitter();
        this.widgetClasses = true;
        this._isFocused = false;
        this.listBoxId = guid$1();
        this.optionPrefix = guid$1();
        this.onChangeCallback = function (_) { };
        this.onTouchedCallback = function (_) { };
        /**
         * Used for the default virtualization settings config.
         */
        this.defaultVirtualItemHeight = 28;
        /**
         * Used for the default virtualization settings config.
         */
        this.defaultVirtualPageSize = 50;
        this._filtering = false;
        this._text = '';
        this.filterText = '';
        this._open = false;
        this._popupSettings = { animate: true };
        this.popupMouseDownHandler = function (event) { return event.preventDefault(); };
        this.customValueSubject = new Subject();
        this.valueSubject = new Subject();
        this.clearValueSubject = new Subject();
        this.subs = new Subscription();
        validatePackage(packageMetadata);
        this.direction = localization.rtl ? 'rtl' : 'ltr';
        this.data = [];
    }
    ComboBoxComponent_1 = ComboBoxComponent;
    Object.defineProperty(ComboBoxComponent.prototype, "text", {
        get: function () {
            return this._text;
        },
        set: function (text) {
            this._text = isPresent(text) ? text.toString() : "";
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    ComboBoxComponent.prototype.togglePopup = function (open) {
        var isDisabled = this.disabled || this.readonly;
        var sameState = this.isOpen === open;
        if (isDisabled || sameState) {
            return;
        }
        var isDefaultPrevented = this.triggerPopupEvents(open);
        if (!isDefaultPrevented) {
            this._toggle(open);
        }
    };
    Object.defineProperty(ComboBoxComponent.prototype, "activeDescendant", {
        get: function () {
            if (!this.isOpen || !isPresent(this.selectionService.focused) || this.selectionService.focused === -1) {
                return null;
            }
            var dataItem = this.dataService.itemAt(this.selectionService.focused);
            return this.optionPrefix + "-" + (dataItem ? getter$1(dataItem, this.valueField) : "");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComboBoxComponent.prototype, "noDataLabel", {
        get: function () {
            if (this.data.length === 0) {
                return this.noDataText;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComboBoxComponent.prototype, "clearTitle", {
        get: function () {
            return this.localization.get('clearTitle');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComboBoxComponent.prototype, "appendTo", {
        get: function () {
            var appendTo = this.popupSettings.appendTo;
            if (!appendTo || appendTo === 'root') {
                return undefined;
            }
            return appendTo === 'component' ? this.container : appendTo;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComboBoxComponent.prototype, "data", {
        get: function () {
            var virtual = this.virtual;
            if (virtual) {
                var start = virtual.skip || 0;
                var end = start + virtual.pageSize;
                // Use length instead of itemsCount because of the grouping.
                virtual.total = this.dataService.data.length;
                return this.dataService.data.slice(start, end);
            }
            return this.dataService.data;
        },
        /**
         * Sets the data of the ComboBox.
         *
         * > The data has to be provided in an array-like list.
         */
        set: function (data) {
            this.dataService.data = data || [];
            if (this.virtual) {
                this.virtual.skip = 0;
            }
            this.setState();
            if (this._filtering) {
                var queryAndDataPresent = this.text.length > 0 && this.dataService.itemsCount > 0;
                var index = queryAndDataPresent ? this.firstFocusableIndex(0) : -1;
                this.selectionService.focused = index;
            }
            if (this.suggest && this.dataService.itemsCount && this.text) {
                this.suggestedText = getter$1(this.dataService.itemAt(0), this.textField);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComboBoxComponent.prototype, "value", {
        get: function () {
            return this._value;
        },
        /**
         * Sets the value of the ComboBox.
         * It can either be of the primitive (string, numbers) or of the complex (objects) type.
         * To define the type, use the `valuePrimitive` option.
         *
         * > All selected values which are not present in the dataset are considered custom values.
         * > When the `Enter` key is pressed or the component loses focus, custom values get dismissed unless `allowCustom` is set to `true`.
         */
        set: function (newValue) {
            this._value = newValue;
            this.setState();
            this.cdr.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComboBoxComponent.prototype, "valuePrimitive", {
        get: function () {
            if (!isPresent(this._valuePrimitive)) {
                return !isPresent(this.valueField);
            }
            return this._valuePrimitive;
        },
        /**
         * Specifies the type of the selected value.
         * If set to `true`, the selected value has to be of the primitive type
         * ([more information and example]({% slug valuebinding_combobox %}#toc-primitive-values-from-object-fields)).
         */
        set: function (isPrimitive) {
            this._valuePrimitive = isPrimitive;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComboBoxComponent.prototype, "popupSettings", {
        get: function () {
            return this._popupSettings;
        },
        /**
         * Configures the popup of the ComboBox.
         *
         * The available options are:
         * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
         * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped. The `auto` mode is not supported when virtual scrolling is enabled.
         * - `height: Number`&mdash;Sets the height of the popup container.
         * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
         * - `appendTo: "root" | "component" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.
         */
        set: function (settings) {
            this._popupSettings = Object.assign({ animate: true }, settings);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComboBoxComponent.prototype, "itemDisabled", {
        /**
         * Defines a Boolean function that is executed for each data item in the component
         * ([see examples]({% slug disableditems_combobox %})). Determines whether the item will be disabled.
         */
        set: function (fn) {
            if (typeof fn !== 'function') {
                throw new Error("itemDisabled must be a function, but received " + JSON.stringify(fn) + ".");
            }
            this.disabledItemsService.itemDisabled = fn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComboBoxComponent.prototype, "tabIndex", {
        get: function () {
            return this.tabindex;
        },
        /**
         * @hidden
         */
        set: function (tabIndex) {
            this.tabindex = tabIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComboBoxComponent.prototype, "virtual", {
        get: function () {
            return this._virtualSettings;
        },
        /**
         * Enables the [virtualization]({% slug virtualization_combobox %}) functionality.
         */
        set: function (settings) {
            this._virtualSettings = normalizeVirtualizationSettings(settings, {
                itemHeight: this.defaultVirtualItemHeight,
                pageSize: this.defaultVirtualPageSize
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComboBoxComponent.prototype, "clearable", {
        get: function () {
            return this.clearButton;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComboBoxComponent.prototype, "dir", {
        get: function () {
            return this.direction;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComboBoxComponent.prototype, "isFocused", {
        get: function () {
            return this._isFocused;
        },
        set: function (value) {
            this.renderer[value ? 'addClass' : 'removeClass'](this.wrapper.nativeElement, "k-state-focused");
            this._isFocused = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComboBoxComponent.prototype, "clearButtonVisiblity", {
        get: function () {
            if (this.touchEnabled) {
                return 'visible';
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComboBoxComponent.prototype, "popupWidth", {
        get: function () {
            var wrapperOffsetWidth = 0;
            if (isDocumentAvailable()) {
                wrapperOffsetWidth = this.wrapper.nativeElement.offsetWidth;
            }
            var width = this.popupSettings.width || wrapperOffsetWidth;
            var minWidth = isNaN(wrapperOffsetWidth) ? wrapperOffsetWidth : wrapperOffsetWidth + "px";
            var maxWidth = isNaN(width) ? width : width + "px";
            return { min: minWidth, max: maxWidth };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComboBoxComponent.prototype, "popupHeight", {
        get: function () {
            var popupHeight = this.popupSettings.height;
            return isPresent(popupHeight) ? popupHeight + "px" : 'auto';
        },
        enumerable: true,
        configurable: true
    });
    ComboBoxComponent.prototype.ngOnInit = function () {
        this.renderer.removeAttribute(this.hostElement.nativeElement, 'tabindex');
        this.attachStreams();
        this.createValueStream();
        this.subscribeTouchEvents();
        this.attachSelectClickHandler();
        this.setMessages();
    };
    ComboBoxComponent.prototype.createValueStream = function () {
        var _this = this;
        var valueStream = this.valueSubject.pipe(filter(function (candidate) {
            var current = getter$1(_this.value, _this.valueField);
            var newValue = getter$1(candidate, _this.valueField);
            var newText = getter$1(candidate, _this.textField);
            if (!isPresent(_this.value) && !isPresent(newValue)) {
                return false;
            }
            if (isPresent(newText)) {
                newText = newText.toString();
            }
            if (current === newValue && _this.text === newText) {
                _this.clearFilter();
                return false;
            }
            else {
                return true;
            }
        }), map(function (candidate) {
            var newValue = getter$1(candidate, _this.valueField);
            var newText = getter$1(candidate, _this.textField);
            return {
                dataItem: candidate,
                text: newText,
                value: _this.valuePrimitive ? newValue : candidate
            };
        }));
        var customValueStreams = partition(function () { return _this.allowCustom; })(this.customValueSubject.pipe(throttleTime(300)));
        var allowCustomValueStream = customValueStreams[0].pipe(tap(function () {
            _this.loading = true;
            _this.disabled = true;
            _this.cdr.detectChanges();
        }), filter(function () {
            var hasChange = _this.text !== getter$1(_this.value, _this.valueField);
            _this.loading = hasChange;
            _this.disabled = hasChange;
            if (!hasChange) {
                _this.clearFilter();
            }
            return hasChange;
        }), this.valueNormalizer, map(function (normalizedValue) {
            return {
                custom: true,
                dataItem: normalizedValue,
                text: _this.text,
                value: normalizedValue
            };
        }));
        var disableCustomValueStream = customValueStreams[1].pipe(map(function () {
            return {
                custom: true,
                dataItem: undefined,
                text: undefined,
                value: undefined
            };
        }));
        var clearValueStream = this.clearValueSubject.pipe(map(function () { return ({
            dataItem: undefined,
            text: undefined,
            value: undefined
        }); }));
        if (this.valueSubscription) {
            this.valueSubscription.unsubscribe();
        }
        var merged = merge(valueStream, allowCustomValueStream, disableCustomValueStream, clearValueStream);
        this.valueSubscription = merged.pipe(catchError(function () {
            var selectionChanged = getter$1(_this.dataItem, _this.valueField) !== undefined;
            _this.dataItem = undefined;
            _this.value = undefined;
            _this.text = undefined;
            _this.loading = false;
            _this.disabled = false;
            if (selectionChanged) {
                _this.selectionChange.emit(undefined);
            }
            _this.emitValueChange();
            _this.createValueStream();
            return of(null);
        }))
            .subscribe(function (state) {
            var selectionChanged = getter$1(_this.dataItem, _this.valueField) !== getter$1(state.dataItem, _this.valueField);
            _this.dataItem = state.dataItem;
            _this.value = state.value;
            _this.text = state.text;
            _this.loading = false;
            _this.disabled = false;
            _this.clearFilter();
            if (state.custom) {
                _this.selectionService.focused = -1;
            }
            if (selectionChanged) {
                var selectionArgs = state.custom ? undefined : _this.dataItem;
                _this.selectionChange.emit(selectionArgs);
            }
            _this.emitValueChange();
        });
    };
    ComboBoxComponent.prototype.attachStreams = function () {
        var _this = this;
        if (!isDocumentAvailable()) {
            return;
        }
        this.subs.add(this.localization
            .changes.subscribe(function (_a) {
            var rtl = _a.rtl;
            _this.direction = rtl ? 'rtl' : 'ltr';
            _this.setMessages();
        }));
        this.subs.add(merge(this.navigationService.up, this.navigationService.down, this.navigationService.home, this.navigationService.end)
            .pipe(filter(function (event) { return isPresent(event.index); }))
            .subscribe(function (event) { return _this.navigate(event.index); }));
        this.subs.add(this.navigationService.open.subscribe(this.handleNavigationOpen.bind(this)));
        this.subs.add(this.navigationService.close.subscribe(function () { return _this.togglePopup(false); }));
        this.subs.add(this.navigationService.esc.subscribe(this.handleEscape.bind(this)));
        this.subs.add(this.navigationService.enter.pipe(tap(function (event) {
            if (_this.isOpen) {
                event.originalEvent.preventDefault();
            }
        }))
            .subscribe(this.handleEnter.bind(this)));
        this.subs.add(merge(this.selectionService.onChange, this.selectionService.onSelect.pipe(filter(function (_) { return !_this.isOpen; })))
            .pipe(tap(function (_) {
            _this._filtering = false;
            _this.togglePopup(false);
        }), map(function (event) { return _this.dataService.itemAt(event.indices[0]); }))
            .subscribe(function (dataItem) {
            _this.change(dataItem);
        }));
        this.subs.add(this.selectionService.onSelect.pipe(filter(function (_) { return _this.isOpen; }), tap(function (_) { return _this._filtering = false; }), map(function (event) { return _this.dataService.itemAt(event.indices[0]); }))
            .subscribe(function (dataItem) {
            var selectionChanged = getter$1(dataItem, _this.valueField) !== getter$1(_this.dataItem, _this.valueField);
            _this.updateState({ dataItem: dataItem });
            if (selectionChanged) {
                _this.selectionChange.emit(dataItem);
            }
        }));
    };
    ComboBoxComponent.prototype.ngOnDestroy = function () {
        this.destroyPopup();
        clearTimeout(this.messagesTimeout);
        this.subs.unsubscribe();
        if (isPresent(this.valueSubscription)) {
            this.valueSubscription.unsubscribe();
        }
        if (this.touchstartDisposeHandler) {
            this.touchstartDisposeHandler();
        }
        if (this.selectClickDisposeHandler) {
            this.selectClickDisposeHandler();
        }
    };
    ComboBoxComponent.prototype.ngOnChanges = function (changes) {
        var virtual = this.virtual;
        var requestInitialData = virtual && changes.data && changes.data.isFirstChange();
        if (requestInitialData) {
            this.pageChange({ skip: 0, take: virtual.pageSize });
        }
        if (isChanged('valueNormalizer', changes)) {
            this.createValueStream();
        }
        if (anyChanged(['textField', 'valueField', 'valuePrimitive'], changes, false)) {
            this.setState();
        }
    };
    ComboBoxComponent.prototype.ngAfterContentChecked = function () {
        this.verifySettings();
    };
    /**
     * Focuses a specific item of the ComboBox based on a provided index.
     * If null or invalid index is provided the focus will be removed.
     */
    ComboBoxComponent.prototype.focusItemAt = function (index) {
        var isInRange = index >= 0 && index < this.data.length;
        if (isPresent(index) && isInRange && !this.disabledItemsService.isIndexDisabled(index)) {
            this.selectionService.focus(index);
        }
        else {
            this.selectionService.focus(-1);
        }
    };
    /**
     * Focuses the ComboBox.
     */
    ComboBoxComponent.prototype.focus = function () {
        if (!this.disabled) {
            this.searchbar.focus();
        }
    };
    /**
     * Blurs the ComboBox.
     */
    ComboBoxComponent.prototype.blur = function () {
        if (!this.disabled) {
            this.searchbar.blur();
        }
    };
    /**
     * Toggles the visibility of the popup. If you use the `toggle` method to open or close the popup,
     * the `open` and `close` events will not be fired.
     *
     * @param open - The state of the popup.
     */
    ComboBoxComponent.prototype.toggle = function (open) {
        var _this = this;
        Promise.resolve(null).then(function () {
            var shouldOpen = isPresent(open) ? open : !_this._open;
            _this._toggle(shouldOpen);
            _this.cdr.markForCheck();
        });
    };
    Object.defineProperty(ComboBoxComponent.prototype, "isOpen", {
        /**
         * Returns the current open state of the popup.
         */
        get: function () {
            return this._open;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Resets the value of the ComboBox.
     * If you use the `reset` method to clear the value of the component,
     * the model will not update automatically and the `selectionChange` and `valueChange` events will not be fired.
     */
    ComboBoxComponent.prototype.reset = function () {
        this.value = undefined;
        this.clearState();
        this.resetSelection();
    };
    /**
     * @hidden
     *
     * Used by the TextBoxContainer to determine if the floating label
     * should be rendered in the input when the component is not focused.
     */
    ComboBoxComponent.prototype.isEmpty = function () {
        var textEmpty = !isPresent(this.text) || isEmptyString(this.text);
        var valueEmpty = !isPresent(this.value) || isEmptyString(this.value);
        return textEmpty && valueEmpty;
    };
    /**
     * @hidden
     */
    ComboBoxComponent.prototype.clearValue = function (event) {
        event.stopImmediatePropagation();
        this.focus();
        this._filtering = true;
        this._previousDataItem = undefined;
        this.selectionService.resetSelection([]);
        this.clearValueSubject.next();
        this._filtering = false;
    };
    /**
     * @hidden
     */
    ComboBoxComponent.prototype.writeValue = function (value) {
        this.value = value === null ? undefined : value;
    };
    /**
     * @hidden
     */
    ComboBoxComponent.prototype.registerOnChange = function (fn) {
        this.onChangeCallback = fn;
    };
    /**
     * @hidden
     */
    ComboBoxComponent.prototype.registerOnTouched = function (fn) {
        this.onTouchedCallback = fn;
    };
    /**
     * @hidden
     */
    ComboBoxComponent.prototype.setDisabledState = function (isDisabled) {
        this.disabled = isDisabled;
    };
    Object.defineProperty(ComboBoxComponent.prototype, "buttonClasses", {
        /**
         * @hidden
         */
        get: function () {
            return this.loading ? 'k-i-loading' : this.iconClass || 'k-i-arrow-s';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    ComboBoxComponent.prototype.onResize = function () {
        if (this.isOpen) {
            var popupWrapper = this.popupRef.popupElement;
            var _a = this.popupWidth, min = _a.min, max = _a.max;
            popupWrapper.style.minWidth = min;
            popupWrapper.style.width = max;
        }
    };
    ComboBoxComponent.prototype.verifySettings = function () {
        if (!isDevMode()) {
            return;
        }
        if (this.valuePrimitive === true && isPresent(this.value) && typeof this.value === "object") {
            throw new Error(ComboBoxMessages.primitive);
        }
        if (this.valuePrimitive === false && isPresent(this.value) && typeof this.value !== "object") {
            throw new Error(ComboBoxMessages.object);
        }
        var valueOrText = !isPresent(this.valueField) !== !isPresent(this.textField);
        if (valueOrText) {
            throw new Error(ComboBoxMessages.textAndValue);
        }
        if (this.virtual && isNaN(this.virtual.itemHeight)) {
            throw new Error(ComboBoxMessages.noItemHeight);
        }
    };
    ComboBoxComponent.prototype.setState = function () {
        // Filtering in process, do nothing.
        if (this._filtering) {
            return;
        }
        var value = this.value;
        var valueField = this.valueField;
        var resolved = this.findDataItem({ valueField: valueField, value: value });
        if (isPresent(resolved.index) && resolved.index !== -1) {
            this.updateState({ dataItem: resolved.dataItem, confirm: true });
            this.resetSelection(resolved.index);
        }
        else if (isPresent(value) && this.allowCustom) {
            this.updateState({ dataItem: value });
            this.resetSelection(-1);
        }
        else if (this._previousDataItem && this.value) {
            this.updateState({ dataItem: this._previousDataItem });
            this.resetSelection();
        }
        else {
            this.clearState();
            this.resetSelection(-1);
        }
    };
    ComboBoxComponent.prototype.updateState = function (_a) {
        var dataItem = _a.dataItem, _b = _a.confirm, confirm = _b === void 0 ? false : _b;
        this.dataItem = dataItem;
        this.text = getter$1(dataItem, this.textField);
        if (confirm) {
            this._previousDataItem = dataItem;
        }
    };
    ComboBoxComponent.prototype.clearState = function () {
        this.text = undefined;
        this.dataItem = undefined;
    };
    ComboBoxComponent.prototype.resetSelection = function (index) {
        var clear = !isPresent(index) || index < 0;
        this.selectionService.resetSelection(clear ? [] : [index]);
        this.selectionService.focused = index;
    };
    ComboBoxComponent.prototype.firstFocusableIndex = function (index) {
        var maxIndex = this.data.length - 1;
        if (this.disabledItemsService.isIndexDisabled(index)) {
            return (index < maxIndex) ? this.firstFocusableIndex(index + 1) : undefined;
        }
        else {
            return index;
        }
    };
    ComboBoxComponent.prototype.findIndexPredicate = function (text) {
        var _this = this;
        if (this.dataService.grouped) {
            return function (item) {
                var itemText = getter$1(item.value, _this.textField);
                itemText = !isPresent(itemText) ? "" : itemText.toString().toLowerCase();
                return itemText.startsWith(text.toLowerCase());
            };
        }
        else {
            return function (item) {
                var itemText = getter$1(item, _this.textField);
                itemText = !isPresent(itemText) ? "" : itemText.toString().toLowerCase();
                return itemText.startsWith(text.toLowerCase());
            };
        }
    };
    ComboBoxComponent.prototype.findDataItem = function (_a) {
        var _this = this;
        var valueField = _a.valueField, value = _a.value;
        var result = {
            dataItem: null,
            index: -1
        };
        var comparer = function (element) {
            var dataItem = _this.dataService.grouped ? element.value : element;
            return getter$1(dataItem, valueField) === getter$1(value, valueField);
        };
        var index = this.dataService.findIndex(comparer);
        result.dataItem = this.dataService.itemAt(index);
        result.index = index;
        return result;
    };
    ComboBoxComponent.prototype.search = function (text, startFrom) {
        if (startFrom === void 0) { startFrom = 0; }
        var index;
        if (text.length && this.dataService.itemsCount) {
            index = this.dataService.findIndex(this.findIndexPredicate(text), startFrom);
        }
        else {
            index = -1;
        }
        if (this.disabledItemsService.isIndexDisabled(index)) {
            if (index + 1 < this.dataService.itemsCount) {
                this.search(text, index + 1);
            }
            else {
                this.selectionService.focus(-1);
            }
        }
        else {
            this.selectionService.focus(index);
            if (this.suggest) {
                this.suggestedText = getter$1(this.dataService.itemAt(index), this.textField);
            }
        }
    };
    /**
     * @hidden
     */
    ComboBoxComponent.prototype.getSuggestion = function () {
        var hasSelected = !!this.selectionService.selected.length;
        var shouldSuggest = this.suggest && !this.backspacePressed && this.suggestedText && this.text;
        if (!hasSelected && shouldSuggest && this.suggestedText.toLowerCase().startsWith(this.text.toLowerCase())) {
            return this.suggestedText;
        }
        else {
            this.suggestedText = undefined;
        }
    };
    ComboBoxComponent.prototype.navigate = function (index) {
        if (this.dataService.itemsCount === 0) {
            return;
        }
        this.text = getter$1(this.dataService.itemAt(index), this.textField);
        this.selectionService.select(index);
    };
    /**
     * @hidden
     */
    ComboBoxComponent.prototype.handleNavigate = function (event) {
        var hasSelected = isPresent(this.selectionService.selected[0]);
        var focused = isNaN(this.selectionService.focused) ? this.firstFocusableIndex(0) : this.selectionService.focused;
        var offset = 0;
        if (this.disabled || this.readonly) {
            return;
        }
        if (event.keyCode === Keys.Home || event.keyCode === Keys.End) {
            return;
        }
        if (!hasSelected) {
            if (event.keyCode === Keys.ArrowDown) {
                offset = -1;
            }
            else if (event.keyCode === Keys.ArrowUp) {
                offset = 1;
            }
        }
        var action = this.navigationService.process({
            current: offset + focused,
            max: this.dataService.itemsCount - 1,
            min: 0,
            originalEvent: event
        });
        if (action !== NavigationAction.Undefined &&
            action !== NavigationAction.Left &&
            action !== NavigationAction.Right &&
            action !== NavigationAction.Backspace &&
            action !== NavigationAction.Delete &&
            ((action === NavigationAction.Enter && this.isOpen) || action !== NavigationAction.Enter)) {
            event.preventDefault();
        }
    };
    ComboBoxComponent.prototype.handleEnter = function () {
        var text = this.text;
        var focused = this.selectionService.focused;
        var hasFocused = isPresent(focused) && focused !== -1;
        var previousText = getter$1(this._previousDataItem, this.textField) || "";
        var focusedItemText = getter$1(this.dataService.itemAt(focused), this.textField);
        var textHasChanged = text !== previousText;
        this.togglePopup(false);
        this._filtering = false;
        if (this.allowCustom && textHasChanged) {
            if (text === focusedItemText || this.useSuggestion()) {
                this.selectionService.change(focused);
            }
            else {
                this.change(text, true);
            }
        }
        if (!this.allowCustom) {
            if (hasFocused) {
                this.selectionService.change(focused);
            }
            else if (textHasChanged) {
                this.change(text, true);
            }
        }
    };
    /**
     * @hidden
     */
    ComboBoxComponent.prototype.handleBlur = function () {
        var _this = this;
        this._filtering = false;
        this.searchbar.input.nativeElement.scrollLeft = 0; // Firefox doesn't auto-scroll to the left on blur like other browsers
        this.isFocused = false;
        var unresolvedSelection = getter$1(this.dataItem, this.valueField) !== getter$1(this.value, this.valueField);
        var currentText = this.searchbar.value;
        var textHasChanged = currentText !== (getter$1(this.dataItem, this.textField) || '');
        var valueHasChanged = unresolvedSelection || textHasChanged;
        var runInZone = valueHasChanged || hasObservers(this.onBlur) || hasObservers(this.close) || isUntouched(this.hostElement.nativeElement);
        if (runInZone) {
            this.zone.run(function () {
                if (valueHasChanged) {
                    var lowerCaseMatch = isPresent(_this.focusedItemText) && _this.focusedItemText.toLowerCase() === currentText.toLowerCase();
                    if (lowerCaseMatch || unresolvedSelection) {
                        _this.selectionService.change(_this.selectionService.focused);
                    }
                    else {
                        _this.change(currentText, true);
                    }
                }
                _this.onBlur.emit();
                _this.onTouchedCallback();
                _this.togglePopup(false);
            });
        }
        else {
            this.togglePopup(false);
        }
    };
    /**
     * @hidden
     */
    ComboBoxComponent.prototype.handleEscape = function () {
        this.togglePopup(false);
        // clear the focus only if the focused item is not selected
        var hasSelected = this.selectionService.selected.length > 0;
        if (!hasSelected) {
            this.suggestedText = null;
            this.selectionService.focused = -1;
        }
    };
    /**
     * @hidden
     */
    ComboBoxComponent.prototype.handleNavigationOpen = function () {
        this.restoreItemFocus();
        this.togglePopup(true);
    };
    /**
     * @hidden
     */
    ComboBoxComponent.prototype.searchBarChange = function (text) {
        var currentTextLength = this.text ? this.text.length : 0;
        this.backspacePressed = (text.length < currentTextLength) ? true : false;
        this.text = text;
        // Reset the selection prior to filter. If a match is present, it will be resolved. If a match is not present, it is not needed.
        this.selectionService.resetSelection([]);
        this.togglePopup(true);
        this._filtering = true;
        if (this.filterable && this.filterText !== text) {
            this.filterText = text;
            this.filterChange.emit(text);
        }
        else {
            this.search(text);
        }
    };
    /**
     * @hidden
     */
    ComboBoxComponent.prototype.handleFocus = function () {
        var _this = this;
        this.isFocused = true;
        if (hasObservers(this.onFocus)) {
            this.zone.run(function () { return _this.onFocus.emit(); });
        }
    };
    /**
     * @hidden
     */
    ComboBoxComponent.prototype.pageChange = function (event) {
        var virtual = this.virtual;
        virtual.skip = event.skip;
    };
    ComboBoxComponent.prototype.change = function (candidate, isCustom) {
        if (isCustom === void 0) { isCustom = false; }
        if (isCustom) {
            this.customValueSubject.next(candidate);
        }
        else {
            this.valueSubject.next(candidate);
        }
    };
    ComboBoxComponent.prototype.emitValueChange = function () {
        this.onChangeCallback(this.value);
        this.valueChange.emit(this.value);
        this._previousDataItem = this.dataItem;
    };
    /**
     * @hidden
     */
    ComboBoxComponent.prototype.selectClick = function () {
        if (!this.touchEnabled) {
            this.searchbar.focus();
        }
        if (!this.isOpen) {
            this.restoreItemFocus();
        }
        this.togglePopup(!this.isOpen);
    };
    Object.defineProperty(ComboBoxComponent.prototype, "listContainerClasses", {
        get: function () {
            return ['k-list-container', 'k-reset'].concat(this.popupSettings.popupClass || []);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    ComboBoxComponent.prototype.preventEventDefault = function (event) {
        event.preventDefault();
    };
    Object.defineProperty(ComboBoxComponent.prototype, "focusedItemText", {
        get: function () {
            var focused = this.selectionService.focused;
            if (!isPresent(focused) || focused === -1) {
                return null;
            }
            var itemText = getter$1(this.dataService.itemAt(focused), this.textField);
            return !isPresent(itemText) ? "" : itemText.toString();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Focuses the first match when there's text in the input field, but no focused item.
     */
    ComboBoxComponent.prototype.restoreItemFocus = function () {
        var hasFocus = isPresent(this.selectionService.focused) && this.selectionService.focused > -1;
        if (!hasFocus && this.text && this.dataService.itemsCount) {
            if (this.filterable) {
                this.selectionService.focused = this.firstFocusableIndex(0);
            }
            else {
                this.search(this.text);
            }
        }
    };
    ComboBoxComponent.prototype.useSuggestion = function () {
        if (!(this.suggest && isPresent(this.searchbar.value))) {
            return false;
        }
        var focusedDataItem = this.dataService.itemAt(this.selectionService.focused);
        var focusedItemText = getter$1(focusedDataItem, this.textField);
        if (!isPresent(focusedItemText)) {
            return false;
        }
        return this.searchbar.value.toLowerCase() === focusedItemText.toLowerCase();
    };
    ComboBoxComponent.prototype.destroyPopup = function () {
        if (this.popupRef) {
            this.popupRef.popupElement
                .removeEventListener('mousedown', this.popupMouseDownHandler);
            this.popupRef.close();
            this.popupRef = null;
        }
    };
    ComboBoxComponent.prototype.createPopup = function () {
        var _this = this;
        if (this.virtual) {
            this.virtual.skip = 0;
        }
        var horizontalAlign = this.direction === "rtl" ? "right" : "left";
        var anchorPosition = { horizontal: horizontalAlign, vertical: "bottom" };
        var popupPosition = { horizontal: horizontalAlign, vertical: "top" };
        this.popupRef = this.popupService.open({
            anchor: this.wrapper,
            animate: this.popupSettings.animate,
            appendTo: this.appendTo,
            content: this.popupTemplate,
            popupClass: this.listContainerClasses,
            positionMode: 'absolute',
            anchorAlign: anchorPosition,
            popupAlign: popupPosition
        });
        var popupWrapper = this.popupRef.popupElement;
        var _a = this.popupWidth, min = _a.min, max = _a.max;
        popupWrapper.addEventListener('mousedown', this.popupMouseDownHandler);
        popupWrapper.style.minWidth = min;
        popupWrapper.style.width = max;
        popupWrapper.style.height = this.popupHeight;
        popupWrapper.setAttribute("dir", this.direction);
        this.popupRef.popupOpen.subscribe(function () {
            _this.cdr.detectChanges();
            _this.optionsList.scrollToItem(_this.selectionService.focused);
            _this.opened.emit();
        });
        this.popupRef.popupClose.subscribe(function () {
            _this.closed.emit();
        });
        this.popupRef.popupAnchorViewportLeave.subscribe(function () { return _this.togglePopup(false); });
    };
    ComboBoxComponent.prototype._toggle = function (open) {
        this._open = open;
        this.destroyPopup();
        if (this._open) {
            this.createPopup();
        }
    };
    ComboBoxComponent.prototype.triggerPopupEvents = function (open) {
        var eventArgs = new PreventableEvent();
        if (open) {
            this.open.emit(eventArgs);
        }
        else {
            this.close.emit(eventArgs);
        }
        return eventArgs.isDefaultPrevented();
    };
    ComboBoxComponent.prototype.clearFilter = function () {
        if (!(this.filterable && this.filterText)) {
            return;
        }
        this.filterText = '';
        this.filterChange.emit(this.filterText);
    };
    ComboBoxComponent.prototype.setMessages = function () {
        var _this = this;
        this.zone.runOutsideAngular(function () {
            clearTimeout(_this.messagesTimeout);
            _this.messagesTimeout = setTimeout(function () {
                _this.noDataText = _this.localization.get('noDataText');
                _this.cdr.detectChanges();
            });
        });
    };
    ComboBoxComponent.prototype.subscribeTouchEvents = function () {
        var _this = this;
        if (!isDocumentAvailable() || !this.touchEnabled) {
            return;
        }
        this.zone.runOutsideAngular(function () {
            // Roll up ComboBox on iOS when tapped outside
            return _this.touchstartDisposeHandler = _this.renderer.listen(document, 'touchstart', function (e) {
                var target = e.target;
                var isInDropDown = inDropDown(_this.hostElement, target, _this.popupRef);
                if (_this.isFocused && !isInDropDown) {
                    // Close popup and mobile keyboard if searchbar is focused
                    _this.zone.run(function () { return _this.blur(); });
                }
                else if (_this.isOpen && !isInDropDown) {
                    // Close popup if the popup is opened via the select click
                    _this.zone.run(function () { return _this.togglePopup(false); });
                }
            });
        });
    };
    ComboBoxComponent.prototype.attachSelectClickHandler = function () {
        var selectElement = this.select.nativeElement;
        var event = pointers ? 'pointerdown' : 'click';
        this.selectClickDisposeHandler = this.renderer.listen(selectElement, event, this.selectClick.bind(this));
    };
    var ComboBoxComponent_1;
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ComboBoxComponent.prototype, "focusableId", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], ComboBoxComponent.prototype, "allowCustom", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], ComboBoxComponent.prototype, "data", null);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], ComboBoxComponent.prototype, "value", null);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ComboBoxComponent.prototype, "textField", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ComboBoxComponent.prototype, "valueField", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], ComboBoxComponent.prototype, "valuePrimitive", null);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], ComboBoxComponent.prototype, "valueNormalizer", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ComboBoxComponent.prototype, "placeholder", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], ComboBoxComponent.prototype, "popupSettings", null);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], ComboBoxComponent.prototype, "listHeight", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ComboBoxComponent.prototype, "iconClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], ComboBoxComponent.prototype, "loading", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], ComboBoxComponent.prototype, "suggest", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], ComboBoxComponent.prototype, "clearButton", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], ComboBoxComponent.prototype, "disabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Function])
    ], ComboBoxComponent.prototype, "itemDisabled", null);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], ComboBoxComponent.prototype, "readonly", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], ComboBoxComponent.prototype, "tabindex", void 0);
    __decorate([
        Input("tabIndex"),
        __metadata("design:type", Number),
        __metadata("design:paramtypes", [Number])
    ], ComboBoxComponent.prototype, "tabIndex", null);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], ComboBoxComponent.prototype, "filterable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], ComboBoxComponent.prototype, "virtual", null);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], ComboBoxComponent.prototype, "valueChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], ComboBoxComponent.prototype, "selectionChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], ComboBoxComponent.prototype, "filterChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], ComboBoxComponent.prototype, "open", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], ComboBoxComponent.prototype, "opened", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], ComboBoxComponent.prototype, "close", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], ComboBoxComponent.prototype, "closed", void 0);
    __decorate([
        Output('focus'),
        __metadata("design:type", EventEmitter)
    ], ComboBoxComponent.prototype, "onFocus", void 0);
    __decorate([
        Output('blur'),
        __metadata("design:type", EventEmitter)
    ], ComboBoxComponent.prototype, "onBlur", void 0);
    __decorate([
        ContentChild(ItemTemplateDirective, { static: false }),
        __metadata("design:type", ItemTemplateDirective)
    ], ComboBoxComponent.prototype, "template", void 0);
    __decorate([
        ContentChild(HeaderTemplateDirective, { static: false }),
        __metadata("design:type", HeaderTemplateDirective)
    ], ComboBoxComponent.prototype, "headerTemplate", void 0);
    __decorate([
        ContentChild(FooterTemplateDirective, { static: false }),
        __metadata("design:type", FooterTemplateDirective)
    ], ComboBoxComponent.prototype, "footerTemplate", void 0);
    __decorate([
        ContentChild(NoDataTemplateDirective, { static: false }),
        __metadata("design:type", NoDataTemplateDirective)
    ], ComboBoxComponent.prototype, "noDataTemplate", void 0);
    __decorate([
        ContentChild(GroupTemplateDirective, { static: false }),
        __metadata("design:type", GroupTemplateDirective)
    ], ComboBoxComponent.prototype, "groupTemplate", void 0);
    __decorate([
        ContentChild(FixedGroupTemplateDirective, { static: false }),
        __metadata("design:type", FixedGroupTemplateDirective)
    ], ComboBoxComponent.prototype, "fixedGroupTemplate", void 0);
    __decorate([
        ViewChild('container', { read: ViewContainerRef, static: true }),
        __metadata("design:type", ViewContainerRef)
    ], ComboBoxComponent.prototype, "container", void 0);
    __decorate([
        ViewChild('popupTemplate', { static: true }),
        __metadata("design:type", TemplateRef)
    ], ComboBoxComponent.prototype, "popupTemplate", void 0);
    __decorate([
        ViewChild(SearchBarComponent, { static: true }),
        __metadata("design:type", SearchBarComponent)
    ], ComboBoxComponent.prototype, "searchbar", void 0);
    __decorate([
        ViewChild('optionsList', { static: false }),
        __metadata("design:type", ListComponent)
    ], ComboBoxComponent.prototype, "optionsList", void 0);
    __decorate([
        ViewChild('wrapper', { static: true }),
        __metadata("design:type", ElementRef)
    ], ComboBoxComponent.prototype, "wrapper", void 0);
    __decorate([
        ViewChild('select', { static: true }),
        __metadata("design:type", ElementRef)
    ], ComboBoxComponent.prototype, "select", void 0);
    __decorate([
        HostBinding('class.k-widget'),
        HostBinding('class.k-combobox'),
        __metadata("design:type", Boolean)
    ], ComboBoxComponent.prototype, "widgetClasses", void 0);
    __decorate([
        HostBinding('class.k-combobox-clearable'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], ComboBoxComponent.prototype, "clearable", null);
    __decorate([
        HostBinding('attr.dir'),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [])
    ], ComboBoxComponent.prototype, "dir", null);
    ComboBoxComponent = ComboBoxComponent_1 = __decorate([
        Component({
            exportAs: 'kendoComboBox',
            providers: [
                COMBOBOX_VALUE_ACCESSOR,
                DataService,
                SelectionService,
                NavigationService,
                DisabledItemsService,
                LocalizationService,
                {
                    provide: L10N_PREFIX,
                    useValue: 'kendo.combobox'
                },
                {
                    provide: FilterableComponent, useExisting: forwardRef(function () { return ComboBoxComponent_1; })
                },
                {
                    provide: KendoInput, useExisting: forwardRef(function () { return ComboBoxComponent_1; })
                }
            ],
            selector: 'kendo-combobox',
            template: "\n        <ng-container kendoComboBoxLocalizedMessages\n            i18n-noDataText=\"kendo.combobox.noDataText|The text displayed in the popup when there are no items\"\n            noDataText=\"NO DATA FOUND\"\n\n            i18n-clearTitle=\"kendo.combobox.clearTitle|The title of the clear button\"\n            clearTitle=\"clear\"\n        >\n        </ng-container>\n        <span #wrapper unselectable=\"on\"\n            class=\"k-dropdown-wrap\"\n            [ngClass]=\"{'k-state-disabled': disabled }\"\n        >\n          <kendo-searchbar #searchbar\n              [role]=\"'combobox'\"\n              [id]=\"focusableId\"\n              [listId]=\"listBoxId\"\n              [activeDescendant]=\"activeDescendant\"\n              [noDataLabel]=\"noDataLabel\"\n              [userInput]=\"text\"\n              [suggestedText]=\"getSuggestion()\"\n              [disabled]=\"disabled\"\n              [readonly]=\"readonly\"\n              [tabIndex]=\"tabIndex\"\n              [popupOpen]=\"isOpen\"\n              [placeholder]=\"placeholder\"\n              (onNavigate)=\"handleNavigate($event)\"\n              (valueChange)=\"searchBarChange($event)\"\n              (onBlur)=\"handleBlur()\"\n              (onFocus)=\"handleFocus()\"\n          ></kendo-searchbar>\n          <span\n              *ngIf=\"clearButton && !loading && !disabled && !readonly && text?.length\"\n              class=\"k-icon k-clear-value k-i-close\"\n              [style.visibility]=\"clearButtonVisiblity\"\n              aria-hidden=\"true\"\n              [attr.title]=\"clearTitle\"\n              (click)=\"clearValue($event)\"\n              [kendoEventsOutsideAngular]=\"{\n                    mousedown: preventEventDefault\n              }\"\n          >\n          </span>\n          <span\n              #select\n              aria-hidden=\"true\"\n              unselectable=\"on\"\n              class=\"k-select\"\n              [kendoEventsOutsideAngular]=\"{\n                  mousedown: preventEventDefault\n              }\"\n          >\n              <span class=\"k-icon\" [ngClass]=\"buttonClasses\">\n               </span>\n          </span>\n          <ng-template #popupTemplate>\n              <!--header template-->\n              <ng-template *ngIf=\"headerTemplate\"\n                  [templateContext]=\"{\n                      templateRef: headerTemplate.templateRef\n                  }\">\n              </ng-template>\n              <!--list-->\n              <kendo-list\n                  #optionsList\n                  [id]=\"listBoxId\"\n                  [optionPrefix]=\"optionPrefix\"\n                  [data]=\"data\"\n                  [textField]=\"textField\"\n                  [valueField]=\"valueField\"\n                  [template]=\"template\"\n                  [groupTemplate]=\"groupTemplate\"\n                  [fixedGroupTemplate]=\"fixedGroupTemplate\"\n                  [height]=\"listHeight\"\n                  [show]=\"isOpen\"\n                  [virtual]=\"virtual\"\n                  (pageChange)=\"pageChange($event)\"\n              >\n              </kendo-list>\n              <!--no-data template-->\n              <div class=\"k-nodata\" *ngIf=\"data.length === 0\">\n                  <ng-template [ngIf]=\"noDataTemplate\"\n                      [templateContext]=\"{\n                          templateRef: noDataTemplate ? noDataTemplate.templateRef : undefined\n                      }\">\n                  </ng-template>\n                  <ng-template [ngIf]=\"!noDataTemplate\">\n                      <div>{{ noDataText }}</div>\n                  </ng-template>\n              </div>\n              <!--footer template-->\n              <ng-template *ngIf=\"footerTemplate\"\n                  [templateContext]=\"{\n                      templateRef: footerTemplate.templateRef\n                  }\">\n              </ng-template>\n          </ng-template>\n        </span>\n        <ng-template [ngIf]=\"isOpen\">\n            <kendo-resize-sensor (resize)=\"onResize()\"></kendo-resize-sensor>\n        </ng-template>\n        <ng-container #container></ng-container>\n  "
        }),
        __param(10, Optional()), __param(10, Inject(TOUCH_ENABLED)),
        __metadata("design:paramtypes", [LocalizationService,
            PopupService,
            SelectionService,
            NavigationService,
            DisabledItemsService,
            DataService,
            NgZone,
            ChangeDetectorRef,
            Renderer2,
            ElementRef, Boolean])
    ], ComboBoxComponent);
    return ComboBoxComponent;
}());

/**
 * Renders the selected value of the dropdown. To define the header template, nest an `<ng-template>` tag
 * with the `kendo<ComponentName>ValueTemplate` directive inside the component tag.
 *
 * The template context is set to the current component.
 * To get a reference to the current data item, use the `let-dataItem` directive.
 *
 * > The `ValueTemplate` directive can only be used with the DropDownList and DropDownTree components.
 *
 * - [Using `ValueTemplate` with the DropDownList]({% slug templates_ddl %}#toc-value-template)
 * - [Using `ValueTemplate` with the DropDownTree]({% slug templates_ddt %}#toc-value-template)
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-dropdownlist [data]="listItems">
 *    <ng-template kendoDropDownListValueTemplate let-dataItem>
 *      <span>{{dataItem}} option</span>
 *    </ng-template>
 *  </kendo-dropdownlist>
 * `
 * })
 * class AppComponent {
 *   public listItems: Array<string> = ["Item 1", "Item 2", "Item 3", "Item 4"];
 * }
 * ```
 */
var ValueTemplateDirective = /** @class */ (function () {
    function ValueTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    ValueTemplateDirective = __decorate([
        Directive({
            selector: '[kendoDropDownListValueTemplate],[kendoDropDownTreeValueTemplate]'
        }),
        __metadata("design:paramtypes", [TemplateRef])
    ], ValueTemplateDirective);
    return ValueTemplateDirective;
}());

/* tslint:disable:member-ordering */
/**
 * @hidden
 */
var DROPDOWNLIST_VALUE_ACCESSOR = {
    multi: true,
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return DropDownListComponent; })
};
/**
 * Represents the [Kendo UI DropDownList component for Angular]({% slug overview_ddl %}).
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-dropdownlist [data]="listItems">
 *  </kendo-dropdownlist>
 * `
 * })
 * class AppComponent {
 *   public listItems: Array<string> = ["Item 1", "Item 2", "Item 3", "Item 4"];
 * }
 * ```
 */
var DropDownListComponent = /** @class */ (function () {
    function DropDownListComponent(localization, popupService, selectionService, navigationService, disabledItemsService, dataService, _zone, renderer, hostElement, cdr, touchEnabled$$1) {
        this.localization = localization;
        this.popupService = popupService;
        this.selectionService = selectionService;
        this.navigationService = navigationService;
        this.disabledItemsService = disabledItemsService;
        this.dataService = dataService;
        this._zone = _zone;
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.cdr = cdr;
        this.touchEnabled = touchEnabled$$1;
        /**
         * @hidden
         */
        this.focusableId = "k-" + guid$1();
        /**
         * Sets the height of the options list. By default, `listHeight` is 200px.
         *
         * > The `listHeight` property affects only the list of options and not the whole popup container.
         * > To set the height of the popup container, use `popupSettings.height`.
         */
        this.listHeight = 200;
        /**
         * Sets the disabled state of the component.
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the component.
         */
        this.readonly = false;
        /**
         * Enables the [filtering]({% slug filtering_ddl %}) functionality of the DropDownList.
         */
        this.filterable = false;
        /**
         * Enables a case-insensitive search. When filtration is disabled, use this option.
         */
        this.ignoreCase = true;
        /**
         * Sets the delay before an item search is performed. When filtration is disabled, use this option.
         */
        this.delay = 500;
        /**
         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        this.tabindex = 0;
        /**
         * Fires each time the value is changed ([see example]({% slug overview_ddl %}#toc-events)).
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time the user types in the input field
         * ([see example]({% slug overview_ddl %}#toc-events)).
         * You can filter the source based on the passed filtration value.
         * When the value of the component is programmatically changed to `ngModel` or `formControl`
         * through its API or form binding, the `valueChange` event is not triggered because it
         * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.
         */
        this.filterChange = new EventEmitter();
        /**
         * Fires each time the item selection is changed
         * ([see example]({% slug overview_ddl %}#toc-events)).
         */
        this.selectionChange = new EventEmitter();
        /**
         * Fires each time the popup is about to open
         * ([see example]({% slug openstate_ddl %}#toc-preventing-opening-and-closing)).
         * This event is preventable. If you cancel it, the popup will remain closed.
         */
        this.open = new EventEmitter();
        /**
         * Fires after the popup has been opened.
         */
        this.opened = new EventEmitter();
        /**
         * Fires each time the popup is about to close
         * ([see example]({% slug openstate_ddl %}#toc-preventing-opening-and-closing)).
         * This event is preventable. If you cancel it, the popup will remain open.
         */
        this.close = new EventEmitter();
        /**
         * Fires after the popup has been closed.
         */
        this.closed = new EventEmitter();
        /**
         * Fires each time the user focuses the DropDownList.
         */
        this.onFocus = new EventEmitter();
        /**
         * Fires each time the DropDownList gets blurred.
         */
        this.onBlur = new EventEmitter();
        this.widgetClasses = true;
        this.groupIndices = [];
        this.listBoxId = guid$1();
        this.optionPrefix = guid$1();
        this.filterText = "";
        this._isFocused = false;
        this.onTouchedCallback = function (_) { };
        this.onChangeCallback = function (_) { };
        this.word = "";
        this.last = "";
        this.filterFocused = new EventEmitter();
        this.filterBlurred = new EventEmitter();
        this.wrapperFocused = new EventEmitter();
        this.wrapperBlurred = new EventEmitter();
        this.selectionSubscription = new Subscription();
        this._open = false;
        this._popupSettings = { animate: true };
        validatePackage(packageMetadata);
        this.direction = localization.rtl ? 'rtl' : 'ltr';
        this.data = [];
        this.subscribeEvents();
        this.subscribeTouchEvents();
        this.popupMouseDownHandler = this.onMouseDown.bind(this);
    }
    DropDownListComponent_1 = DropDownListComponent;
    Object.defineProperty(DropDownListComponent.prototype, "width", {
        get: function () {
            var wrapperWidth = isDocumentAvailable() ? this.wrapper.nativeElement.offsetWidth : 0;
            var width = this.popupSettings.width || wrapperWidth;
            var minWidth = isNaN(wrapperWidth) ? wrapperWidth : wrapperWidth + "px";
            var maxWidth = isNaN(width) ? width : width + "px";
            return { min: minWidth, max: maxWidth };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownListComponent.prototype, "height", {
        get: function () {
            var popupHeight = this.popupSettings.height;
            return isPresent(popupHeight) ? popupHeight + "px" : 'auto';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownListComponent.prototype, "widgetTabIndex", {
        get: function () {
            if (this.disabled) {
                return undefined;
            }
            var providedTabIndex = Number(this.tabIndex);
            var defaultTabIndex = 0;
            return !isNaN(providedTabIndex) ? providedTabIndex : defaultTabIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownListComponent.prototype, "ariaExpanded", {
        get: function () {
            return this.isOpen;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownListComponent.prototype, "ariaOwns", {
        get: function () {
            if (!this.isOpen) {
                return;
            }
            return this.listBoxId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownListComponent.prototype, "ariaActivedescendant", {
        get: function () {
            if (!isPresent(this.dataItem)) {
                return;
            }
            return this.optionPrefix + "-" + getter$1(this.dataItem, this.valueField);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownListComponent.prototype, "noDataLabel", {
        get: function () {
            if (this.dataService.itemsCount === 0) {
                return this.noDataText;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownListComponent.prototype, "appendTo", {
        get: function () {
            var appendTo = this.popupSettings.appendTo;
            if (!appendTo || appendTo === 'root') {
                return undefined;
            }
            return appendTo === 'component' ? this.container : appendTo;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownListComponent.prototype, "data", {
        get: function () {
            var virtual = this.virtual;
            if (virtual) {
                var start = virtual.skip || 0;
                var end = start + virtual.pageSize;
                // Use length instead of itemsCount because of the grouping.
                virtual.total = this.dataService.data.length;
                return this.dataService.data.slice(start, end);
            }
            return this.dataService.data;
        },
        /**
         * Sets the data of the DropDownList.
         *
         * > The data has to be provided in an array-like list.
         */
        set: function (data) {
            this.dataService.data = data || [];
            if (this.virtual) {
                this.virtual.skip = 0;
            }
            this.setState();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownListComponent.prototype, "value", {
        get: function () {
            return this._value;
        },
        /**
         * Sets the value of the DropDownList.
         * It can either be of the primitive (string, numbers) or of the complex (objects) type.
         * To define the type, use the `valuePrimitive` option.
         *
         * > All selected values which are not present in the source are ignored.
         */
        set: function (newValue) {
            if (!isPresent(newValue)) {
                this._previousDataItem = undefined;
            }
            this._value = newValue;
            this.setState();
            this.cdr.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownListComponent.prototype, "popupSettings", {
        get: function () {
            return this._popupSettings;
        },
        /**
         * Configures the popup of the DropDownList.
         *
         * The available options are:
         * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
         * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped. The `auto` mode is not supported when virtual scrolling is enabled.
         * - `height: Number`&mdash;Sets the height of the popup container.
         * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
         * - `appendTo: "root" | "component" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.
         */
        set: function (settings) {
            this._popupSettings = Object.assign({ animate: true }, settings);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownListComponent.prototype, "itemDisabled", {
        /**
         * Defines a Boolean function that is executed for each data item in the component
         * ([see examples]({% slug disableditems_ddl %})). Determines whether the item will be disabled.
         */
        set: function (fn) {
            if (typeof fn !== 'function') {
                throw new Error("itemDisabled must be a function, but received " + JSON.stringify(fn) + ".");
            }
            this.disabledItemsService.itemDisabled = fn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownListComponent.prototype, "virtual", {
        get: function () {
            return this._virtualSettings;
        },
        /**
         * Enables the [virtualization]({% slug virtualization_ddl %}) functionality.
         */
        set: function (settings) {
            this._virtualSettings = normalizeVirtualizationSettings(settings);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownListComponent.prototype, "valuePrimitive", {
        get: function () {
            if (!isPresent(this._valuePrimitive)) {
                return !isPresent(this.valueField);
            }
            return this._valuePrimitive;
        },
        /**
         * Specifies the type of the selected value
         * ([more information and example]({% slug valuebinding_ddl %}#toc-primitive-values-from-object-fields)).
         * If set to `true`, the selected value has to be of a primitive value.
         */
        set: function (isPrimitive) {
            this._valuePrimitive = isPrimitive;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownListComponent.prototype, "tabIndex", {
        get: function () {
            return this.tabindex;
        },
        /**
         * @hidden
         */
        set: function (tabIndex) {
            this.tabindex = tabIndex;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    DropDownListComponent.prototype.blurComponent = function () {
        this.wrapperBlurred.emit();
    };
    /**
     * @hidden
     */
    DropDownListComponent.prototype.blurFilterInput = function () {
        this.filterBlurred.emit();
    };
    /**
     * @hidden
     */
    DropDownListComponent.prototype.focusComponent = function () {
        var _this = this;
        this.wrapperFocused.emit();
        if (!this.isFocused) {
            this.isFocused = true;
            if (hasObservers(this.onFocus)) {
                this._zone.run(function () {
                    _this.onFocus.emit();
                });
            }
        }
    };
    /**
     * @hidden
     */
    DropDownListComponent.prototype.keydown = function (event) {
        var firstIndex = isPresent(this.defaultItem) ? -1 : 0;
        var focused = isNaN(this.selectionService.focused) ? this.firstFocusableIndex(firstIndex) : this.selectionService.focused;
        var offset = 0;
        if (this.disabled || this.readonly) {
            return;
        }
        var isHomeEnd = event.keyCode === Keys.Home || event.keyCode === Keys.End;
        var isFilterFocused = this.filterable && this.isFocused && this.isOpen;
        if (isFilterFocused && isHomeEnd) {
            return;
        }
        var hasSelected = isPresent(this.selectionService.selected[0]);
        var focusedItemNotSelected = isPresent(this.selectionService.focused) && !this.selectionService.isSelected(this.selectionService.focused);
        if (!hasSelected || focusedItemNotSelected) {
            if (event.keyCode === Keys.ArrowDown || event.keyCode === Keys.ArrowRight) {
                offset = -1;
            }
            else if (event.keyCode === Keys.ArrowUp || event.keyCode === Keys.ArrowLeft) {
                offset = 1;
            }
        }
        var eventData = event;
        var action = this.navigationService.process({
            current: focused + offset,
            max: this.dataService.itemsCount - 1,
            min: this.defaultItem ? -1 : 0,
            originalEvent: eventData
        });
        var leftRightKeys = (action === NavigationAction.Left) || (action === NavigationAction.Right);
        if (action !== NavigationAction.Undefined &&
            action !== NavigationAction.Tab &&
            action !== NavigationAction.Backspace &&
            action !== NavigationAction.Delete &&
            !(leftRightKeys && this.filterable) &&
            action !== NavigationAction.Enter //enter when popup is opened is handled before `handleEnter`
        ) {
            eventData.preventDefault();
        }
    };
    /**
     * @hidden
     */
    DropDownListComponent.prototype.keypress = function (event) {
        if (this.disabled || this.readonly || this.filterable) {
            return;
        }
        this.onKeyPress(event);
    };
    /**
     * @hidden
     */
    DropDownListComponent.prototype.click = function (event) {
        event.preventDefault();
        this.focus();
        this.togglePopup(!this.isOpen);
    };
    /**
     * @hidden
     */
    DropDownListComponent.prototype.onResize = function () {
        if (this._open) {
            var popupWrapper = this.popupRef.popupElement;
            var _a = this.width, min = _a.min, max = _a.max;
            popupWrapper.style.minWidth = min;
            popupWrapper.style.width = max;
        }
    };
    Object.defineProperty(DropDownListComponent.prototype, "dir", {
        get: function () {
            return this.direction;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownListComponent.prototype, "isFocused", {
        get: function () {
            return this._isFocused;
        },
        set: function (isFocused) {
            this.renderer[isFocused ? 'addClass' : 'removeClass'](this.wrapper.nativeElement, 'k-state-focused');
            this._isFocused = isFocused;
        },
        enumerable: true,
        configurable: true
    });
    DropDownListComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.renderer.removeAttribute(this.hostElement.nativeElement, "tabindex");
        this.localizationChangesSubscription = this.localization
            .changes.subscribe(function (_a) {
            var rtl = _a.rtl;
            _this.direction = rtl ? 'rtl' : 'ltr';
            _this.setMessages();
        });
        this.setMessages();
        this.assignAriaDescribedBy();
    };
    /**
     * @hidden
     * Used by the TextBoxContainer to determine if the component is empty.
     */
    DropDownListComponent.prototype.isEmpty = function () {
        var value = this.value;
        return !(value === 0 || value === false || value || this.defaultItem);
    };
    /**
     * @hidden
     */
    DropDownListComponent.prototype.onFilterFocus = function () {
        this.filterFocused.emit();
    };
    /**
     * @hidden
     */
    DropDownListComponent.prototype.ngOnDestroy = function () {
        this.destroyPopup();
        this.unsubscribeEvents();
        clearTimeout(this.messagesTimeout);
        if (this.localizationChangesSubscription) {
            this.localizationChangesSubscription.unsubscribe();
        }
    };
    /**
     * @hidden
     */
    DropDownListComponent.prototype.ngOnChanges = function (changes) {
        var virtual = this.virtual;
        var requestInitialData = virtual && changes.data && changes.data.isFirstChange();
        if (requestInitialData) {
            this.pageChange({ skip: 0, take: virtual.pageSize });
        }
        if (isChanged('defaultItem', changes, false)) {
            this.disabledItemsService.defaultItem = this.defaultItem;
        }
        if (anyChanged(['textField', 'valueField', 'valuePrimitive', 'defaultItem', 'itemDisabled'], changes, false)) {
            this.setState();
        }
    };
    /**
     * @hidden
     */
    DropDownListComponent.prototype.ngAfterContentChecked = function () {
        this.verifySettings();
    };
    /**
     * Focuses a specific item of the DropDownList based on a provided index.
     * If there is a default item it is positioned at index -1.
     * If null or invalid index is provided the focus will be removed.
     */
    DropDownListComponent.prototype.focusItemAt = function (index) {
        var minIndex = isPresent(this.defaultItem) ? -1 : 0;
        var isInRange = minIndex <= index && index < this.data.length;
        if (isPresent(index) && isInRange && !this.disabledItemsService.isIndexDisabled(index)) {
            this.selectionService.focus(index);
        }
        else {
            this.selectionService.focus(null);
        }
    };
    /**
     * Focuses the DropDownList.
     */
    DropDownListComponent.prototype.focus = function () {
        if (!this.disabled) {
            this.wrapper.nativeElement.focus();
        }
    };
    /**
     * Blurs the DropDownList.
     */
    DropDownListComponent.prototype.blur = function () {
        if (!this.disabled) {
            this.wrapper.nativeElement.blur();
        }
    };
    /**
     * Toggles the visibility of the popup
     * ([see example]({% slug openstate_ddl %}#toc-setting-the-initially-opened-component)).
     * If you use the `toggle` method to open or close the popup, the `open` and `close` events will not be fired.
     *
     * @param open - The state of the popup.
     */
    DropDownListComponent.prototype.toggle = function (open) {
        var _this = this;
        // The Promise is required to open the popup on load.
        // Otherwise, the "Expression has changed..." type error will be thrown.
        Promise.resolve(null).then(function () {
            var shouldOpen = isPresent(open) ? open : !_this._open;
            _this._toggle(shouldOpen);
        });
    };
    DropDownListComponent.prototype._toggle = function (open) {
        this._open = open;
        this.destroyPopup();
        if (this._open) {
            this.createPopup();
        }
    };
    DropDownListComponent.prototype.triggerPopupEvents = function (open) {
        var eventArgs = new PreventableEvent();
        if (open) {
            this.open.emit(eventArgs);
        }
        else {
            this.close.emit(eventArgs);
        }
        return eventArgs.isDefaultPrevented();
    };
    /**
     * @hidden
     */
    DropDownListComponent.prototype.togglePopup = function (open) {
        var isDisabled = this.disabled || this.readonly;
        var sameState = this.isOpen === open;
        if (isDisabled || sameState) {
            return;
        }
        var isDefaultPrevented = this.triggerPopupEvents(open);
        if (!isDefaultPrevented) {
            if (!open && this.filterable && this.isFocused) {
                this.focus();
            }
            this._toggle(open);
        }
    };
    Object.defineProperty(DropDownListComponent.prototype, "isOpen", {
        /**
         * Returns the current open state of the popup.
         */
        get: function () {
            return this._open;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Resets the value of the DropDownList.
     * If you use the `reset` method to clear the value of the component,
     * the model will not update automatically and the `selectionChange` and `valueChange` events will not be fired.
     */
    DropDownListComponent.prototype.reset = function () {
        this.value = undefined;
    };
    /**
     * @hidden
     */
    DropDownListComponent.prototype.writeValue = function (value) {
        this.value = value === null ? undefined : value;
    };
    /**
     * @hidden
     */
    DropDownListComponent.prototype.registerOnChange = function (fn) {
        this.onChangeCallback = fn;
    };
    /**
     * @hidden
     */
    DropDownListComponent.prototype.registerOnTouched = function (fn) {
        this.onTouchedCallback = fn;
    };
    /**
     * @hidden
     */
    DropDownListComponent.prototype.setDisabledState = function (isDisabled) {
        this.disabled = isDisabled;
    };
    Object.defineProperty(DropDownListComponent.prototype, "buttonClasses", {
        /**
         * @hidden
         */
        get: function () {
            return this.loading ? 'k-i-loading' : this.iconClass || 'k-i-arrow-s';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownListComponent.prototype, "listContainerClasses", {
        /**
         * @hidden
         */
        get: function () {
            var containerClasses = ['k-list-container', 'k-reset'];
            if (this.popupSettings.popupClass) {
                containerClasses.push(this.popupSettings.popupClass);
            }
            return containerClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownListComponent.prototype, "isDisabledDefaultItem", {
        /**
         * @hidden
         */
        get: function () {
            return this.disabledItemsService.isItemDisabled(this.defaultItem);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    DropDownListComponent.prototype.getText = function () {
        return this.text;
    };
    /**
     * @hidden
     */
    DropDownListComponent.prototype.getDefaultItemText = function () {
        return getter$1(this.defaultItem, this.textField);
    };
    DropDownListComponent.prototype.createPopup = function () {
        var _this = this;
        if (this.virtual) {
            this.virtual.skip = 0;
        }
        var horizontalAlign = this.direction === "rtl" ? "right" : "left";
        var anchorPosition = { horizontal: horizontalAlign, vertical: "bottom" };
        var popupPosition = { horizontal: horizontalAlign, vertical: "top" };
        this.popupRef = this.popupService.open({
            anchor: this.wrapper,
            anchorAlign: anchorPosition,
            animate: this.popupSettings.animate,
            appendTo: this.appendTo,
            content: this.popupTemplate,
            popupAlign: popupPosition,
            popupClass: this.listContainerClasses,
            positionMode: 'absolute'
        });
        var popupWrapper = this.popupRef.popupElement;
        var _a = this.width, min = _a.min, max = _a.max;
        popupWrapper.addEventListener('mousedown', this.popupMouseDownHandler);
        popupWrapper.style.minWidth = min;
        popupWrapper.style.width = max;
        popupWrapper.style.height = this.height;
        popupWrapper.setAttribute("dir", this.direction);
        this.popupRef.popupOpen.subscribe(function () {
            _this.cdr.detectChanges();
            _this.optionsList.scrollToItem(_this.selectionService.focused);
            _this.opened.emit();
        });
        this.popupRef.popupClose.subscribe(function () {
            _this.closed.emit();
        });
        if (!this.filterable) {
            this.popupRef.popupAnchorViewportLeave.subscribe(function () { return _this.togglePopup(false); });
        }
    };
    DropDownListComponent.prototype.destroyPopup = function () {
        if (this.popupRef) {
            this.popupRef.popupElement
                .removeEventListener('mousedown', this.popupMouseDownHandler);
            this.popupRef.close();
            this.popupRef = null;
        }
    };
    DropDownListComponent.prototype.updateState = function (_a) {
        var dataItem = _a.dataItem, _b = _a.confirm, confirm = _b === void 0 ? false : _b;
        this.dataItem = dataItem;
        this.text = getter$1(dataItem, this.textField);
        if (confirm) {
            this._previousDataItem = dataItem;
        }
    };
    DropDownListComponent.prototype.clearState = function () {
        this.text = undefined;
        this.dataItem = undefined;
    };
    DropDownListComponent.prototype.resetSelection = function (index) {
        var clear = !isPresent(index);
        this.selectionService.resetSelection(clear ? [] : [index]);
        this.selectionService.focused = clear ? this.firstFocusableIndex(0) : index;
    };
    DropDownListComponent.prototype.onSelectionChange = function (_a) {
        var dataItem = _a.dataItem;
        this.updateState({ dataItem: dataItem });
        this.selectionChange.emit(dataItem);
        // reassigning the value label ID as aria-deascibedby forces firefox/nvda, forefox/jaws to read
        // the new value when the popup is closed and the value is changed with the arrow keys (up/down)
        this.assignAriaDescribedBy();
    };
    DropDownListComponent.prototype.subscribeEvents = function () {
        var _this = this;
        if (!isDocumentAvailable()) {
            return;
        }
        // Item selection when the popup is open.
        this.selectionSubscription.add(this.selectionService.onSelect.pipe(filter(function (_) { return _this.isOpen; }), map(this.itemFromEvent.bind(this)))
            .subscribe(this.onSelectionChange.bind(this)));
        // Item selection when the popup is closed | clicked | enter, and so on.
        this.selectionSubscription.add(merge(this.selectionService.onSelect.pipe(filter(function (_) { return !_this.isOpen; })), this.selectionService.onChange).pipe(map(this.itemFromEvent.bind(this)), tap(function (_) { return _this.togglePopup(false); }))
            .subscribe(function (_a) {
            var dataItem = _a.dataItem, newValue = _a.value, newSelection = _a.newSelection;
            if (newSelection) {
                _this.onSelectionChange({ dataItem: dataItem });
            }
            var shouldUsePrevious = !isPresent(dataItem) && _this._previousDataItem;
            var shouldUseNewValue = newValue !== getter$1(_this.value, _this.valueField);
            if (shouldUsePrevious) {
                _this.updateState({ dataItem: _this._previousDataItem });
                _this.resetSelection();
            }
            else if (shouldUseNewValue) {
                _this.value = _this.valuePrimitive ? newValue : dataItem;
                _this._previousDataItem = dataItem;
                _this.emitChange(_this.value);
            }
            _this.clearFilter();
        }));
        this.navigationSubscription = merge(this.navigationService.up, this.navigationService.down, this.navigationService.left.pipe(skipWhile(function () { return _this.filterable; })), this.navigationService.right.pipe(skipWhile(function () { return _this.filterable; })), this.navigationService.home, this.navigationService.end)
            .pipe(filter(function (event) { return !isNaN(event.index); }))
            .subscribe(function (event) { return _this.selectionService.select(event.index); });
        this.openSubscription = this.navigationService.open.subscribe(function () { return _this.togglePopup(true); });
        this.closeSubscription = this.navigationService.close.subscribe(function () {
            _this.togglePopup(false);
            _this.focus();
        });
        this.enterSubscription = this.navigationService.enter
            .pipe(tap(function (event) { return event.originalEvent.preventDefault(); }))
            .subscribe(this.handleEnter.bind(this));
        this.escSubscription = this.navigationService.esc
            .subscribe(this.handleEscape.bind(this));
        this.filterBlurredSubscription = this.filterBlurred.pipe(concatMap(function () { return interval(10).pipe(take(1), takeUntil(_this.wrapperFocused)); }))
            .subscribe(function () {
            _this.wrapperBlurred.emit();
        });
        this._zone.runOutsideAngular(function () {
            _this.componentBlurredSubscription =
                merge(_this.wrapperBlurred.pipe(concatMap(function () { return interval(10).pipe(take(1), takeUntil(_this.filterFocused)); })), _this.navigationService.tab).pipe(tap(function (event) { return event instanceof NavigationEvent && _this.focus(); }), filter(function () { return _this.isFocused; }))
                    .subscribe(function () { return _this.componentBlur(); });
        });
    };
    DropDownListComponent.prototype.subscribeTouchEvents = function () {
        var _this = this;
        if (!isDocumentAvailable() || !this.touchEnabled) {
            return;
        }
        this._zone.runOutsideAngular(function () {
            // Roll up DropDownList on iOS when tapped outside
            return _this.touchstartDisposeHandler = _this.renderer.listen(document, 'touchstart', function (e) {
                var target = e.target;
                if (_this.isFocused && !inDropDown(_this.hostElement, target, _this.popupRef)) {
                    _this._zone.run(function () {
                        if (_this.filterFocused) {
                            // Close popup if filter is focused
                            _this.togglePopup(false);
                        }
                        _this.blur();
                    });
                }
            });
        });
    };
    DropDownListComponent.prototype.unsubscribeEvents = function () {
        if (!isDocumentAvailable()) {
            return;
        }
        this.navigationSubscription.unsubscribe();
        this.openSubscription.unsubscribe();
        this.closeSubscription.unsubscribe();
        this.enterSubscription.unsubscribe();
        this.escSubscription.unsubscribe();
        this.componentBlurredSubscription.unsubscribe();
        this.filterBlurredSubscription.unsubscribe();
        if (this.touchstartDisposeHandler) {
            this.touchstartDisposeHandler();
        }
        if (this.selectionSubscription) {
            this.selectionSubscription.unsubscribe();
        }
    };
    DropDownListComponent.prototype.itemFromEvent = function (event) {
        var index = event.indices[0];
        var dataItem = this.dataService.itemAt(index);
        dataItem = isPresent(dataItem) ? dataItem : this.currentOrDefault(index);
        var value = getter$1(dataItem, this.valueField);
        var newSelection = event.newSelection;
        return {
            dataItem: dataItem,
            index: index,
            newSelection: newSelection,
            value: value
        };
    };
    DropDownListComponent.prototype.currentOrDefault = function (selectedIndex) {
        var defaultItemIndex = -1;
        if (isPresent(this.dataItem) && selectedIndex !== defaultItemIndex) {
            return this.dataItem;
        }
        else {
            return this.defaultItem;
        }
    };
    DropDownListComponent.prototype.firstFocusableIndex = function (index) {
        var maxIndex = this.dataService.itemsCount - 1;
        if (this.disabledItemsService.isIndexDisabled(index)) {
            return (index < maxIndex) ? this.firstFocusableIndex(index + 1) : undefined;
        }
        else {
            return index;
        }
    };
    DropDownListComponent.prototype.handleEnter = function () {
        if (this.isOpen) {
            this.selectionService.change(this.selectionService.focused);
            this.focus();
        }
        else {
            this.togglePopup(true);
        }
    };
    DropDownListComponent.prototype.handleEscape = function () {
        if (isPresent(this.selectionService.selected[0])) {
            this.selectionService.change(this.selectionService.selected[0]);
        }
        else {
            this.togglePopup(false);
            this.clearFilter();
        }
        this.focus();
    };
    DropDownListComponent.prototype.clearFilter = function () {
        if (!(this.filterable && this.filterText)) {
            return;
        }
        this.filterText = "";
        this.cdr.markForCheck();
        this.filterChange.emit(this.filterText);
    };
    DropDownListComponent.prototype.verifySettings = function () {
        if (!isDevMode()) {
            return;
        }
        if (this.defaultItem && this.valueField && typeof this.defaultItem !== "object") {
            throw new Error(DropDownListMessages.defaultItem);
        }
        if (this.valuePrimitive === true && isPresent(this.value) && typeof this.value === "object") {
            throw new Error(DropDownListMessages.primitive);
        }
        if (this.valuePrimitive === false && isPresent(this.value) && typeof this.value !== "object") {
            throw new Error(DropDownListMessages.object);
        }
        var valueOrText = !isPresent(this.valueField) !== !isPresent(this.textField);
        if (valueOrText) {
            throw new Error(DropDownListMessages.textAndValue);
        }
    };
    DropDownListComponent.prototype.componentBlur = function () {
        var _this = this;
        this.isFocused = false;
        var selectionPresent = isPresent(this.selectionService.selected[0]);
        var valueHasChanged = selectionPresent && getter$1(this.value, this.valueField) !== getter$1(this.dataService.itemAt(this.selectionService.selected[0]), this.valueField);
        if (valueHasChanged ||
            hasObservers(this.close) ||
            hasObservers(this.onBlur) ||
            hasObservers(this.filterChange) ||
            isUntouched(this.hostElement.nativeElement)) {
            this._zone.run(function () {
                if (valueHasChanged) {
                    _this.selectionService.change(_this.selectionService.selected[0]);
                }
                _this.togglePopup(false);
                _this.clearFilter();
                _this.onBlur.emit();
                _this.onTouchedCallback();
            });
        }
        else {
            this.togglePopup(false);
        }
    };
    /**
     * @hidden
     */
    DropDownListComponent.prototype.onMouseDown = function (event) {
        var tagName = event.target.tagName.toLowerCase();
        if (tagName !== "input") {
            event.preventDefault();
        }
    };
    DropDownListComponent.prototype.onKeyPress = function (event) {
        if (event.which === 0 || event.keyCode === Keys.Enter) {
            return;
        }
        var character = String.fromCharCode(event.charCode || event.keyCode);
        if (this.ignoreCase) {
            character = character.toLowerCase();
        }
        if (character === " ") {
            event.preventDefault();
        }
        this.word += character;
        this.last = character;
        this.search();
    };
    DropDownListComponent.prototype.search = function () {
        var _this = this;
        clearTimeout(this.typingTimeout);
        if (!this.filterable) {
            this.typingTimeout = setTimeout(function () { _this.word = ""; }, this.delay);
            this.selectNext();
        }
    };
    DropDownListComponent.prototype.selectNext = function () {
        var _this = this;
        var data = this.dataService
            .filter(function (item) { return isPresent(item) && !item.header && !_this.disabledItemsService.isItemDisabled(item); })
            .map(function (item) {
            if (_this.dataService.grouped) {
                return { item: item.value, itemIndex: item.offsetIndex };
            }
            return { item: item, itemIndex: _this.dataService.indexOf(item) };
        });
        var isInLoop = sameCharsOnly(this.word, this.last);
        var dataLength = data.length;
        var hasSelected = !isNaN(this.selectionService.selected[0]);
        var startIndex = !hasSelected ? 0 : this.selectionService.selected[0];
        var text, index, defaultItem;
        if (this.defaultItem && !this.disabledItemsService.isItemDisabled(this.defaultItem)) {
            defaultItem = { item: this.defaultItem, itemIndex: -1 };
            dataLength += 1;
            startIndex += 1;
        }
        startIndex += isInLoop && hasSelected ? 1 : 0;
        data = shuffleData(data, startIndex, defaultItem);
        index = 0;
        for (; index < dataLength; index++) {
            text = getter$1(data[index].item, this.textField);
            var loopMatch = Boolean(isInLoop && matchText(text, this.last, this.ignoreCase));
            var nextMatch = Boolean(matchText(text, this.word, this.ignoreCase));
            if (loopMatch || nextMatch) {
                index = data[index].itemIndex;
                break;
            }
        }
        if (index !== dataLength) {
            this.navigate(index);
        }
    };
    DropDownListComponent.prototype.emitChange = function (value) {
        this.onChangeCallback(value);
        this.valueChange.emit(value);
    };
    DropDownListComponent.prototype.navigate = function (index) {
        this.selectionService.select(index);
    };
    DropDownListComponent.prototype.findDataItem = function (_a) {
        var valueField = _a.valueField, value = _a.value;
        var result = {
            dataItem: null,
            index: -1
        };
        var prop = function (dataItem) { return getter$1(dataItem, valueField); };
        var comparer;
        if (this.dataService.grouped) {
            comparer = function (element) {
                return prop(element.value) === prop(value);
            };
        }
        else {
            comparer = function (element) {
                return prop(element) === prop(value);
            };
        }
        var index = this.dataService.findIndex(comparer);
        result.dataItem = this.dataService.itemAt(index);
        result.index = index;
        return result;
    };
    DropDownListComponent.prototype.setState = function () {
        var value = this.value;
        var valueField = this.valueField;
        var textField = this.textField;
        var primitive = this.valuePrimitive;
        if (this.defaultItem) {
            var defaultValue = getter$1(this.defaultItem, valueField);
            var currentValue = getter$1(value, valueField);
            if (!isPresent(value) || (currentValue === defaultValue)) {
                this.updateState({ dataItem: this.defaultItem, confirm: true });
                this.resetSelection(-1);
                if (this.filterable && this.filterText && this.dataService.itemsCount) {
                    this.selectionService.focused = this.firstFocusableIndex(0);
                }
                return;
            }
        }
        var resolved = this.findDataItem({ valueField: valueField, value: value });
        // The data and value are of same shape,
        // for example, value: 'foo', data: ['foo', 'bar']
        // or value: { value: 1, text: 'foo' }, data: [{ value: 1, text: 'foo' }].
        var ofSameType = !(primitive && textField);
        if (resolved.dataItem) {
            this.updateState({ dataItem: resolved.dataItem, confirm: true });
            this.resetSelection(resolved.index);
        }
        else if (isPresent(value) && ofSameType) {
            this.updateState({ dataItem: value });
            this.resetSelection();
        }
        else if (this._previousDataItem) {
            this.updateState({ dataItem: this._previousDataItem });
            this.resetSelection();
        }
        else {
            this.clearState();
            this.resetSelection();
        }
    };
    /**
     * @hidden
     */
    DropDownListComponent.prototype.handleFilter = function (event) {
        this.filterChange.emit(event.target.value);
    };
    /**
     * @hidden
     */
    DropDownListComponent.prototype.pageChange = function (event) {
        var virtual = this.virtual;
        virtual.skip = event.skip;
    };
    DropDownListComponent.prototype.setMessages = function () {
        var _this = this;
        this._zone.runOutsideAngular(function () {
            clearTimeout(_this.messagesTimeout);
            _this.messagesTimeout = setTimeout(function () {
                _this.noDataText = _this.localization.get('noDataText');
                _this.cdr.detectChanges();
            });
        });
    };
    DropDownListComponent.prototype.assignAriaDescribedBy = function () {
        var currentValue = this.wrapper.nativeElement.getAttribute('aria-describedby') || '';
        var trimmed = currentValue.replace(this.valueLabelId, '').trim();
        // reset the value label ID to force readers to read the new value
        this.valueLabelId = guid$1();
        // add to the current value - don't replace it
        var newValue = (this.valueLabelId + " " + trimmed).trim();
        this.renderer.setAttribute(this.wrapper.nativeElement, 'aria-describedby', newValue);
    };
    var DropDownListComponent_1;
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], DropDownListComponent.prototype, "focusableId", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], DropDownListComponent.prototype, "iconClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], DropDownListComponent.prototype, "loading", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], DropDownListComponent.prototype, "data", null);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], DropDownListComponent.prototype, "value", null);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], DropDownListComponent.prototype, "textField", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], DropDownListComponent.prototype, "valueField", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], DropDownListComponent.prototype, "popupSettings", null);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], DropDownListComponent.prototype, "listHeight", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], DropDownListComponent.prototype, "defaultItem", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], DropDownListComponent.prototype, "disabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Function])
    ], DropDownListComponent.prototype, "itemDisabled", null);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], DropDownListComponent.prototype, "readonly", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], DropDownListComponent.prototype, "filterable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], DropDownListComponent.prototype, "virtual", null);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], DropDownListComponent.prototype, "ignoreCase", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], DropDownListComponent.prototype, "delay", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], DropDownListComponent.prototype, "valuePrimitive", null);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], DropDownListComponent.prototype, "tabindex", void 0);
    __decorate([
        Input("tabIndex"),
        __metadata("design:type", Number),
        __metadata("design:paramtypes", [Number])
    ], DropDownListComponent.prototype, "tabIndex", null);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], DropDownListComponent.prototype, "valueChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], DropDownListComponent.prototype, "filterChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], DropDownListComponent.prototype, "selectionChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], DropDownListComponent.prototype, "open", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], DropDownListComponent.prototype, "opened", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], DropDownListComponent.prototype, "close", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], DropDownListComponent.prototype, "closed", void 0);
    __decorate([
        Output('focus'),
        __metadata("design:type", EventEmitter)
    ], DropDownListComponent.prototype, "onFocus", void 0);
    __decorate([
        Output('blur'),
        __metadata("design:type", EventEmitter)
    ], DropDownListComponent.prototype, "onBlur", void 0);
    __decorate([
        ContentChild(ItemTemplateDirective, { static: false }),
        __metadata("design:type", ItemTemplateDirective)
    ], DropDownListComponent.prototype, "itemTemplate", void 0);
    __decorate([
        ContentChild(GroupTemplateDirective, { static: false }),
        __metadata("design:type", GroupTemplateDirective)
    ], DropDownListComponent.prototype, "groupTemplate", void 0);
    __decorate([
        ContentChild(FixedGroupTemplateDirective, { static: false }),
        __metadata("design:type", FixedGroupTemplateDirective)
    ], DropDownListComponent.prototype, "fixedGroupTemplate", void 0);
    __decorate([
        ContentChild(ValueTemplateDirective, { static: false }),
        __metadata("design:type", ValueTemplateDirective)
    ], DropDownListComponent.prototype, "valueTemplate", void 0);
    __decorate([
        ContentChild(HeaderTemplateDirective, { static: false }),
        __metadata("design:type", HeaderTemplateDirective)
    ], DropDownListComponent.prototype, "headerTemplate", void 0);
    __decorate([
        ContentChild(FooterTemplateDirective, { static: false }),
        __metadata("design:type", FooterTemplateDirective)
    ], DropDownListComponent.prototype, "footerTemplate", void 0);
    __decorate([
        ContentChild(NoDataTemplateDirective, { static: false }),
        __metadata("design:type", NoDataTemplateDirective)
    ], DropDownListComponent.prototype, "noDataTemplate", void 0);
    __decorate([
        ViewChild('container', { read: ViewContainerRef, static: true }),
        __metadata("design:type", ViewContainerRef)
    ], DropDownListComponent.prototype, "container", void 0);
    __decorate([
        ViewChild('popupTemplate', { static: true }),
        __metadata("design:type", TemplateRef)
    ], DropDownListComponent.prototype, "popupTemplate", void 0);
    __decorate([
        ViewChild('wrapper', { static: true }),
        __metadata("design:type", ElementRef)
    ], DropDownListComponent.prototype, "wrapper", void 0);
    __decorate([
        ViewChild('optionsList', { static: false }),
        __metadata("design:type", ListComponent)
    ], DropDownListComponent.prototype, "optionsList", void 0);
    __decorate([
        HostBinding('class.k-widget'),
        HostBinding('class.k-dropdown'),
        __metadata("design:type", Boolean)
    ], DropDownListComponent.prototype, "widgetClasses", void 0);
    __decorate([
        HostBinding('attr.dir'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], DropDownListComponent.prototype, "dir", null);
    DropDownListComponent = DropDownListComponent_1 = __decorate([
        Component({
            exportAs: 'kendoDropDownList',
            providers: [
                DROPDOWNLIST_VALUE_ACCESSOR,
                DataService,
                SelectionService,
                NavigationService,
                DisabledItemsService,
                LocalizationService,
                {
                    provide: L10N_PREFIX,
                    useValue: 'kendo.dropdownlist'
                },
                {
                    provide: FilterableComponent, useExisting: forwardRef(function () { return DropDownListComponent_1; })
                },
                {
                    provide: KendoInput, useExisting: forwardRef(function () { return DropDownListComponent_1; })
                }
            ],
            selector: 'kendo-dropdownlist',
            template: "\n        <ng-container kendoDropDownListLocalizedMessages\n            i18n-noDataText=\"kendo.dropdownlist.noDataText|The text displayed in the popup when there are no items\"\n            noDataText=\"NO DATA FOUND\"\n        >\n        </ng-container>\n        <span #wrapper unselectable=\"on\"\n          role=\"listbox\"\n          [id]=\"focusableId\"\n          [ngClass]=\"{\n            'k-dropdown-wrap': true,\n            'k-state-disabled': this.disabled\n          }\"\n          [attr.dir]=\"direction\"\n          [attr.readonly]=\"readonly\"\n          [attr.tabindex]=\"widgetTabIndex\"\n          [attr.aria-disabled]=\"disabled\"\n          [attr.aria-readonly]=\"readonly\"\n          aria-haspopup=\"listbox\"\n          [attr.aria-expanded]=\"ariaExpanded\"\n          [attr.aria-owns]=\"ariaOwns\"\n          [attr.aria-activedescendant]=\"ariaActivedescendant\"\n          [attr.aria-label]=\"noDataLabel\"\n          (keydown)=\"keydown($event)\"\n          (keypress)=\"keypress($event)\"\n          (click)=\"click($event)\"\n          [kendoEventsOutsideAngular]=\"{\n            focus: focusComponent,\n            blur: blurComponent\n            }\"\n          [scope]=\"this\"\n        >\n            <span class=\"k-input\" unselectable=\"on\" [id]=\"valueLabelId\">\n               <ng-template *ngIf=\"valueTemplate\"\n                   [templateContext]=\"{\n                       templateRef: valueTemplate.templateRef,\n                       $implicit: dataItem\n                   }\">\n               </ng-template>\n               <ng-template [ngIf]=\"!valueTemplate\">{{ getText() }}</ng-template>\n           </span>\n           <span class=\"k-select\" unselectable=\"on\">\n               <span\n                    class=\"k-icon\"\n                    unselectable=\"on\"\n                    [ngClass]=\"buttonClasses\"\n                >\n                </span>\n           </span>\n           <ng-template #popupTemplate>\n               <!--filterable-->\n\n               <ng-template [ngIf]=\"filterable\">\n                   <span class=\"k-list-filter\" (click)=\"$event.stopImmediatePropagation()\">\n                       <input\n                           [attr.aria-owns]=\"ariaOwns\"\n                           [attr.aria-activedescendant]=\"ariaActivedescendant\"\n                           [attr.aria-label]=\"noDataLabel\"\n                           tabindex=\"-1\"\n                           [filterInput]=\"isFocused && !touchEnabled\"\n                           [dir]=\"direction\"\n                           [(ngModel)]=\"filterText\"\n                           class=\"k-textbox\"\n                           (keydown)=\"keydown($event)\"\n                           (input)=\"handleFilter($event)\"\n                           (focus)=\"onFilterFocus()\"\n                           (blur)=\"blurFilterInput()\" />\n                       <span class=\"k-icon k-i-search\" unselectable=\"on\"></span>\n                   </span>\n               </ng-template>\n               <!--default item-->\n               <ng-template [ngIf]=\"defaultItem && !itemTemplate\">\n                   <div class=\"k-list-optionlabel\" [ngClass]=\"{ 'k-state-disabled': isDisabledDefaultItem }\" kendoDropDownsSelectable [index]=\"-1\">\n                       {{ getDefaultItemText() }}\n                   </div>\n               </ng-template>\n               <ng-template [ngIf]=\"defaultItem && itemTemplate\">\n                   <div class=\"k-list-optionlabel\" [ngClass]=\"{ 'k-state-disabled': isDisabledDefaultItem }\" kendoDropDownsSelectable [index]=\"-1\">\n                       <ng-template\n                           [templateContext]=\"{\n                               templateRef: itemTemplate.templateRef,\n                               $implicit: defaultItem\n                           }\">\n                       </ng-template>\n                   </div>\n               </ng-template>\n               <!--header template-->\n               <ng-template *ngIf=\"headerTemplate\"\n                   [templateContext]=\"{\n                       templateRef: headerTemplate.templateRef\n                   }\">\n               </ng-template>\n               <!--list-->\n               <kendo-list\n                   #optionsList\n                   [id]=\"listBoxId\"\n                   [optionPrefix]=\"optionPrefix\"\n                   [data]=\"data\"\n                   [textField]=\"textField\"\n                   [valueField]=\"valueField\"\n                   [template]=\"itemTemplate\"\n                   [groupTemplate]=\"groupTemplate\"\n                   [fixedGroupTemplate]=\"fixedGroupTemplate\"\n                   [height]=\"listHeight\"\n                   [show]=\"isOpen\"\n                   [virtual]=\"virtual\"\n                   (pageChange)=\"pageChange($event)\"\n                   >\n               </kendo-list>\n               <!--no-data template-->\n               <div class=\"k-nodata\" *ngIf=\"data.length === 0\">\n                   <ng-template [ngIf]=\"noDataTemplate\"\n                       [templateContext]=\"{\n                           templateRef: noDataTemplate ? noDataTemplate.templateRef : undefined\n                       }\">\n                   </ng-template>\n                   <ng-template [ngIf]=\"!noDataTemplate\">\n                       <div>{{ noDataText }}</div>\n                   </ng-template>\n               </div>\n               <!--footer template-->\n               <ng-template *ngIf=\"footerTemplate\"\n                   [templateContext]=\"{\n                       templateRef: footerTemplate.templateRef\n                   }\">\n               </ng-template>\n            </ng-template>\n        </span>\n        <ng-template [ngIf]=\"isOpen\">\n            <kendo-resize-sensor (resize)=\"onResize()\"></kendo-resize-sensor>\n        </ng-template>\n        <ng-container #container></ng-container>\n  "
        }),
        __param(10, Optional()), __param(10, Inject(TOUCH_ENABLED)),
        __metadata("design:paramtypes", [LocalizationService,
            PopupService,
            SelectionService,
            NavigationService,
            DisabledItemsService,
            DataService,
            NgZone,
            Renderer2,
            ElementRef,
            ChangeDetectorRef, Boolean])
    ], DropDownListComponent);
    return DropDownListComponent;
}());

/**
 * Renders the content of the custom list item in the MultiSelect
 * ([see example]({% slug templates_multiselect %}#toc-customizing-the-item-content)).
 * The template context is set to the current component.
 * To get a reference to the current text that is typed by the
 * user, use the `let-customItem` directive.
 *
 * > The `CustomItemTemplate` directive can only be used with the MultiSelect component.
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-multiselect [data]="listItems" [allowCustom]="true">
 *    <ng-template kendoMultiSelectCustomItemTemplate let-customItem>
 *      <span>New Item: {{customItem}}</span>
 *    </ng-template>
 *  </kendo-multiselect>
 * `
 * })
 * class AppComponent {
 *   public listItems: Array<string> = ["Item 1", "Item 2", "Item 3", "Item 4"];
 * }
 * ```
 *
 */
var CustomItemTemplateDirective = /** @class */ (function () {
    function CustomItemTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    CustomItemTemplateDirective = __decorate([
        Directive({
            selector: '[kendoMultiSelectCustomItemTemplate]'
        }),
        __metadata("design:paramtypes", [TemplateRef])
    ], CustomItemTemplateDirective);
    return CustomItemTemplateDirective;
}());

/**
 * Renders the selected tag value of the MultiSelect
 * ([see example]({% slug templates_multiselect %}#toc-tag-template)).
 * The template context is set to the current component.
 * To get a reference to the current data item, use the `let-dataItem` directive.
 *
 * > The `TagTemplate` directive can only be used with the MultiSelect and MultiSelectTree components.
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-multiselect [data]="items">
 *    <ng-template kendoMultiSelectTagTemplate let-dataItem>
 *      <span>{{dataItem}} option</span>
 *    </ng-template>
 *  </kendo-multiselect>
 * `
 * })
 * class AppComponent {
 *   public items: Array<string> = ["Item 1", "Item 2", "Item 3", "Item 4"];
 * }
 * ```
 */
var TagTemplateDirective = /** @class */ (function () {
    function TagTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    TagTemplateDirective = __decorate([
        Directive({
            selector: '[kendoMultiSelectTagTemplate],[kendoMultiSelectTreeTagTemplate]'
        }),
        __metadata("design:paramtypes", [TemplateRef])
    ], TagTemplateDirective);
    return TagTemplateDirective;
}());

/**
 * Renders the grouped tag values in the MultiSelect
 * ([see example]({% slug summarytagmode_multiselect %})).
 * The template context is set to the current component.
 * To get a reference to the current grouped
 * data items collection, use the `let-dataItems` directive.
 *
 * > The `GroupTagTemplate` directive can only be used with the MultiSelect and MultiSelectTree components.
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-multiselect kendoMultiSelectSummaryTag [data]="items">
 *    <ng-template kendoMultiSelectGroupTagTemplate let-dataItems>
 *      <span>{{dataItems.length}} item(s) selected</span>
 *    </ng-template>
 *  </kendo-multiselect>
 * `
 * })
 * class AppComponent {
 *   public items: Array<string> = ["Item 1", "Item 2", "Item 3", "Item 4"];
 * }
 * ```
 */
var GroupTagTemplateDirective = /** @class */ (function () {
    function GroupTagTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    GroupTagTemplateDirective = __decorate([
        Directive({
            selector: '[kendoMultiSelectGroupTagTemplate],[kendoMultiSelectTreeGroupTagTemplate]'
        }),
        __metadata("design:paramtypes", [TemplateRef])
    ], GroupTagTemplateDirective);
    return GroupTagTemplateDirective;
}());

/**
 * Arguments for the `removeTag` event. The `removeTag` event fires when a tag is about
 * to the removed. If you cancel the event, the removal is prevented.
 */
var RemoveTagEvent = /** @class */ (function (_super) {
    __extends(RemoveTagEvent, _super);
    /**
     * Constructs the event arguments for the `remove` event.
     * @param dataItem - The data item or an array of data items that will be removed.
     */
    function RemoveTagEvent(dataItem) {
        var _this = _super.call(this) || this;
        _this.dataItem = dataItem;
        return _this;
    }
    return RemoveTagEvent;
}(PreventableEvent));

/**
 * @hidden
 */
var normalizeCheckboxesSettings = function (settings) {
    if (isObject(settings)) {
        var defaultSettings = { enabled: true, checkOnClick: true };
        return Object.assign({}, defaultSettings, settings);
    }
    return { enabled: Boolean(settings), checkOnClick: true };
};

/* tslint:disable:member-ordering */
var MULTISELECT_VALUE_ACCESSOR = {
    multi: true,
    provide: NG_VALUE_ACCESSOR,
    // tslint:disable-next-line:no-use-before-declare
    useExisting: forwardRef(function () { return MultiSelectComponent; })
};
/**
 * Represents the [Kendo UI MultiSelect component for Angular]({% slug overview_multiselect %}).
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-multiselect [data]="listItems">
 *  </kendo-multiselect>
 * `
 * })
 * class AppComponent {
 *   public listItems: Array<string> = ["Item 1", "Item 2", "Item 3", "Item 4"];
 * }
 * ```
 */
var MultiSelectComponent = /** @class */ (function () {
    function MultiSelectComponent(localization, popupService, dataService, selectionService, navigationService, disabledItemsService, cdr, differs, renderer, hostElement, _zone, touchEnabled$$1) {
        var _this = this;
        this.localization = localization;
        this.popupService = popupService;
        this.dataService = dataService;
        this.selectionService = selectionService;
        this.navigationService = navigationService;
        this.disabledItemsService = disabledItemsService;
        this.cdr = cdr;
        this.differs = differs;
        this.renderer = renderer;
        this.hostElement = hostElement;
        this._zone = _zone;
        this.touchEnabled = touchEnabled$$1;
        this.listBoxId = guid$1();
        this.tagListId = guid$1();
        this.tagPrefix = "tag-" + guid$1();
        this.optionPrefix = "option-" + guid$1();
        this.focusedTagIndex = undefined;
        /**
         * @hidden
         */
        this.focusableId = "k-" + guid$1();
        /**
         * Determines whether to close the options list of the MultiSelect after the item selection is finished
         * ([see example]({% slug openstate_multiselect %}#toc-keeping-the-options-list-open-while-on-focus)).
         * @default true
         */
        this.autoClose = true;
        /**
         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        this.tabindex = 0;
        /**
         * Sets the disabled state of the component.
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the component.
         */
        this.readonly = false;
        /**
         * Enables the [filtering]({% slug filtering_multiselect %}) functionality of the MultiSelect.
         */
        this.filterable = false;
        /**
         * Sets the height of the suggestions list. By default, `listHeight` is 200px.
         *
         * > The `listHeight` property affects only the list of suggestions and not the whole popup container.
         * > To set the height of the popup container, use `popupSettings.height`.
         */
        this.listHeight = 200;
        /**
         * If set to `true`, renders a button on hovering over the component.
         * Clicking this button resets the value of the component to an empty array and triggers the `change` event.
         */
        this.clearButton = true;
        /**
         * A user-defined callback function which receives an array of selected data items and maps them to an array of tags.
         *
         * @param { Any[] } dataItems - The selected data items from the list.
         * @returns { Any[] } - The tags that will be rendered by the component.
         */
        this.tagMapper = function (tags) { return tags || []; };
        /**
         * Specifies whether the MultiSelect allows user-defined values that are not present in the dataset
         * ([more information and examples]({% slug custom_values_multiselect %})).
         * Defaults to `false`.
         */
        this.allowCustom = false;
        /**
         * A user-defined callback function which returns normalized custom values.
         * Typically used when the data items are different from type `string`.
         *
         * @param { Any } value - The custom value that is defined by the user.
         * @returns { Any }
         *
         * @example
         * ```ts
         * import { map } from 'rxjs/operators';
         *
         * _@Component({
         * selector: 'my-app',
         * template: `
         *   <kendo-multiselect
         *       [allowCustom]="true"
         *       [data]="listItems"
         *       textField="text"
         *       valueField="value"
         *       [valueNormalizer]="valueNormalizer"
         *       (valueChange)="onValueChange($event)"
         *   >
         *   </kendo-multiselect>
         * `
         * })
         *
         * class AppComponent {
         *   public listItems: Array<{ text: string, value: number }> = [
         *       { text: "Small", value: 1 },
         *       { text: "Medium", value: 2 },
         *       { text: "Large", value: 3 }
         *   ];
         *
         *   public onValueChange(value) {
         *       console.log("valueChange : ", value);
         *   }
         *
         *   public valueNormalizer = (text$: Observable<string>) => text$.pipe(map((text: string) => {
         *      return {
         *         value: Math.floor(Math.random() * (1000 - 100) + 1000), //generate unique valueField
         *         text: text };
         *   }));
         *
         * }
         * ```
         */
        this.valueNormalizer = function (text) { return text.pipe(map(function (userInput) {
            var comparer = function (item) { return typeof item === 'string' && userInput.toLowerCase() === item.toLowerCase(); };
            var matchingValue = _this.value.find(comparer);
            if (matchingValue) {
                return matchingValue;
            }
            var matchingItem = _this.dataService.find(comparer);
            return matchingItem ? matchingItem : userInput;
        })); };
        /**
         * Fires each time the user types in the input field.
         * You can filter the source based on the passed filtration value.
         */
        this.filterChange = new EventEmitter();
        /**
         * Fires each time the value is changed&mdash;
         * when the component is blurred or the value is cleared through the **Clear** button
         * ([see example]({% slug overview_multiselect %}#toc-events)).
         * When the value of the component is programmatically changed to `ngModel` or `formControl`
         * through its API or form binding, the `valueChange` event is not triggered because it
         * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time the popup is about to open
         * ([see example]({% slug openstate_multiselect %}#toc-preventing-opening-and-closing)).
         * This event is preventable. If you cancel it, the popup will remain closed.
         */
        this.open = new EventEmitter();
        /**
         * Fires after the popup has been opened.
         */
        this.opened = new EventEmitter();
        /**
         * Fires each time the popup is about to close
         * ([see example]({% slug openstate_multiselect %}#toc-preventing-opening-and-closing)).
         * This event is preventable. If you cancel it, the popup will remain open.
         */
        this.close = new EventEmitter();
        /**
         * Fires after the popup has been closed.
         */
        this.closed = new EventEmitter();
        /**
         * Fires each time the user focuses the MultiSelect.
         */
        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the MultiSelect gets blurred.
         */
        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time a tag is about to be removed.
         * This event is preventable. If you cancel it, the tag will not be removed.
         */
        this.removeTag = new EventEmitter();
        this.widgetClasses = true;
        this.initialized = false;
        this.onChangeCallback = function (_) { };
        this.onTouchedCallback = function (_) { };
        this._placeholder = '';
        this._open = false;
        this._value = [];
        this._popupSettings = { animate: true };
        this._checkboxes = { enabled: false };
        this._isFocused = false;
        this.selectedDataItems = [];
        this.customValueSubject = new Subject();
        this.observableSubscriptions = new Subscription();
        validatePackage(packageMetadata);
        this.popupMouseDownHandler = this.onMouseDown.bind(this);
        this.data = [];
        this.direction = this.localization.rtl ? 'rtl' : 'ltr';
        this.subscribeEvents();
        this.subscribeTouchEvents();
    }
    MultiSelectComponent_1 = MultiSelectComponent;
    /**
     * Focuses a specific item of the MultiSelect based on a provided index.
     * If there is a custom item it is positioned at index -1.
     * If null or invalid index is provided the focus will be removed.
     */
    MultiSelectComponent.prototype.focusItemAt = function (index) {
        var minIndex = this.allowCustom ? -1 : 0;
        var isInRange = minIndex <= 0 && index < this.data.length;
        if (isPresent(index) && isInRange && !this.disabledItemsService.isIndexDisabled(index)) {
            this.selectionService.focus(index);
        }
        else {
            this.selectionService.focus(null);
        }
    };
    /**
     * Focuses the MultiSelect.
     */
    MultiSelectComponent.prototype.focus = function () {
        if (!this.disabled) {
            this.searchbar.focus();
        }
    };
    /**
     * @hidden
     */
    MultiSelectComponent.prototype.onSearchBarFocus = function () {
        var _this = this;
        if (!this.isFocused) {
            this.isFocused = true;
            if (hasObservers(this.onFocus)) {
                this._zone.run(function () {
                    _this.onFocus.emit();
                });
            }
        }
    };
    /**
     * Blurs the MultiSelect.
     */
    MultiSelectComponent.prototype.blur = function () {
        if (!this.disabled) {
            this.searchbar.blur();
        }
    };
    /**
     * @hidden
     */
    MultiSelectComponent.prototype.onSearchBarBlur = function () {
        var _this = this;
        if (!this.isFocused) {
            return;
        }
        this.isFocused = false;
        if (hasObservers(this.onBlur) ||
            hasObservers(this.filterChange) ||
            hasObservers(this.close) ||
            isUntouched(this.hostElement.nativeElement)) {
            this._zone.run(function () {
                _this.closePopup();
                if (!(_this.isOpen && _this.allowCustom)) {
                    _this.clearFilter();
                }
                _this.onBlur.emit();
                _this.onTouchedCallback();
            });
        }
        else {
            if (!this.allowCustom) {
                this.clearFilter();
            }
            this.closePopup();
        }
    };
    /**
     * @hidden
     */
    MultiSelectComponent.prototype.wrapperMousedown = function (event) {
        var inputElement = this.searchbar.input.nativeElement;
        if (event.button === 0) {
            if (this.isFocused && this.isOpen && event.target === inputElement) {
                return;
            }
            if (!this.touchEnabled || (this.touchEnabled && event.target.tagName !== 'SPAN')) {
                this.searchbar.focus();
            }
            this.togglePopup(!this.isOpen);
            event.preventDefault();
        }
    };
    /**
     * @hidden
     */
    MultiSelectComponent.prototype.onMouseDown = function (event) {
        event.preventDefault();
    };
    /**
     * @hidden
     */
    MultiSelectComponent.prototype.onResize = function () {
        if (this._open) {
            var popupWrapper = this.popupRef.popupElement;
            var _a = this.width, min = _a.min, max = _a.max;
            popupWrapper.style.minWidth = min;
            popupWrapper.style.width = max;
        }
    };
    Object.defineProperty(MultiSelectComponent.prototype, "appendTo", {
        get: function () {
            var appendTo = this.popupSettings.appendTo;
            if (!appendTo || appendTo === 'root') {
                return undefined;
            }
            return appendTo === 'component' ? this.container : appendTo;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectComponent.prototype, "data", {
        get: function () {
            var virtual = this.virtual;
            if (virtual) {
                var start = virtual.skip || 0;
                var end = start + virtual.pageSize;
                //Use length instead of itemsCount because of grouping
                virtual.total = this.dataService.data.length;
                return this.dataService.data.slice(start, end);
            }
            return this.dataService.data;
        },
        /**
         * Sets the data of the MultiSelect.
         *
         * > The data has to be provided in an array-like list of items.
         */
        set: function (data) {
            this.dataService.data = data || [];
            if (this.virtual) {
                this.virtual.skip = 0;
            }
            if (this.initialized) {
                this.setState(this.value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectComponent.prototype, "value", {
        get: function () {
            return this._value;
        },
        /**
         * Sets the value of the MultiSelect. It can be either of the primitive (string, numbers) or of the complex (objects) type.
         * To define the type, use the `valuePrimitive` option.
         *
         * > All selected values which are not present in the source are ignored.
         */
        set: function (values) {
            this._value = values ? values : [];
            if (!this.differ && this.value) {
                this.differ = this.differs.find(this.value).create();
            }
            this.valueChangeDetected = true;
            if (this.initialized) {
                this.setState(this.value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectComponent.prototype, "tabIndex", {
        get: function () {
            return this.tabindex;
        },
        /**
         * @hidden
         */
        set: function (tabIndex) {
            this.tabindex = tabIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectComponent.prototype, "placeholder", {
        get: function () {
            return this.selectedDataItems.length ? '' : this._placeholder;
        },
        /**
         * The hint which is displayed when the component is empty.
         * When the values are selected, it disappears.
         */
        set: function (text) {
            this._placeholder = text || '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectComponent.prototype, "itemDisabled", {
        /**
         * Defines a Boolean function that is executed for each data item in the component
         * ([see examples]({% slug disableditems_multiselect %})). Determines whether the item will be disabled.
         */
        set: function (fn) {
            if (typeof fn !== 'function') {
                throw new Error("itemDisabled must be a function, but received " + JSON.stringify(fn) + ".");
            }
            this.disabledItemsService.itemDisabled = fn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectComponent.prototype, "checkboxes", {
        get: function () {
            return this._checkboxes;
        },
        /**
         * Specifies whether checkboxes will be rendered before each item in the popup list.
         */
        set: function (settings) {
            this._checkboxes = normalizeCheckboxesSettings(settings);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectComponent.prototype, "virtual", {
        get: function () {
            return this._virtualSettings;
        },
        /**
         * Enables the [virtualization]({% slug virtualization_multiselect %}) functionality.
         */
        set: function (settings) {
            this._virtualSettings = normalizeVirtualizationSettings(settings);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectComponent.prototype, "popupSettings", {
        get: function () {
            return this._popupSettings;
        },
        /**
         * Configures the popup of the MultiSelect.
         *
         * The available options are:
         * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
         * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped. The `auto` mode is not supported when virtual scrolling is enabled.
         * - `height: Number`&mdash;Sets the height of the popup container.
         * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
         * - `appendTo: "root" | "component" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.
         */
        set: function (settings) {
            this._popupSettings = Object.assign({ animate: true }, settings);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectComponent.prototype, "valuePrimitive", {
        get: function () {
            if (!isPresent(this._valuePrimitive)) {
                return !isPresent(this.valueField);
            }
            return this._valuePrimitive;
        },
        /**
         * Specifies the type of the selected value.
         * If set to `true`, the selected value has to be of the primitive type
         * ([more information and example]({% slug valuebinding_multiselect %}#toc-primitive-values-from-object-fields)).
         */
        set: function (isPrimitive) {
            this._valuePrimitive = isPrimitive;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectComponent.prototype, "dir", {
        get: function () {
            return this.direction;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectComponent.prototype, "disabledClass", {
        get: function () {
            return this.disabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectComponent.prototype, "listContainerClasses", {
        get: function () {
            var containerClasses = ['k-list-container', 'k-reset'];
            if (this.popupSettings.popupClass) {
                containerClasses.push(this.popupSettings.popupClass);
            }
            return containerClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectComponent.prototype, "width", {
        get: function () {
            var wrapperOffsetWidth = 0;
            if (isDocumentAvailable()) {
                wrapperOffsetWidth = this.wrapper.nativeElement.offsetWidth;
            }
            var width = this.popupSettings.width || wrapperOffsetWidth;
            var minWidth = isNaN(wrapperOffsetWidth) ? wrapperOffsetWidth : wrapperOffsetWidth + "px";
            var maxWidth = isNaN(width) ? width : width + "px";
            return { min: minWidth, max: maxWidth };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectComponent.prototype, "height", {
        get: function () {
            var popupHeight = this.popupSettings.height;
            return isPresent(popupHeight) ? popupHeight + "px" : 'auto';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectComponent.prototype, "activeDescendant", {
        get: function () {
            var focusedTagIndex = this.focusedTagIndex;
            var focusedListIndex = this.selectionService.focused;
            var prefix;
            var item;
            if (isPresent(focusedTagIndex) && !this.isOpen) {
                item = this.tags[focusedTagIndex];
                prefix = this.tagPrefix;
            }
            else if (isPresent(focusedListIndex) && focusedListIndex !== -1 && this.isOpen) {
                item = this.dataService.itemAt(focusedListIndex);
                prefix = this.optionPrefix;
            }
            else {
                return null;
            }
            return prefix + "-" + getter$1(item, this.valueField);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectComponent.prototype, "noDataLabel", {
        get: function () {
            if (this.dataService.itemsCount === 0) {
                return this.noDataText;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectComponent.prototype, "clearTitle", {
        get: function () {
            return this.localization.get('clearTitle');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectComponent.prototype, "clearButtonVisiblity", {
        get: function () {
            if (this.touchEnabled) {
                return 'visible';
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    MultiSelectComponent.prototype.verifySettings = function () {
        if (!isDevMode() || this.value.length === 0) {
            return;
        }
        if (!isArray(this.value)) {
            throw new Error(MultiselectMessages.array);
        }
        if (this.valuePrimitive === true && isObjectArray(this.value)) {
            throw new Error(MultiselectMessages.primitive);
        }
        if (this.valuePrimitive === false && !isObjectArray(this.value)) {
            throw new Error(MultiselectMessages.object);
        }
        var valueOrText = !isPresent(this.valueField) !== !isPresent(this.textField);
        if (valueOrText) {
            throw new Error(MultiselectMessages.textAndValue);
        }
    };
    /**
     * @hidden
     */
    MultiSelectComponent.prototype.change = function (event) {
        var _this = this;
        var isCustomItem = (isPresent(event.added) || isPresent(event.removed)) && (event.added === -1 || event.removed === -1);
        if (isCustomItem) {
            this.addCustomValue(this.text);
            return; // The change is emited asynchronosly.
        }
        // Existing items.
        if (isPresent(event.added)) {
            var dataItem = this.dataService.itemAt(event.added);
            var newItem = (this.valuePrimitive && isPresent(dataItem) && isPresent(dataItem[this.valueField])) ? dataItem[this.valueField] : dataItem;
            this.value = this.value.concat([newItem]);
        }
        if (isPresent(event.removed)) {
            var dataItem_1 = this.dataService.itemAt(event.removed);
            var filter_1 = function (item) { return getter$1(item, _this.valueField) !== getter$1(dataItem_1, _this.valueField); };
            this.value = this.value.filter(filter_1);
            this.selectionService.focused = event.removed;
            this.cdr.detectChanges();
        }
        this.emitValueChange();
    };
    /**
     * @hidden
     */
    MultiSelectComponent.prototype.setState = function (value) {
        var _this = this;
        var data = this.dataService.data;
        if (this.dataService.grouped) {
            data = data.filter(function (item) { return !item.header; }).map(function (item) { return item.value; });
        }
        var selection = selectedIndices(this.value, data, this.valueField);
        this.selectionService.resetSelection(selection);
        if (this.disabledItemsService.isIndexDisabled(this.selectionService.focused)) {
            this.selectionService.focused = this.firstFocusableIndex(0);
        }
        if (this.isOpen && this.selectionService.focused === undefined) {
            if (this.dataService.itemsCount > 0) {
                this.selectionService.focused = this.firstFocusableIndex(0);
            }
            else if (this.allowCustom) {
                this.selectionService.focused = -1;
            }
        }
        if (this.valuePrimitive && !this.valueField) {
            this.selectedDataItems = value.slice();
        }
        if (isObjectArray(value) || this.valuePrimitive && this.valueField) {
            this.selectedDataItems = resolveAllValues(value, data, this.valueField);
        }
        if (this.selectedDataItems.length < value.length) {
            this.selectedDataItems = value
                .map(function (current) {
                var dataItem = _this.selectedDataItems.find(function (item) { return getter$1(item, _this.valueField) === getter$1(current, _this.valueField); });
                return isPresent(dataItem) ? dataItem : _this.resolveDataItemFromTags(current);
            })
                .filter(function (dataItem) { return isPresent(dataItem); });
        }
        this.tags = this.tagMapper(this.selectedDataItems.slice(0));
        this.disabledIndices = this.disabledItemsMapper();
        this.cdr.markForCheck();
    };
    /**
     * @hidden
     */
    MultiSelectComponent.prototype.handleFilter = function (text) {
        this.text = text;
        if (text && !this.isOpen) {
            this.openPopup();
        }
        if (this.filterable) {
            this.filterChange.emit(text);
        }
        else {
            this.searchTextAndFocus(text);
        }
        this.searchbar.setInputSize();
    };
    /**
     * @hidden
     */
    MultiSelectComponent.prototype.pageChange = function (event) {
        var virtual = this.virtual;
        virtual.skip = event.skip;
    };
    /**
     * @hidden
     */
    MultiSelectComponent.prototype.clearFilter = function () {
        if (this.filterable && this.text) {
            this.filterChange.emit("");
        }
        this.text = "";
        /* Clearing the value from the input as the setInputSize calculation will be incorrect otherwise.
         Calling cdr.detectChanges to clear the input value as a result of property binding
         causes JAWS to read outdated tag values in IE upon tag selection for some reason. */
        this.searchbar.input.nativeElement.value = "";
        this.searchbar.setInputSize();
    };
    /**
     * @hidden
     */
    MultiSelectComponent.prototype.handleNavigate = function (event) {
        var navigateInput = this.text && event.keyCode !== Keys.ArrowDown && event.keyCode !== Keys.ArrowUp;
        var selectValue = this.text && event.keyCode === Keys.Enter || event.keyCode === Keys.Escape;
        var deleteTag = !this.text && event.keyCode === Keys.Backspace && this.tags.length > 0;
        if (deleteTag) {
            this.handleBackspace();
            return;
        }
        if (this.disabled || navigateInput && !selectValue) {
            return;
        }
        var eventData = event;
        var focused = isNaN(this.selectionService.focused) ? -1 : this.selectionService.focused;
        var action = this.navigationService.process({
            current: focused,
            max: this.dataService.itemsCount - 1,
            min: this.allowCustom && this.text ? -1 : 0,
            open: this.isOpen,
            originalEvent: eventData
        });
        if (action !== NavigationAction.Undefined &&
            ((action === NavigationAction.Enter && this.isOpen) || action !== NavigationAction.Enter)) {
            event.preventDefault();
        }
    };
    /**
     * @hidden
     */
    MultiSelectComponent.prototype.handleRemoveTag = function (_a) {
        var tag = _a.tag;
        var eventArgs = new RemoveTagEvent(tag);
        if (this.disabled || this.readonly) {
            return;
        }
        this.focus();
        this.removeTag.emit(eventArgs);
        if (eventArgs.isDefaultPrevented()) {
            return;
        }
        if (tag instanceof Array) {
            this.removeGroupTag(tag);
        }
        else {
            this.removeSingleTag(tag);
        }
        this.cdr.detectChanges();
    };
    /**
     * @hidden
     */
    MultiSelectComponent.prototype.clearAll = function (event) {
        var _this = this;
        event.stopImmediatePropagation();
        event.preventDefault();
        this.focus();
        this.clearFilter();
        var selected = this.selectionService.selected;
        this.value = this.value.filter(function (_item, index) { return _this.disabledItemsService.isIndexDisabled(selected[index]); });
        this.emitValueChange();
    };
    /**
     * @hidden
     */
    MultiSelectComponent.prototype.addCustomValue = function (text) {
        this.customValueSubject.next(text);
    };
    MultiSelectComponent.prototype.ngAfterContentChecked = function () {
        this.verifySettings();
    };
    MultiSelectComponent.prototype.ngDoCheck = function () {
        var valueChanges = this.differ && this.differ.diff(this.value);
        if (valueChanges && !this.valueChangeDetected) {
            this.setState(this.value);
        }
        this.valueChangeDetected = false;
    };
    MultiSelectComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.renderer.removeAttribute(this.hostElement.nativeElement, "tabindex");
        this.createCustomValueStream();
        this.localizationChangeSubscription = this.localization
            .changes.subscribe(function (_a) {
            var rtl = _a.rtl;
            _this.direction = rtl ? 'rtl' : 'ltr';
            _this.setMessages();
        });
        this.setMessages();
        this.setState(this.value);
        this.initialized = true;
    };
    MultiSelectComponent.prototype.ngOnChanges = function (changes) {
        var virtual = this.virtual;
        var requestInitialData = virtual && changes.data && changes.data.isFirstChange();
        if (requestInitialData) {
            this.pageChange({ skip: 0, take: virtual.pageSize });
        }
        if (isChanged('valueNormalizer', changes)) {
            this.createCustomValueStream();
        }
        if (anyChanged(['textField', 'valueField', 'valuePrimitive'], changes)) {
            this.setState(this.value);
        }
    };
    MultiSelectComponent.prototype.ngAfterViewInit = function () {
        this.searchbar.setInputSize();
    };
    MultiSelectComponent.prototype.ngOnDestroy = function () {
        this._toggle(false);
        this.unsubscribeEvents();
        clearTimeout(this.messagesTimeout);
    };
    /**
     * Toggles the visibility of the popup
     * ([see example]({% slug openstate_multiselect %}#toc-setting-the-initially-opened-component)).
     * If you use the `toggle` method to open or close the popup, the respective `open` and `close` events will not be fired.
     *
     * @param open - The state of the popup.
     */
    MultiSelectComponent.prototype.toggle = function (open) {
        var _this = this;
        // The Promise is required for opening the popup on load.
        // Otherwise, the "Expression has changed..." type error will be thrown.
        Promise.resolve(null).then(function () {
            var shouldOpen = isPresent(open) ? open : !_this._open;
            _this._toggle(shouldOpen);
            _this.cdr.markForCheck();
        });
    };
    Object.defineProperty(MultiSelectComponent.prototype, "isOpen", {
        /**
         * Returns the current open state of the popup.
         */
        get: function () {
            return this._open;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Resets the value of the MultiSelect.
     * If you use the `reset` method to clear the value of the component,
     * the model will not update automatically and the `selectionChange` and `valueChange` events will not be fired.
     */
    MultiSelectComponent.prototype.reset = function () {
        this.text = "";
        this.value = [];
    };
    // NG MODEL BINDINGS
    /**
     * @hidden
     */
    MultiSelectComponent.prototype.writeValue = function (value) {
        this.value = value || [];
    };
    /**
     * @hidden
     */
    MultiSelectComponent.prototype.registerOnChange = function (fn) {
        this.onChangeCallback = fn;
    };
    /**
     * @hidden
     */
    MultiSelectComponent.prototype.registerOnTouched = function (fn) {
        this.onTouchedCallback = fn;
    };
    /**
     * @hidden
     */
    MultiSelectComponent.prototype.setDisabledState = function (isDisabled) {
        this.disabled = isDisabled;
    };
    /**
     * @hidden
     */
    MultiSelectComponent.prototype.onTagMapperChange = function () {
        this.tags = this.tagMapper(this.selectedDataItems.slice(0));
        this.cdr.markForCheck();
    };
    Object.defineProperty(MultiSelectComponent.prototype, "isFocused", {
        get: function () {
            return this._isFocused;
        },
        set: function (isFocused) {
            this.renderer[isFocused ? 'addClass' : 'removeClass'](this.hostElement.nativeElement, 'k-state-focused');
            this._isFocused = isFocused;
        },
        enumerable: true,
        configurable: true
    });
    MultiSelectComponent.prototype.subscribeEvents = function () {
        var _this = this;
        if (!isDocumentAvailable()) {
            return;
        }
        var isOpen = function () { return _this.isOpen; };
        var isClosed = function () { return !_this.isOpen; };
        var isTagFocused = function () { return !_this.isOpen && _this.focusedTagIndex !== undefined; };
        [
            this.selectionService.onChange.subscribe(this.handleItemChange.bind(this)),
            this.navigationService.esc.subscribe(this.closePopup.bind(this)),
            this.navigationService.enter.pipe(filter(isOpen)).subscribe(this.handleEnter.bind(this)),
            this.navigationService.open.subscribe(this.openPopup.bind(this)),
            this.navigationService.close.subscribe(this.handleClose.bind(this)),
            this.navigationService.up.pipe(filter(isOpen)).subscribe(function (event) { return _this.handleUp(event.index); }),
            this.navigationService.home.pipe(filter(function () { return isClosed; })).subscribe(this.handleHome.bind(this)),
            this.navigationService.end.pipe(filter(function () { return isClosed; })).subscribe(this.handleEnd.bind(this)),
            this.navigationService.backspace.pipe(filter(isTagFocused)).subscribe(this.handleBackspace.bind(this)),
            this.navigationService.delete.pipe(filter(isTagFocused)).subscribe(this.handleDelete.bind(this)),
            this.navigationService.left.subscribe(this.direction === 'rtl' ? this.handleRightKey.bind(this) : this.handleLeftKey.bind(this)),
            this.navigationService.right.subscribe(this.direction === 'rtl' ? this.handleLeftKey.bind(this) : this.handleRightKey.bind(this)),
            this.navigationService.down.subscribe(function (event) { return _this.handleDownKey(event.index); })
        ].forEach(function (s) { return _this.observableSubscriptions.add(s); });
    };
    MultiSelectComponent.prototype.subscribeTouchEvents = function () {
        var _this = this;
        if (!isDocumentAvailable() || !this.touchEnabled) {
            return;
        }
        this._zone.runOutsideAngular(function () {
            // Roll up MultiSelect on iOS when tapped outside
            return _this.touchstartDisposeHandler = _this.renderer.listen(document, 'touchstart', function (e) {
                var target = e.target;
                if ((_this.isFocused || _this.isOpen) && !inDropDown(_this.hostElement, target, _this.popupRef)) {
                    _this._zone.run(function () {
                        _this.blur();
                        if (_this.isOpen) {
                            _this.togglePopup(false);
                        }
                    });
                }
            });
        });
    };
    MultiSelectComponent.prototype.unsubscribeEvents = function () {
        if (!isDocumentAvailable()) {
            return;
        }
        this.observableSubscriptions.unsubscribe();
        if (this.customValueSubscription) {
            this.customValueSubscription.unsubscribe();
        }
        if (this.localizationChangeSubscription) {
            this.localizationChangeSubscription.unsubscribe();
        }
        if (this.touchstartDisposeHandler) {
            this.touchstartDisposeHandler();
        }
    };
    MultiSelectComponent.prototype.removeGroupTag = function (dataItems) {
        var _this = this;
        var data = this.dataService.data;
        if (this.dataService.grouped) {
            data = data.filter(function (item) { return !item.header; }).map(function (item) { return item.value; });
        }
        var dataItemValues = new Set(dataItems.map(function (item) { return getter$1(item, _this.valueField); }));
        this.value = this.value.filter(function (value) {
            var index = selectedIndices([value], data, _this.valueField)[0];
            var isDataItemDisabled = _this.disabledItemsService.isIndexDisabled(index);
            return !dataItemValues.has(getter$1(value, _this.valueField)) || isDataItemDisabled;
        });
        this.emitValueChange();
    };
    MultiSelectComponent.prototype.removeSingleTag = function (dataItem) {
        var _this = this;
        var data = this.dataService.data;
        if (this.dataService.grouped) {
            data = data.filter(function (item) { return !item.header; }).map(function (item) { return item.value; });
        }
        var index = selectedIndices([dataItem], data, this.valueField)[0];
        if (this.disabledItemsService.isIndexDisabled(index)) {
            return;
        }
        if (isNumber(index)) {
            this.selectionService.unselect(index);
            this.selectionService.focused = index;
            this.togglePopup(false);
        }
        else { // the deleted item is not present in the source
            var filter_2 = function (item) { return getter$1(item, _this.valueField) !== getter$1(dataItem, _this.valueField); };
            this.value = this.value.filter(filter_2);
            this.emitValueChange();
        }
    };
    /**
     * @hidden
     *
     * Determines which of the provided tags should be disabled and stores their position indices
     */
    MultiSelectComponent.prototype.disabledItemsMapper = function () {
        var _this = this;
        var selected = this.selectionService.selected;
        return new Set(this.selectedDataItems.reduce(function (indices, _item, index) {
            if (_this.disabledItemsService.isIndexDisabled(selected[index])) {
                indices.push(index);
            }
            return indices;
        }, []));
    };
    MultiSelectComponent.prototype.createCustomValueStream = function () {
        var _this = this;
        if (this.customValueSubscription) {
            this.customValueSubscription.unsubscribe();
        }
        this.customValueSubscription = this.customValueSubject.pipe(tap(function () {
            _this.loading = true;
            _this.disabled = true;
            _this.cdr.detectChanges();
        }), this.valueNormalizer, catchError(function () {
            _this.loading = false;
            _this.disabled = false;
            if (_this.autoClose) {
                _this.togglePopup(false);
            }
            if (_this.autoClose || !_this.filterable) {
                _this.clearFilter();
            }
            _this.nextTick(function () {
                _this.searchbar.focus();
            });
            _this.createCustomValueStream();
            return of(null);
        }))
            .subscribe(function (normalizedValue) {
            _this.loading = false;
            _this.disabled = false;
            if (isPresent(normalizedValue)) { // if valueNormalizer returns `null` or `undefined` custom value is discarded
                var newValue_1 = _this.valuePrimitive ? getter$1(normalizedValue, _this.valueField) : normalizedValue;
                var itemIndex = _this.dataService.indexOf(newValue_1);
                var customItem = itemIndex === -1;
                if (_this.value.indexOf(newValue_1) === -1) {
                    _this.tags = _this.tagMapper(_this.selectedDataItems.concat([normalizedValue]));
                    if (!customItem) {
                        _this.selectionService.add(itemIndex);
                    }
                    else {
                        _this.value = _this.value.concat([newValue_1]);
                    }
                }
                else {
                    if (!customItem && _this.selectionService.isSelected(itemIndex)) {
                        _this.selectionService.unselect(itemIndex);
                        _this.selectionService.focused = itemIndex;
                    }
                    else {
                        _this.value = _this.value.filter(function (item) { return getter$1(item, _this.valueField) !== newValue_1; });
                    }
                }
                _this.emitValueChange();
            }
            if (_this.autoClose) {
                _this.togglePopup(false);
            }
            if (_this.autoClose || !_this.filterable) {
                _this.clearFilter();
            }
            _this.nextTick(function () {
                _this.searchbar.focus();
            });
        });
    };
    MultiSelectComponent.prototype.handleItemChange = function (event) {
        this.change(event);
        if (this.autoClose) {
            this.togglePopup(false);
        }
        if (this.autoClose || !this.filterable) {
            this.clearFilter();
        }
    };
    MultiSelectComponent.prototype.handleEnter = function (event) {
        var service = this.selectionService;
        var focusedIndex = this.selectionService.focused;
        if (this.isOpen) {
            event.originalEvent.preventDefault();
        }
        if (focusedIndex === -1) {
            if (this.allowCustom && this.text) {
                this.addCustomValue(this.text);
            }
            return; // Clear filter & close are done at customValueSubscription due to race conditions.
        }
        if (service.isSelected(focusedIndex)) {
            service.unselect(focusedIndex);
            service.focused = focusedIndex;
        }
        else {
            service.add(focusedIndex);
        }
        if (this.autoClose) {
            this.togglePopup(false);
        }
        if (this.autoClose || !this.filterable) {
            this.clearFilter();
        }
    };
    MultiSelectComponent.prototype.handleClose = function () {
        this.closePopup();
        this.searchbar.focus();
    };
    MultiSelectComponent.prototype.handleEnd = function () {
        this.focusedTagIndex = this.tags.length - 1;
    };
    MultiSelectComponent.prototype.handleHome = function () {
        this.focusedTagIndex = 0;
    };
    MultiSelectComponent.prototype.handleUp = function (index) {
        this.selectionService.focused = index;
    };
    MultiSelectComponent.prototype.handleBackspace = function () {
        if (this.focusedTagIndex !== undefined) {
            this.handleDelete();
        }
        else {
            this.handleRemoveTag({ tag: this.tags[this.tags.length - 1] });
            this.searchbar.focus();
        }
    };
    MultiSelectComponent.prototype.handleDelete = function () {
        this.handleRemoveTag({ tag: this.tags[this.focusedTagIndex] });
        if (this.focusedTagIndex === this.tags.length) {
            this.focusedTagIndex = undefined;
        }
    };
    MultiSelectComponent.prototype.handleLeftKey = function () {
        if (this.focusedTagIndex === undefined || this.focusedTagIndex < 0) {
            this.focusedTagIndex = this.tags.length - 1;
        }
        else if (this.focusedTagIndex !== 0) {
            this.focusedTagIndex--;
        }
    };
    MultiSelectComponent.prototype.handleDownKey = function (index) {
        if (this.isOpen) {
            this.selectionService.focused = index || this.firstFocusableIndex(0);
        }
        else {
            this.openPopup();
        }
    };
    MultiSelectComponent.prototype.handleRightKey = function () {
        var last = this.tags.length - 1;
        if (this.focusedTagIndex === last) {
            this.focusedTagIndex = undefined;
        }
        else if (this.focusedTagIndex < last) {
            this.focusedTagIndex++;
        }
    };
    MultiSelectComponent.prototype.findIndex = function (text, startsFrom) {
        var _this = this;
        if (startsFrom === void 0) { startsFrom = 0; }
        var itemText;
        text = text.toLowerCase();
        var index = this.dataService.findIndex(function (item) {
            if (_this.dataService.grouped) {
                itemText = getter$1(item.value, _this.textField);
            }
            else {
                itemText = getter$1(item, _this.textField);
            }
            itemText = !isPresent(itemText) ? "" : itemText.toString().toLowerCase();
            return text && itemText.startsWith(text);
        }, startsFrom);
        if (this.disabledItemsService.isIndexDisabled(index)) {
            return (index + 1 > this.dataService.itemsCount) ? -1 : this.findIndex(text, index + 1);
        }
        else {
            return index;
        }
    };
    MultiSelectComponent.prototype.searchTextAndFocus = function (text) {
        var index = this.findIndex(text);
        this.selectionService.focused = index;
    };
    MultiSelectComponent.prototype.closePopup = function () {
        this.togglePopup(false);
        this.focusedTagIndex = undefined;
    };
    MultiSelectComponent.prototype.openPopup = function () {
        this.togglePopup(true);
        this.focusedTagIndex = undefined;
    };
    MultiSelectComponent.prototype.togglePopup = function (open) {
        var isDisabled = this.disabled || this.readonly;
        var sameState = this.isOpen === open;
        if (isDisabled || sameState) {
            return;
        }
        var isDefaultPrevented = this.triggerPopupEvents(open);
        if (!isDefaultPrevented) {
            this._toggle(open);
        }
    };
    MultiSelectComponent.prototype.triggerPopupEvents = function (open) {
        var eventArgs = new PreventableEvent();
        if (open) {
            this.open.emit(eventArgs);
        }
        else {
            this.close.emit(eventArgs);
        }
        return eventArgs.isDefaultPrevented();
    };
    MultiSelectComponent.prototype._toggle = function (open) {
        this._open = open;
        this.destroyPopup();
        if (this._open) {
            this.createPopup();
        }
    };
    MultiSelectComponent.prototype.destroyPopup = function () {
        if (this.popupRef) {
            this.popupRef.popupElement
                .removeEventListener('mousedown', this.popupMouseDownHandler);
            this.popupRef.close();
            this.popupRef = null;
        }
    };
    MultiSelectComponent.prototype.createPopup = function () {
        var _this = this;
        if (this.virtual) {
            this.virtual.skip = 0;
        }
        var horizontalAlign = this.direction === "rtl" ? "right" : "left";
        var anchorPosition = { horizontal: horizontalAlign, vertical: "bottom" };
        var popupPosition = { horizontal: horizontalAlign, vertical: "top" };
        this.popupRef = this.popupService.open({
            anchor: this.wrapper,
            anchorAlign: anchorPosition,
            animate: this.popupSettings.animate,
            appendTo: this.appendTo,
            content: this.popupTemplate,
            popupAlign: popupPosition,
            popupClass: this.listContainerClasses,
            positionMode: 'absolute'
        });
        var popupWrapper = this.popupRef.popupElement;
        var _a = this.width, min = _a.min, max = _a.max;
        popupWrapper.addEventListener('mousedown', this.popupMouseDownHandler);
        popupWrapper.style.minWidth = min;
        popupWrapper.style.width = max;
        popupWrapper.style.height = this.height;
        popupWrapper.setAttribute("dir", this.direction);
        this.popupRef.popupOpen.subscribe(function () {
            _this.cdr.detectChanges();
            _this.optionsList.scrollToItem(_this.selectionService.focused);
            _this.opened.emit();
        });
        this.popupRef.popupClose.subscribe(function () {
            _this.closed.emit();
        });
        this.popupRef.popupAnchorViewportLeave.subscribe(function () {
            _this.togglePopup(false);
        });
    };
    MultiSelectComponent.prototype.emitValueChange = function () {
        this.onChangeCallback(this.value);
        this.valueChange.emit(this.value);
    };
    MultiSelectComponent.prototype.resolveDataItemFromTags = function (value) {
        var _this = this;
        if (!(this.tags && this.tags.length && isPresent(value))) {
            return undefined;
        }
        // Flattening the tags array in case of a summary tag occurrence.
        var tags = this.tags.reduce(function (acc, tag) {
            var items = isArray(tag) ? tag : [tag];
            acc.push.apply(acc, items);
            return acc;
        }, []);
        return tags.find(function (tag) { return getter$1(tag, _this.valueField) === getter$1(value, _this.valueField); });
    };
    MultiSelectComponent.prototype.firstFocusableIndex = function (index) {
        var maxIndex = this.dataService.itemsCount;
        if (this.disabledItemsService.isIndexDisabled(index)) {
            var nextIndex = index + 1;
            return (nextIndex < maxIndex) ? this.firstFocusableIndex(nextIndex) : undefined;
        }
        else {
            return index;
        }
    };
    MultiSelectComponent.prototype.nextTick = function (f) {
        var _this = this;
        this._zone.runOutsideAngular(function () {
            // Use `setTimeout` instead of a resolved promise
            // because the latter does not wait long enough.
            setTimeout(function () { return _this._zone.run(f); });
        });
    };
    MultiSelectComponent.prototype.setMessages = function () {
        var _this = this;
        this._zone.runOutsideAngular(function () {
            clearTimeout(_this.messagesTimeout);
            _this.messagesTimeout = setTimeout(function () {
                _this.noDataText = _this.localization.get('noDataText');
                _this.cdr.detectChanges();
            });
        });
    };
    var MultiSelectComponent_1;
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], MultiSelectComponent.prototype, "focusableId", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], MultiSelectComponent.prototype, "autoClose", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], MultiSelectComponent.prototype, "loading", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array),
        __metadata("design:paramtypes", [Array])
    ], MultiSelectComponent.prototype, "data", null);
    __decorate([
        Input(),
        __metadata("design:type", Array),
        __metadata("design:paramtypes", [Array])
    ], MultiSelectComponent.prototype, "value", null);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], MultiSelectComponent.prototype, "valueField", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], MultiSelectComponent.prototype, "textField", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], MultiSelectComponent.prototype, "tabindex", void 0);
    __decorate([
        Input("tabIndex"),
        __metadata("design:type", Number),
        __metadata("design:paramtypes", [Number])
    ], MultiSelectComponent.prototype, "tabIndex", null);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], MultiSelectComponent.prototype, "placeholder", null);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], MultiSelectComponent.prototype, "disabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Function])
    ], MultiSelectComponent.prototype, "itemDisabled", null);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], MultiSelectComponent.prototype, "checkboxes", null);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], MultiSelectComponent.prototype, "readonly", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], MultiSelectComponent.prototype, "filterable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], MultiSelectComponent.prototype, "virtual", null);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], MultiSelectComponent.prototype, "popupSettings", null);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], MultiSelectComponent.prototype, "listHeight", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], MultiSelectComponent.prototype, "valuePrimitive", null);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], MultiSelectComponent.prototype, "clearButton", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], MultiSelectComponent.prototype, "tagMapper", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], MultiSelectComponent.prototype, "allowCustom", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], MultiSelectComponent.prototype, "valueNormalizer", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MultiSelectComponent.prototype, "filterChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MultiSelectComponent.prototype, "valueChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MultiSelectComponent.prototype, "open", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MultiSelectComponent.prototype, "opened", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MultiSelectComponent.prototype, "close", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MultiSelectComponent.prototype, "closed", void 0);
    __decorate([
        Output('focus'),
        __metadata("design:type", EventEmitter)
    ], MultiSelectComponent.prototype, "onFocus", void 0);
    __decorate([
        Output('blur'),
        __metadata("design:type", EventEmitter)
    ], MultiSelectComponent.prototype, "onBlur", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MultiSelectComponent.prototype, "removeTag", void 0);
    __decorate([
        ViewChild('container', { read: ViewContainerRef, static: true }),
        __metadata("design:type", ViewContainerRef)
    ], MultiSelectComponent.prototype, "container", void 0);
    __decorate([
        ViewChild(SearchBarComponent, { static: true }),
        __metadata("design:type", SearchBarComponent)
    ], MultiSelectComponent.prototype, "searchbar", void 0);
    __decorate([
        ViewChild('popupTemplate', { static: true }),
        __metadata("design:type", TemplateRef)
    ], MultiSelectComponent.prototype, "popupTemplate", void 0);
    __decorate([
        ViewChild('wrapper', { static: true }),
        __metadata("design:type", ElementRef)
    ], MultiSelectComponent.prototype, "wrapper", void 0);
    __decorate([
        ViewChild('optionsList', { static: false }),
        __metadata("design:type", ListComponent)
    ], MultiSelectComponent.prototype, "optionsList", void 0);
    __decorate([
        ContentChild(ItemTemplateDirective, { static: false }),
        __metadata("design:type", ItemTemplateDirective)
    ], MultiSelectComponent.prototype, "template", void 0);
    __decorate([
        ContentChild(CustomItemTemplateDirective, { static: false }),
        __metadata("design:type", CustomItemTemplateDirective)
    ], MultiSelectComponent.prototype, "customItemTemplate", void 0);
    __decorate([
        ContentChild(GroupTemplateDirective, { static: false }),
        __metadata("design:type", GroupTemplateDirective)
    ], MultiSelectComponent.prototype, "groupTemplate", void 0);
    __decorate([
        ContentChild(FixedGroupTemplateDirective, { static: false }),
        __metadata("design:type", FixedGroupTemplateDirective)
    ], MultiSelectComponent.prototype, "fixedGroupTemplate", void 0);
    __decorate([
        ContentChild(HeaderTemplateDirective, { static: false }),
        __metadata("design:type", HeaderTemplateDirective)
    ], MultiSelectComponent.prototype, "headerTemplate", void 0);
    __decorate([
        ContentChild(FooterTemplateDirective, { static: false }),
        __metadata("design:type", FooterTemplateDirective)
    ], MultiSelectComponent.prototype, "footerTemplate", void 0);
    __decorate([
        ContentChild(TagTemplateDirective, { static: false }),
        __metadata("design:type", TagTemplateDirective)
    ], MultiSelectComponent.prototype, "tagTemplate", void 0);
    __decorate([
        ContentChild(GroupTagTemplateDirective, { static: false }),
        __metadata("design:type", GroupTagTemplateDirective)
    ], MultiSelectComponent.prototype, "groupTagTemplate", void 0);
    __decorate([
        ContentChild(NoDataTemplateDirective, { static: false }),
        __metadata("design:type", NoDataTemplateDirective)
    ], MultiSelectComponent.prototype, "noDataTemplate", void 0);
    __decorate([
        HostBinding('class.k-widget'),
        HostBinding('class.k-multiselect'),
        __metadata("design:type", Boolean)
    ], MultiSelectComponent.prototype, "widgetClasses", void 0);
    __decorate([
        HostBinding('attr.dir'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], MultiSelectComponent.prototype, "dir", null);
    __decorate([
        HostBinding('class.k-state-disabled'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], MultiSelectComponent.prototype, "disabledClass", null);
    MultiSelectComponent = MultiSelectComponent_1 = __decorate([
        Component({
            exportAs: 'kendoMultiSelect',
            providers: [
                MULTISELECT_VALUE_ACCESSOR,
                DataService,
                SelectionService,
                NavigationService,
                DisabledItemsService,
                LocalizationService,
                {
                    provide: L10N_PREFIX,
                    useValue: 'kendo.multiselect'
                },
                {
                    provide: FilterableComponent, useExisting: forwardRef(function () { return MultiSelectComponent_1; })
                },
                {
                    provide: KendoInput, useExisting: forwardRef(function () { return MultiSelectComponent_1; })
                }
            ],
            selector: 'kendo-multiselect',
            template: "\n        <ng-container kendoMultiSelectLocalizedMessages\n            i18n-noDataText=\"kendo.multiselect.noDataText|The text displayed in the popup when there are no items\"\n            noDataText=\"NO DATA FOUND\"\n\n            i18n-clearTitle=\"kendo.combobox.clearTitle|The title of the clear button\"\n            clearTitle=\"clear\"\n        >\n        </ng-container>\n        <div class=\"k-multiselect-wrap k-floatwrap\"\n            #wrapper\n            (mousedown)=\"wrapperMousedown($event)\"\n        >\n            <kendo-taglist\n                [id]=\"tagListId\"\n                [tags]=\"tags\"\n                [textField]=\"textField\"\n                [valueField]=\"valueField\"\n                [focused]=\"focusedTagIndex\"\n                [disabled]=\"disabled\"\n                [template]=\"tagTemplate\"\n                [groupTemplate]=\"groupTagTemplate\"\n                [tagPrefix]=\"tagPrefix\"\n                [disabledIndices]=\"disabledIndices\"\n                (removeTag)=\"handleRemoveTag($event)\"\n            >\n            </kendo-taglist>\n            <kendo-searchbar\n                #searchbar\n                [id]=\"focusableId\"\n                [role]=\"'listbox'\"\n                [tagListId]=\"tagListId\"\n                [activeDescendant]=\"activeDescendant\"\n                [noDataLabel]=\"noDataLabel\"\n                [userInput]=\"text\"\n                [disabled]=\"disabled\"\n                [readonly]=\"readonly\"\n                [tabIndex]=\"tabIndex\"\n                [popupOpen]=\"isOpen\"\n                [placeholder]=\"placeholder\"\n                (onNavigate)=\"handleNavigate($event)\"\n                (valueChange)=\"handleFilter($event)\"\n                (onBlur)=\"onSearchBarBlur()\"\n                (onFocus)=\"onSearchBarFocus()\"\n            >\n            </kendo-searchbar>\n            <span\n                *ngIf=\"!loading && !readonly && clearButton && (tags?.length || text?.length)\"\n                class=\"k-icon k-clear-value k-i-close\"\n                [style.visibility]=\"clearButtonVisiblity\"\n                [attr.title]=\"clearTitle\"\n                role=\"button\"\n                tabindex=\"-1\"\n                (mousedown)=\"clearAll($event)\"\n            >\n            </span>\n            <span\n                *ngIf=\"loading\"\n                class=\"k-icon k-i-loading\"\n            >\n            </span>\n        </div>\n        <ng-template #popupTemplate>\n            <!--header template-->\n            <ng-template *ngIf=\"headerTemplate\"\n                [templateContext]=\"{\n                    templateRef: headerTemplate.templateRef\n                }\">\n            </ng-template>\n            <!--custom item template-->\n            <div class=\"k-list\" *ngIf=\"allowCustom && text\">\n                <div class=\"k-item k-custom-item\" kendoDropDownsSelectable [multipleSelection]=\"true\" [index]=\"-1\">\n                    <ng-template *ngIf=\"customItemTemplate;else default_custom_item_template\"\n                        [templateContext]=\"{\n                            templateRef: customItemTemplate.templateRef,\n                            $implicit: text\n                        }\">\n                    </ng-template>\n                    <ng-template #default_custom_item_template>{{ text }}</ng-template>\n                    <span class=\"k-icon k-i-plus\" style=\"float: right\"></span>\n                </div>\n            </div>\n            <!--list-->\n            <kendo-list\n                #optionsList\n                [id]=\"listBoxId\"\n                [optionPrefix]=\"optionPrefix\"\n                [data]=\"data\"\n                [textField]=\"textField\"\n                [valueField]=\"valueField\"\n                [height]=\"listHeight\"\n                [template]=\"template\"\n                [groupTemplate]=\"groupTemplate\"\n                [fixedGroupTemplate]=\"fixedGroupTemplate\"\n                [show]=\"isOpen\"\n                [multipleSelection]=\"true\"\n                [virtual]=\"virtual\"\n                (pageChange)=\"pageChange($event)\"\n                [checkboxes]=\"checkboxes\"\n                >\n            </kendo-list>\n            <!--no data template-->\n            <div class=\"k-nodata\" *ngIf=\"data.length === 0\">\n                <ng-template [ngIf]=\"noDataTemplate\"\n                    [templateContext]=\"{\n                        templateRef: noDataTemplate ? noDataTemplate.templateRef : undefined\n                    }\">\n                </ng-template>\n                <ng-template [ngIf]=\"!noDataTemplate\">\n                    <div>{{ noDataText }}</div>\n                </ng-template>\n            </div>\n            <!--footer template-->\n            <ng-template *ngIf=\"footerTemplate\"\n                [templateContext]=\"{\n                    templateRef: footerTemplate.templateRef\n                }\">\n            </ng-template>\n        </ng-template>\n        <ng-template [ngIf]=\"isOpen\">\n            <kendo-resize-sensor (resize)=\"onResize()\"></kendo-resize-sensor>\n        </ng-template>\n        <ng-container #container></ng-container>\n  "
        }),
        __param(11, Optional()), __param(11, Inject(TOUCH_ENABLED)),
        __metadata("design:paramtypes", [LocalizationService,
            PopupService,
            DataService,
            SelectionService,
            NavigationService,
            DisabledItemsService,
            ChangeDetectorRef,
            KeyValueDiffers,
            Renderer2,
            ElementRef,
            NgZone, Boolean])
    ], MultiSelectComponent);
    return MultiSelectComponent;
}());

/**
 * Renders the column cell content of the MultiColumnComboBox. To define a column cell template, nest an `<ng-template>` tag
 * with the `kendoMultiColumnComboBoxColumnCellTemplate` directive inside the [`<kendo-combobox-column>`]({% slug api_dropdowns_comboboxcolumncomponent %}) tag
 * ([see example]({% slug templates_multicolumncombobox %})).
 *
 * The current [`column`]({% slug api_dropdowns_comboboxcolumncomponent %}) and data item are available as context variables:
 *
 * - `let-dataItem="dataItem"` (`any`) - The current data item. Also available as implicit context variable.
 * - `let-column="column"` ([`ColumnComponent`]({% slug api_dropdowns_comboboxcolumncomponent %})) - The current column configuration obejct.
 */
var ColumnCellTemplateDirective = /** @class */ (function () {
    function ColumnCellTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    ColumnCellTemplateDirective = __decorate([
        Directive({
            selector: '[kendoMultiColumnComboBoxColumnCellTemplate]'
        }),
        __metadata("design:paramtypes", [TemplateRef])
    ], ColumnCellTemplateDirective);
    return ColumnCellTemplateDirective;
}());

/**
 * Renders the column header content of the MultiColumnComboBox. To define a column header template, nest an `<ng-template>` tag
 * with the `kendoMultiColumnComboBoxColumnHeaderTemplate` directive inside the [`<kendo-combobox-column>`]({% slug api_dropdowns_comboboxcolumncomponent %}) tag
 * ([see example]({% slug templates_multicolumncombobox %})).
 *
 * The current [`column`]({% slug api_dropdowns_comboboxcolumncomponent %}) is available as implicit context variable.
 */
var ColumnHeaderTemplateDirective = /** @class */ (function () {
    function ColumnHeaderTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    ColumnHeaderTemplateDirective = __decorate([
        Directive({
            selector: '[kendoMultiColumnComboBoxColumnHeaderTemplate]'
        }),
        __metadata("design:paramtypes", [TemplateRef])
    ], ColumnHeaderTemplateDirective);
    return ColumnHeaderTemplateDirective;
}());

/**
 * Represents the column definition of the [MultiColumnComboBox]({% slug overview_multicolumncombobox %})
 * ([see example]({% slug columns_multicolumncombobox %})).
 */
var ComboBoxColumnComponent = /** @class */ (function () {
    function ComboBoxColumnComponent() {
        /**
         * Sets the visibility of the column.
         *
         * @default false
         */
        this.hidden = false;
        /**
         * @hidden
         */
        this.matchesMedia = true;
    }
    __decorate([
        ContentChild(ColumnCellTemplateDirective, { static: false }),
        __metadata("design:type", ColumnCellTemplateDirective)
    ], ComboBoxColumnComponent.prototype, "cellTemplate", void 0);
    __decorate([
        ContentChild(ColumnHeaderTemplateDirective, { static: false }),
        __metadata("design:type", ColumnHeaderTemplateDirective)
    ], ComboBoxColumnComponent.prototype, "headerTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ComboBoxColumnComponent.prototype, "field", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ComboBoxColumnComponent.prototype, "title", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], ComboBoxColumnComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], ComboBoxColumnComponent.prototype, "hidden", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ComboBoxColumnComponent.prototype, "style", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ComboBoxColumnComponent.prototype, "headerStyle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ComboBoxColumnComponent.prototype, "class", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ComboBoxColumnComponent.prototype, "headerClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ComboBoxColumnComponent.prototype, "media", void 0);
    ComboBoxColumnComponent = __decorate([
        Component({
            selector: 'kendo-combobox-column',
            template: ''
        })
    ], ComboBoxColumnComponent);
    return ComboBoxColumnComponent;
}());

/**
 * Persists the intially resolved scrollbar width value.
 */
var SCROLLBAR_WIDTH;
/**
 * @hidden
 *
 * Gets the default scrollbar width accoring to the current environment.
 */
var scrollbarWidth = function () {
    // calculate scrollbar width only once, then return the memoized value
    if (isNaN(SCROLLBAR_WIDTH)) {
        var div = document.createElement('div');
        div.style.cssText = 'overflow: scroll; overflow-x: hidden; zoom: 1; clear: both; display: block;';
        div.innerHTML = '&nbsp;';
        document.body.appendChild(div);
        SCROLLBAR_WIDTH = div.offsetWidth - div.scrollWidth;
        document.body.removeChild(div);
    }
    return SCROLLBAR_WIDTH;
};
/**
 * Checks if all columns have a valid user-defined width.
 */
var allColumnsWidthsSet = function (columns) {
    if (!isPresent(columns) || columns.length === 0) {
        return false;
    }
    return columns.toArray().every(function (column) { return !isNaN(column.width) && column.width > 0; });
};
/**
 * @hidden
 *
 * Calculates the row width according to the passed columns width configuration.
 * Hidden columns and such that don't match the provided media query are ignored.
 * If some of the columns don't have a preset width or have an invalid width value, the function returns `null`.
 */
var getRowWidthFromColumnsMeta = function (columns) {
    if (!allColumnsWidthsSet(columns)) {
        return null;
    }
    var bordersWidth = 2;
    var initialRowWidht = scrollbarWidth() + bordersWidth;
    return columns.reduce(function (totalWidth, column) {
        if (!column.hidden && column.matchesMedia) {
            totalWidth += parseInt(column.width, 10);
        }
        return totalWidth;
    }, initialRowWidht);
};

/**
 * Represents the [Kendo UI MultiColumnComboBox component for Angular]({% slug overview_multicolumncombobox %}).
 */
var MultiColumnComboBoxComponent = /** @class */ (function (_super) {
    __extends(MultiColumnComboBoxComponent, _super);
    function MultiColumnComboBoxComponent(localization, popupService, selectionService, navigationService, disabledItemsService, dataService, zone, changeDetector, renderer, hostElement, touchEnabled$$1) {
        var _this = _super.call(this, localization, popupService, selectionService, navigationService, disabledItemsService, dataService, zone, changeDetector, renderer, hostElement, touchEnabled$$1) || this;
        /**
         * @hidden
         */
        _this.hostClasses = true;
        _this.removeWindowResizeListener = noop;
        // the row height in @progress/kendo-theme-default
        _this.defaultVirtualItemHeight = 36;
        // use a smaller virtual page size as columns with multiple cells can cause poor performance
        _this.defaultVirtualPageSize = 30;
        return _this;
    }
    MultiColumnComboBoxComponent_1 = MultiColumnComboBoxComponent;
    Object.defineProperty(MultiColumnComboBoxComponent.prototype, "header", {
        /**
         * @hidden
         */
        set: function (header) {
            // updates the header padding on initial render as the resize senzor doesn't kick in as early
            this.updateHeaderPadding(header && header.nativeElement);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiColumnComboBoxComponent.prototype, "popupWidth", {
        get: function () {
            var wrapperOffsetWidth = this.wrapper.nativeElement.offsetWidth;
            var min = wrapperOffsetWidth + "px";
            var width = this.popupSettings.width || getRowWidthFromColumnsMeta(this.columns) || wrapperOffsetWidth;
            var max = isNaN(width) ? width : width + "px";
            return { min: min, max: max };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiColumnComboBoxComponent.prototype, "listContainerClasses", {
        /**
         * @hidden
         */
        get: function () {
            return [
                'k-list-container',
                'k-popup',
                'k-reset',
                'k-group',
                'k-dropdowngrid-popup',
                'k-popup-flush',
                'k-state-border-up'
            ].concat(this.popupSettings.popupClass || []);
        },
        enumerable: true,
        configurable: true
    });
    MultiColumnComboBoxComponent.prototype.ngAfterViewInit = function () {
        this.updateColumnsMediaState();
        this.addWindowResizeListener();
    };
    MultiColumnComboBoxComponent.prototype.ngOnDestroy = function () {
        _super.prototype.ngOnDestroy.call(this);
        this.removeWindowResizeListener();
    };
    /**
     * @hidden
     */
    MultiColumnComboBoxComponent.prototype.textFrom = function (dataItem, field) {
        return getter$1(dataItem, field);
    };
    /**
     * @hidden
     *
     * Adds or removes a padding value at the end of the header container equal to the size of the scrollbar.
     * As when the items container has a scrollbar, the column headers and the cells are misaligned.
     * When the container has a scrollbar, the padding style is added, and when there is none - it is removed.
     */
    MultiColumnComboBoxComponent.prototype.updateHeaderPadding = function (header) {
        if (!isPresent(header)) {
            return;
        }
        // the scrollbar is rendered on the left in rtl
        var headerPaddingPosition = this.localization.rtl ? 'padding-left' : 'padding-right';
        if (this.optionsList.hasScrollbar() && scrollbarWidth() > 0) {
            this.renderer.setStyle(header, headerPaddingPosition, scrollbarWidth() + "px");
        }
        else {
            this.renderer.removeStyle(header, headerPaddingPosition);
        }
    };
    MultiColumnComboBoxComponent.prototype.verifySettings = function () {
        if (!isDevMode()) {
            return;
        }
        if (isPresent(this.data) && this.data.length > 0 && this.data.some(function (item) { return !isObject(item); })) {
            throw new Error(MultiColumnComboBoxMessages.data);
        }
        if (!isPresent(this.valueField) || !isPresent(this.textField)) {
            throw new Error(MultiColumnComboBoxMessages.textAndValue);
        }
        _super.prototype.verifySettings.call(this);
    };
    MultiColumnComboBoxComponent.prototype.addWindowResizeListener = function () {
        var _this = this;
        if (!isDocumentAvailable()) {
            return;
        }
        this.zone.runOutsideAngular(function () {
            return _this.removeWindowResizeListener = _this.renderer.listen(window, 'resize', _this.updateColumnsMediaState.bind(_this));
        });
    };
    MultiColumnComboBoxComponent.prototype.updateColumnsMediaState = function () {
        var _this = this;
        if (!(isPresent(this.columns) && isDocumentAvailable())) {
            return;
        }
        this.columns.forEach(function (column) {
            var matchesMedia = !column.media || window.matchMedia(column.media).matches;
            if (column.matchesMedia !== matchesMedia) {
                column.matchesMedia = matchesMedia;
                if (_this.isOpen) {
                    // enter the zone only if the popup is actually open
                    // update its width in case it's dependent on the columns' width
                    _this.zone.run(function () { return _this.popupRef.popupElement.style.width = _this.popupWidth.max; });
                }
            }
        });
    };
    var MultiColumnComboBoxComponent_1;
    __decorate([
        HostBinding('class.k-dropdowngrid'),
        __metadata("design:type", Boolean)
    ], MultiColumnComboBoxComponent.prototype, "hostClasses", void 0);
    __decorate([
        ContentChildren(ComboBoxColumnComponent),
        __metadata("design:type", QueryList)
    ], MultiColumnComboBoxComponent.prototype, "columns", void 0);
    __decorate([
        ViewChild('header', { static: false }),
        __metadata("design:type", ElementRef),
        __metadata("design:paramtypes", [ElementRef])
    ], MultiColumnComboBoxComponent.prototype, "header", null);
    MultiColumnComboBoxComponent = MultiColumnComboBoxComponent_1 = __decorate([
        Component({
            providers: [
                SelectionService,
                DataService,
                NavigationService,
                DisabledItemsService,
                LocalizationService,
                {
                    provide: L10N_PREFIX,
                    useValue: 'kendo.multicolumncombobox'
                },
                {
                    multi: true,
                    provide: NG_VALUE_ACCESSOR,
                    useExisting: forwardRef(function () { return MultiColumnComboBoxComponent_1; })
                },
                {
                    provide: KendoInput,
                    useExisting: forwardRef(function () { return MultiColumnComboBoxComponent_1; })
                },
                {
                    provide: FilterableComponent,
                    useExisting: forwardRef(function () { return MultiColumnComboBoxComponent_1; })
                }
            ],
            selector: 'kendo-multicolumncombobox',
            template: "\n        <ng-container\n            kendoMultiColumnComboBoxLocalizedMessages\n\n            i18n-noDataText=\"kendo.multicolumncombobox.noDataText|The text displayed in the popup when there are no items\"\n            noDataText=\"NO DATA FOUND\"\n\n            i18n-clearTitle=\"kendo.multicolumncombobox.clearTitle|The title of the clear button\"\n            clearTitle=\"clear\"\n        >\n        </ng-container>\n        <span\n            #wrapper\n            unselectable=\"on\"\n            class=\"k-dropdown-wrap\"\n            [class.k-state-disabled]=\"disabled\"\n        >\n            <kendo-searchbar\n                #searchbar\n                [role]=\"'combobox'\"\n                [id]=\"focusableId\"\n                [listId]=\"listBoxId\"\n                [activeDescendant]=\"activeDescendant\"\n                [noDataLabel]=\"noDataLabel\"\n                [userInput]=\"text\"\n                [suggestedText]=\"getSuggestion()\"\n                [disabled]=\"disabled\"\n                [readonly]=\"readonly\"\n                [tabIndex]=\"tabIndex\"\n                [popupOpen]=\"isOpen\"\n                [placeholder]=\"placeholder\"\n                (onNavigate)=\"handleNavigate($event)\"\n                (valueChange)=\"searchBarChange($event)\"\n                (onBlur)=\"handleBlur()\"\n                (onFocus)=\"handleFocus()\"\n            >\n            </kendo-searchbar>\n\n            <span\n                *ngIf=\"clearButton && !loading && !disabled && !readonly && text?.length\"\n                class=\"k-icon k-clear-value k-i-close\"\n                [style.visibility]=\"clearButtonVisiblity\"\n                aria-hidden=\"true\"\n                [attr.title]=\"clearTitle\"\n                (click)=\"clearValue($event)\"\n                [kendoEventsOutsideAngular]=\"{\n                    mousedown: preventEventDefault\n                }\"\n            >\n            </span>\n\n            <span\n                #select\n                aria-hidden=\"true\"\n                unselectable=\"on\"\n                class=\"k-select\"\n                [kendoEventsOutsideAngular]=\"{\n                    mousedown: preventEventDefault\n                }\"\n            >\n                <span\n                    class=\"k-icon\"\n                    [ngClass]=\"buttonClasses\"\n                >\n                </span>\n            </span>\n        </span>\n\n        <ng-template #popupTemplate>\n            <!--user-defined header template -->\n            <ng-template\n                *ngIf=\"headerTemplate\"\n                [templateContext]=\"{\n                    templateRef: headerTemplate?.templateRef\n                }\"\n            >\n            </ng-template>\n\n            <!--grid header-->\n            <div\n                #header\n                class=\"k-grid-header\"\n            >\n                <div class=\"k-grid-header-wrap\">\n                    <table role=\"presentation\">\n                        <colgroup>\n                            <ng-container *ngFor=\"let column of columns\">\n                                <col\n                                    *ngIf=\"!column.hidden && column.matchesMedia\"\n                                    [style.width.px]=\"column.width\"\n                                />\n                            </ng-container>\n                        </colgroup>\n                        <tbody>\n                            <tr>\n                                <ng-container *ngFor=\"let column of columns\">\n                                    <th\n                                        *ngIf=\"!column.hidden && column.matchesMedia\"\n                                        class=\"k-header\"\n                                        [ngStyle]=\"column.headerStyle\"\n                                        [ngClass]=\"column.headerClass\"\n                                    >\n                                        <ng-container *ngIf=\"!column.headerTemplate\">\n                                            {{ column.title || column.field }}\n                                        </ng-container>\n                                        <ng-template\n                                            *ngIf=\"column.headerTemplate\"\n                                            [templateContext]=\"{\n                                                templateRef: column.headerTemplate?.templateRef,\n                                                $implicit: column,\n                                                column: column\n                                            }\"\n                                        >\n                                        </ng-template>\n                                    </th>\n                                </ng-container>\n                            </tr>\n                        </tbody>\n                    </table>\n                </div>\n            </div>\n\n            <!-- item template -->\n            <ng-template #rowTemplate let-dataItem>\n                <ng-container *ngFor=\"let column of columns\">\n                    <span\n                        *ngIf=\"!column.hidden && column.matchesMedia\"\n                        class=\"k-cell\"\n                        [ngClass]=\"column.class\"\n                        [style.width.px]=\"column.width\"\n                        [ngStyle]=\"column.style\"\n                    >\n                        <ng-container *ngIf=\"!column.cellTemplate\">\n                            {{ textFrom(dataItem, column.field) }}\n                        </ng-container>\n                        <ng-template\n                            *ngIf=\"column.cellTemplate\"\n                            [templateContext]=\"{\n                                templateRef: column.cellTemplate?.templateRef,\n                                $implicit: dataItem,\n                                dataItem: dataItem,\n                                column: column\n                            }\"\n                        >\n                        </ng-template>\n                    </span>\n                </ng-container>\n            </ng-template>\n\n            <!--list-->\n            <kendo-list\n                #optionsList\n                [id]=\"listBoxId\"\n                [optionPrefix]=\"optionPrefix\"\n                [data]=\"data\"\n                [textField]=\"textField\"\n                [valueField]=\"valueField\"\n                [template]=\"{ templateRef: rowTemplate }\"\n                [groupTemplate]=\"groupTemplate\"\n                [fixedGroupTemplate]=\"fixedGroupTemplate\"\n                [height]=\"listHeight\"\n                [show]=\"isOpen\"\n                [virtual]=\"virtual\"\n                [listClass]=\"'k-reset k-grid-list'\"\n                (pageChange)=\"pageChange($event)\"\n                (listResize)=\"updateHeaderPadding(header)\"\n            >\n            </kendo-list>\n\n            <!--no-data template-->\n            <div\n                class=\"k-nodata\"\n                *ngIf=\"data.length === 0\"\n            >\n                <ng-template\n                    [ngIf]=\"noDataTemplate\"\n                    [templateContext]=\"{\n                        templateRef: noDataTemplate?.templateRef\n                    }\"\n                >\n                </ng-template>\n                <ng-template [ngIf]=\"!noDataTemplate\">\n                    <div>{{ noDataText }}</div>\n                </ng-template>\n            </div>\n\n            <!--user-defined footer template-->\n            <ng-container *ngIf=\"footerTemplate\">\n                <div class=\"k-footer\">\n                    <ng-template\n                        [templateContext]=\"{\n                            templateRef: footerTemplate.templateRef\n                        }\"\n                    >\n                    </ng-template>\n                </div>\n            </ng-container>\n        </ng-template>\n\n        <kendo-resize-sensor\n            *ngIf=\"isOpen\"\n            (resize)=\"onResize()\"\n        >\n        </kendo-resize-sensor>\n\n        <!-- when the popupSettings.appendTo value is set to 'component', this container is used -->\n        <ng-container #container></ng-container>\n    "
        }),
        __param(10, Inject(TOUCH_ENABLED)),
        __metadata("design:paramtypes", [LocalizationService,
            PopupService,
            SelectionService,
            NavigationService,
            DisabledItemsService,
            DataService,
            NgZone,
            ChangeDetectorRef,
            Renderer2,
            ElementRef, Boolean])
    ], MultiColumnComboBoxComponent);
    return MultiColumnComboBoxComponent;
}(ComboBoxComponent));

/**
 * Renders the content of each node in the DropDownTree. To define a node template, nest an `<ng-template>` tag
 * with the `kendoDropDownTreeNodeTemplate` directive inside the `<kendo-dropdowntree>` tag.
 *
 * The current data item and hierarchical index are available as context variables:
 *
 * - `let-dataItem` (`any`) - The current data item. Available as implicit context variable.
 * - `let-index="index"` (`string`) - The current item hierarchical index.
 */
var NodeTemplateDirective = /** @class */ (function () {
    function NodeTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    NodeTemplateDirective = __decorate([
        Directive({
            selector: '[kendoDropDownTreeNodeTemplate], [kendoMultiSelectTreeNodeTemplate]'
        }),
        __metadata("design:paramtypes", [TemplateRef])
    ], NodeTemplateDirective);
    return NodeTemplateDirective;
}());

/* tslint:disable:member-ordering */
var DEFAULT_POPUP_SETTINGS = { animate: true };
var hasChildren = function () { return false; };
var fetchChildren = function () { return of([]); };
var itemDisabled = function () { return false; };
var isNodeVisible = function () { return true; };
/**
 * Represents the [Kendo UI DropDownTree component for Angular]({% slug overview_ddt %}).
 */
var DropDownTreeComponent = /** @class */ (function () {
    function DropDownTreeComponent(popupService, navigationService, renderer, hostElement, _zone, cdr, localization, touchEnabled$$1) {
        this.popupService = popupService;
        this.navigationService = navigationService;
        this.renderer = renderer;
        this.hostElement = hostElement;
        this._zone = _zone;
        this.cdr = cdr;
        this.localization = localization;
        this.touchEnabled = touchEnabled$$1;
        this.hostClasses = true;
        /**
         * Fires each time the popup is about to open
         * ([see example]({% slug openstate_ddt %})).
         * This event is preventable. If you cancel it, the popup will remain closed.
         */
        this.open = new EventEmitter();
        /**
         * Fires after the popup has been opened.
         */
        this.opened = new EventEmitter();
        /**
         * Fires each time the popup is about to close
         * ([see example]({% slug openstate_ddt %})).
         * This event is preventable. If you cancel it, the popup will remain open.
         */
        this.close = new EventEmitter();
        /**
         * Fires after the popup has been closed.
         */
        this.closed = new EventEmitter();
        /**
         * Fires when the user expands a node in the popup TreeView.
         */
        this.nodeExpand = new EventEmitter();
        /**
         * Fires when the user collapses a node in the popup TreeView.
         */
        this.nodeCollapse = new EventEmitter();
        /**
         * Fires each time the user focuses the DropDownTree.
         */
        this.onFocus = new EventEmitter();
        /**
         * Fires each time the DropDownTree gets blurred.
         */
        this.onBlur = new EventEmitter();
        /**
         * Fires each time the value is changed
         * ([see example]({% slug overview_ddt %}#toc-events)).
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires when the value of the built-in filter input element changes.
         */
        this.filterChange = new EventEmitter();
        /**
         * If set to `true`, renders a button on hovering over the component.
         * Clicking this button resets the value of the component to `undefined` and triggers the `change` event.
         */
        this.clearButton = true;
        /**
         * A function which determines if a specific node has child nodes.
         */
        this.hasChildren = hasChildren;
        /**
         * A function which provides the child nodes for a given parent node.
         */
        this.fetchChildren = fetchChildren;
        /**
         * The hint which is displayed when the component is empty.
         */
        this.placeholder = "";
        /**
         * Sets the height of the options list. By default, `listHeight` is 200px.
         *
         * > The `listHeight` property affects only the list of options and not the whole popup container.
         * > To set the height of the popup container, use `popupSettings.height`.
         */
        this.listHeight = 200;
        /**
         * Sets the disabled state of the component.
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the component.
         */
        this.readonly = false;
        /**
         * Specifies the type of the selected value
         * ([more information and example]({% slug valuebinding_ddt %}#toc-primitive-values)).
         * If set to `true`, the selected value has to be of a primitive value.
         */
        this.valuePrimitive = false;
        /**
         * A function that is executed for each data item and determines if a specific item is disabled.
         */
        this.itemDisabled = itemDisabled;
        /**
         * A callback which determines whether a tree node should be rendered as hidden. The utility .k-display-none class is used to hide the nodes.
         * Useful for custom filtering implementations.
         */
        this.isNodeVisible = isNodeVisible;
        /**
         * Indicates whether the child nodes will be fetched on node expand or will be initially prefetched.
         * @default true
         */
        this.loadOnDemand = true;
        /**
         * Renders the built-in input element for filtering the DropDownTree.
         * If set to `true`, the component emits the `filterChange` event, which can be used to [filter the DropDownTree manually]({% slug filtering_ddt %}#toc-manual-filtering).
         * A built-in filtering implementation is available to use with the [`kendoDropDownTreeHierarchyBinding`]({% slug api_dropdowns_dropdowntreehierarchybindingdirective %}) and [`kendoDropDownTreeFlatBinding`]({% slug api_dropdowns_dropdowntreeflatbindingdirective %}) directives.
         */
        this.filterable = false;
        /**
         * @hidden
         */
        this.filter = '';
        /**
         * @hidden
         *
         * Used by the kendo-label and kendo-floatinglabel to access and associate the focusable element with the provided label via aria-labelledby.
         */
        this.focusableId = "k-" + guid();
        /**
         * @hidden
         */
        this.selectedKeys = [];
        /**
         * @hidden
         */
        this.filterStateChange = new EventEmitter();
        /**
         * @hidden
         */
        this.allNodesHidden = false;
        /**
         * @hidden
         *
         * Used to associate the value label with the wrapper via aria-describedby.
         */
        this.valueLabelId = "k-" + guid();
        this._popupSettings = DEFAULT_POPUP_SETTINGS;
        this._tabindex = 0;
        this._isFocused = false;
        this.subscriptions = [];
        this.onTouchedCallback = noop;
        this.onChangeCallback = noop;
        this.direction = localization.rtl ? 'rtl' : 'ltr';
        this.subscribeEvents();
        this.subscribeTouchEvents();
    }
    DropDownTreeComponent_1 = DropDownTreeComponent;
    Object.defineProperty(DropDownTreeComponent.prototype, "clearable", {
        get: function () {
            return this.clearButton;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownTreeComponent.prototype, "treeview", {
        get: function () {
            return this._treeview;
        },
        set: function (treeview) {
            if (treeview) {
                if (this.isFocused && !this.filterable || this.touchEnabled) {
                    treeview.focus();
                }
                // the treeview animations are initially disabled (we don't want expand animations during popup opening)
                // re-enables the animations for user interaction
                treeview.animate = true;
                this._treeview = treeview;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownTreeComponent.prototype, "data", {
        get: function () {
            return this._nodes;
        },
        /**
         * Sets the data of the DropDownTree.
         *
         * > The data has to be provided in an array-like list with objects.
         */
        set: function (data) {
            this._nodes = data;
            this.setState();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownTreeComponent.prototype, "value", {
        get: function () {
            return this._value;
        },
        /**
         * Sets the value of the DropDownTree.
         * It can either be of the primitive (string, numbers) or of the complex (objects) type.
         * To define the type, use the `valuePrimitive` option.
         *
         */
        set: function (newValue) {
            this._value = newValue;
            this.setState();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownTreeComponent.prototype, "popupSettings", {
        get: function () {
            return this._popupSettings;
        },
        /**
         * Configures the popup of the DropDownTree.
         *
         * The available options are:
         * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
         * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped.
         * - `height: Number`&mdash;Sets the height of the popup container.
         * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
         * - `appendTo: "root" | "component" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.
         */
        set: function (settings) {
            this._popupSettings = Object.assign({}, DEFAULT_POPUP_SETTINGS, settings);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownTreeComponent.prototype, "dataItem", {
        get: function () {
            return this._dataItem ? this._dataItem : this.value;
        },
        /**
         * Keeps the current `dataItem` object in order to resolve selection.
         * Needs to be provided when `value` is bound in and `valuePrimitive` is set to true.
         */
        set: function (item) {
            this._dataItem = item;
            this.setState();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownTreeComponent.prototype, "tabindex", {
        get: function () {
            return this.disabled ? -1 : this._tabindex;
        },
        /**
         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        set: function (value) {
            var providedTabIndex = Number(value);
            var defaultTabIndex = 0;
            this._tabindex = !isNaN(providedTabIndex) ? providedTabIndex : defaultTabIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownTreeComponent.prototype, "isFocused", {
        get: function () {
            return this._isFocused;
        },
        set: function (isFocused) {
            this.renderer[isFocused ? 'addClass' : 'removeClass'](this.wrapper.nativeElement, 'k-state-focused');
            this._isFocused = isFocused;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownTreeComponent.prototype, "width", {
        get: function () {
            var wrapperWidth = this.wrapper.nativeElement.offsetWidth;
            var width = this.popupSettings.width || wrapperWidth;
            var minWidth = isNaN(wrapperWidth) ? wrapperWidth : wrapperWidth + "px";
            var maxWidth = isNaN(width) ? width : width + "px";
            return { min: minWidth, max: maxWidth };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownTreeComponent.prototype, "height", {
        get: function () {
            var popupHeight = this.popupSettings.height;
            return isPresent(popupHeight) ? popupHeight + "px" : 'auto';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownTreeComponent.prototype, "isOpen", {
        /**
         * Returns the current open state of the popup.
         */
        get: function () {
            return isPresent(this.popupRef);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownTreeComponent.prototype, "clearButtonVisiblity", {
        get: function () {
            if (this.touchEnabled) {
                return 'visible';
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownTreeComponent.prototype, "isExpanded", {
        get: function () {
            return this.isNodeExpanded;
        },
        /**
         * @hidden
         *
         * Alias for `isNodeExpanded`. Used for compatibility with the `ExpandableComponent` interface.
         * Required for the expand-directive.
         */
        set: function (callback) {
            this.isNodeExpanded = callback;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownTreeComponent.prototype, "expand", {
        /**
         * @hidden
         *
         * Alias for `nodeExpand`. Used for compatibility with the `ExpandableComponent` interface.
         * Required for the expand-directive.
         */
        get: function () {
            return this.nodeExpand;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownTreeComponent.prototype, "collapse", {
        /**
         * @hidden
         *
         * Alias for `nodeCollapse`. Used for compatibility with the `ExpandableComponent` interface.
         * Required for the expand-directive.
         */
        get: function () {
            return this.nodeCollapse;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownTreeComponent.prototype, "nodes", {
        get: function () {
            return this.data;
        },
        /**
         * @hidden
         *
         * Alias for `data`. Used for compatibility with the `DataBoundComponent` interface.
         * Required for the data-binding directives.
         */
        set: function (nodes) {
            this.data = nodes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownTreeComponent.prototype, "children", {
        get: function () {
            return this.fetchChildren;
        },
        /**
         * @hidden
         *
         * Alias for `fetchChildren`. Used for compatibility with the `DataBoundComponent` interface.
         * Required for the data-binding directives
         */
        set: function (callback) {
            this.fetchChildren = callback;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropDownTreeComponent.prototype, "isVisible", {
        get: function () {
            return this.isNodeVisible;
        },
        /**
         * @hidden
         *
         * Alias for `isNodeVisible`. Used for compatibility with the `DataBoundComponent` interface.
         * The `DataBoundComponent` interface is used in the data-binding directives.
         */
        set: function (callback) {
            this.isNodeVisible = callback;
        },
        enumerable: true,
        configurable: true
    });
    DropDownTreeComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.renderer.removeAttribute(this.hostElement.nativeElement, 'tabindex');
        this.assignAriaDescribedBy();
        this.subscriptions.push(this.localization
            .changes.subscribe(function (_a) {
            var rtl = _a.rtl;
            _this.direction = rtl ? 'rtl' : 'ltr';
            _this.cdr.markForCheck();
        }));
    };
    /**
     * @hidden
     */
    DropDownTreeComponent.prototype.ngOnDestroy = function () {
        this.destroyPopup();
        this.unsubscribeEvents();
    };
    /**
     * @hidden
     */
    DropDownTreeComponent.prototype.ngOnChanges = function (changes) {
        if (anyChanged(['textField', 'valueField', 'valuePrimitive'], changes, false)) {
            this.setState();
        }
    };
    /**
     * @hidden
     */
    DropDownTreeComponent.prototype.ngAfterContentChecked = function () {
        this.verifySettings();
    };
    /**
     * @hidden
     *
     * Used by the kendo-floatinglabel component to determine if the floating label
     * should be rendered inside the input when the component is not focused.
     */
    DropDownTreeComponent.prototype.isEmpty = function () {
        return !this.text && !this.placeholder;
    };
    /**
     * @hidden
     */
    DropDownTreeComponent.prototype.togglePopup = function (open) {
        var isDisabled = this.disabled || this.readonly;
        var sameState = this.isOpen === open;
        if (isDisabled || sameState) {
            return;
        }
        var togglePrevented = this.triggerPopupEvents(open);
        if (!togglePrevented) {
            open ?
                this.createPopup() :
                this.destroyPopup();
        }
    };
    /**
     * @hidden
     */
    DropDownTreeComponent.prototype.handleFocus = function () {
        var _this = this;
        if (!this.isFocused) {
            this.isFocused = true;
            if (hasObservers(this.onFocus)) {
                this._zone.run(function () {
                    _this.onFocus.emit();
                });
            }
        }
    };
    /**
     * @hidden
     */
    DropDownTreeComponent.prototype.handleBlur = function (e) {
        var _this = this;
        var relatedTarget = e && e.relatedTarget;
        if (this.hostElement.nativeElement.contains(relatedTarget) ||
            (this.isOpen && this.popupRef.popupElement.contains(relatedTarget))) {
            return;
        }
        this.isFocused = false;
        if (hasObservers(this.onBlur) ||
            isUntouched(this.hostElement.nativeElement)) {
            this._zone.run(function () {
                _this.togglePopup(false);
                _this.onBlur.emit();
                _this.onTouchedCallback();
            });
        }
        else {
            this.togglePopup(false);
        }
    };
    /**
     * @hidden
     */
    DropDownTreeComponent.prototype.handleKeydown = function (event) {
        if (this.disabled || this.readonly) {
            return;
        }
        var eventData = event;
        this.navigationService.process({
            originalEvent: eventData
        });
    };
    /**
     * @hidden
     */
    DropDownTreeComponent.prototype.handleClick = function () {
        this.togglePopup(!this.isOpen);
    };
    /**
     * Focuses a specific item of the DropDownTree based on a provided index in the format of `1_1`.
     * The targeted item should be expanded in order for it to be focused.
     * If null or invalid index is provided the focus will be set on the first item.
     */
    DropDownTreeComponent.prototype.focusItemAt = function (index) {
        if (this.treeview) {
            var lookup = this.treeview.itemLookup(index);
            var isItemDisabled = !isPresent(lookup) || this.treeview.isDisabled(lookup.item.dataItem, lookup.item.index);
            if (!isItemDisabled) {
                this.treeview.focus(index);
            }
        }
    };
    /**
     * Focuses the DropDownTree.
     */
    DropDownTreeComponent.prototype.focus = function () {
        if (!this.disabled) {
            this.wrapper.nativeElement.focus();
        }
    };
    /**
     * Blurs the DropDownTree.
     */
    DropDownTreeComponent.prototype.blur = function () {
        if (!this.disabled) {
            this.wrapper.nativeElement.blur();
        }
    };
    /**
     * Resets the value of the DropDownTree.
     * If you use the `reset` method to clear the value of the component,
     * the model will not update automatically and the `valueChange` event will not be fired.
     */
    DropDownTreeComponent.prototype.reset = function () {
        this.value = undefined;
        this.dataItem = undefined;
    };
    /**
     * Toggles the visibility of the popup
     * ([see example]({% slug openstate_ddt %})).
     * If you use the `toggle` method to open or close the popup, the `open` and `close` events will not be fired.
     *
     * @param open - The state of the popup.
     */
    DropDownTreeComponent.prototype.toggle = function (open) {
        var _this = this;
        // The Promise is required to open the popup on load.
        // Otherwise, the "ViewContainerRef not found..." error will be thrown.
        Promise.resolve(null).then(function () {
            var shouldOpen = isPresent(open) ? open : !isPresent(_this.popupRef);
            _this.destroyPopup();
            if (shouldOpen) {
                _this.createPopup();
            }
        });
    };
    Object.defineProperty(DropDownTreeComponent.prototype, "popupContainerClasses", {
        /**
         * @hidden
         */
        get: function () {
            var containerClasses = ['k-popup-dropdowntree', 'k-reset', 'k-group', 'k-list-container'];
            if (this.popupSettings.popupClass) {
                containerClasses.push(this.popupSettings.popupClass);
            }
            return containerClasses;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    DropDownTreeComponent.prototype.onSelectionChange = function (_a) {
        var dataItem = _a.dataItem, index = _a.index;
        this.valueDepth = index.split('_').length - 1;
        var valueField = this.getField(this.valueField, dataItem);
        var newValue = this.valuePrimitive ?
            getter(valueField)(dataItem) :
            dataItem;
        var shouldUpdateValue = newValue !== this.value;
        if (shouldUpdateValue) {
            this.dataItem = dataItem;
            this.value = newValue;
            this.emitValueChange(this.value);
        }
        this.togglePopup(false);
        this.focus();
    };
    /**
     * @hidden
     */
    DropDownTreeComponent.prototype.messageFor = function (key) {
        return this.localization.get(key);
    };
    /**
     * @hidden
     */
    DropDownTreeComponent.prototype.clearValue = function (event) {
        event.stopImmediatePropagation();
        this.focus();
        this.value = undefined;
        this.dataItem = undefined;
        this.clearState();
        this.valueChange.emit(undefined);
        this.emitValueChange();
    };
    Object.defineProperty(DropDownTreeComponent.prototype, "appendTo", {
        get: function () {
            var appendTo = this.popupSettings.appendTo;
            if (!appendTo || appendTo === 'root') {
                return undefined;
            }
            return appendTo === 'component' ? this.container : appendTo;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    DropDownTreeComponent.prototype.preventEventDefault = function (event) {
        event.preventDefault();
    };
    /**
     * @hidden
     */
    DropDownTreeComponent.prototype.writeValue = function (value) {
        // If the user resets the value by providing null/undefined we need to reset the `dataItem`
        // Because upon initialization of the component the `writeValue` is being called twice -
        // first time with `null` value regardless of sync/async value - an extra check is added to
        // distinguish between client reset and initial phanotm 'null' value
        if (!isPresent(value) && isPresent(this.value)) {
            this.dataItem = null;
        }
        this.value = value === null ? undefined : value;
    };
    /**
     * @hidden
     */
    DropDownTreeComponent.prototype.registerOnChange = function (fn) {
        this.onChangeCallback = fn;
    };
    /**
     * @hidden
     */
    DropDownTreeComponent.prototype.registerOnTouched = function (fn) {
        this.onTouchedCallback = fn;
    };
    /**
     * @hidden
     */
    DropDownTreeComponent.prototype.setDisabledState = function (isDisabled) {
        this.disabled = isDisabled;
        this.cdr.markForCheck();
    };
    /**
     * @hidden
     */
    DropDownTreeComponent.prototype.handleFilterInputChange = function (term) {
        var _this = this;
        this.filterChange.next(term);
        this.allNodesHidden = this.nodes.every(function (node, index) { return !_this.isVisible(node, String(index)); });
    };
    DropDownTreeComponent.prototype.verifySettings = function () {
        if (!isDevMode()) {
            return;
        }
        if (this.valuePrimitive === true && isPresent(this.value) && typeof this.value === "object") {
            throw new Error(DropDownTreeMessages.primitive);
        }
        if (this.valuePrimitive === true && isPresent(this.value) && typeof this.dataItem !== "object") {
            throw new Error(DropDownTreeMessages.dataItem);
        }
        if (this.valuePrimitive === false && isPresent(this.value) && typeof this.value !== "object") {
            throw new Error(DropDownTreeMessages.object);
        }
        if (!isPresent(this.valueField) || !isPresent(this.textField)) {
            throw new Error(DropDownTreeMessages.textAndValue);
        }
        if ((isArray(this.valueField) || isArray(this.textField)) && isPresent(this.value) && !isPresent(this.valueDepth)) {
            throw new Error(DropDownTreeMessages.valueDepth);
        }
    };
    DropDownTreeComponent.prototype.emitValueChange = function (value) {
        this.onChangeCallback(value);
        this.valueChange.emit(value);
    };
    DropDownTreeComponent.prototype.getText = function (textField, dataItem) {
        if (isPresent(dataItem) && isPresent(textField)) {
            var field = this.getField(textField, dataItem);
            return getter(field)(dataItem);
        }
        return null;
    };
    /**
     * @hidden
     *
     * Determines the `valueField` and `textField` for a specific level in the data set
     *  @param field - the field value (string | string[])
     *  @param value - current value
     */
    DropDownTreeComponent.prototype.getField = function (field, value) {
        var fieldsCount = field.length - 1;
        if (typeof field === 'string') {
            // If the `valueField` | `textField` is the same for all levels
            return field;
        }
        else if (isPresent(this.valueDepth)) {
            // When `valueDepth` can be defined from the index on selectionChange or provided by the user
            return fieldsCount < this.valueDepth ? field[fieldsCount] : field[this.valueDepth];
        }
        else {
            // Fallback: Look to find a match of each field in the current data item
            // Side effect may occur if all of the listed fields are present in the data item
            return field.find(function (item) { return item in value; });
        }
    };
    DropDownTreeComponent.prototype.triggerPopupEvents = function (open) {
        var eventArgs = new PreventableEvent();
        if (open) {
            this.open.emit(eventArgs);
        }
        else {
            this.close.emit(eventArgs);
        }
        return eventArgs.isDefaultPrevented();
    };
    DropDownTreeComponent.prototype.createPopup = function () {
        var _this = this;
        var horizontalAlign = this.direction === "rtl" ? "right" : "left";
        var anchorPosition = { horizontal: horizontalAlign, vertical: 'bottom' };
        var popupPosition = { horizontal: horizontalAlign, vertical: 'top' };
        this.popupRef = this.popupService.open({
            anchor: this.wrapper,
            appendTo: this.appendTo,
            anchorAlign: anchorPosition,
            content: this.popupTemplate,
            popupAlign: popupPosition,
            positionMode: 'absolute',
            popupClass: this.popupContainerClasses
        });
        var popupWrapper = this.popupRef.popupElement;
        var _a = this.width, min = _a.min, max = _a.max;
        popupWrapper.style.minWidth = min;
        popupWrapper.style.width = max;
        popupWrapper.style.height = this.height;
        popupWrapper.setAttribute("dir", this.direction);
        this.popupRef.popupOpen.subscribe(function () {
            _this.cdr.detectChanges();
            _this.opened.emit();
        });
        this.popupRef.popupClose.subscribe(function () {
            _this.closed.emit();
        });
    };
    DropDownTreeComponent.prototype.destroyPopup = function () {
        var _this = this;
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
            if (this.filter !== "") {
                this.filter = "";
                this.allNodesHidden = false;
                if (hasObservers(this.filterChange)) {
                    this._zone.run(function () {
                        _this.filterChange.emit("");
                    });
                }
            }
        }
    };
    DropDownTreeComponent.prototype.handleEscape = function () {
        this.togglePopup(false);
        this.focus();
    };
    DropDownTreeComponent.prototype.setState = function () {
        if (isPresent(this.value) && isPresent(this.dataItem) && isPresent(this.valueField)) {
            this.text = this.getText(this.textField, this.dataItem);
            var valueField = this.getField(this.valueField, this.dataItem);
            this.selectBy = valueField;
            this.selectedKeys = [getter(valueField)(this.dataItem)];
        }
        else {
            this.clearState();
        }
        this.cdr.markForCheck();
    };
    DropDownTreeComponent.prototype.clearState = function () {
        this.text = undefined;
        this.valueDepth = undefined;
        this.selectedKeys = [];
    };
    DropDownTreeComponent.prototype.subscribeEvents = function () {
        var _this = this;
        this.subscriptions.push(this.navigationService.open.subscribe(function () { return _this.togglePopup(true); }), this.navigationService.close.subscribe(function () {
            _this.togglePopup(false);
            _this.focus();
        }), this.navigationService.enter
            .pipe(tap(function (event) { return event.originalEvent.preventDefault(); }))
            .subscribe(function () { return _this.togglePopup(true); }), this.navigationService.esc
            .subscribe(function () { return _this.handleEscape(); }), this.navigationService.tab.subscribe(function () { return _this.focus(); }), this.navigationService.down.subscribe(function (event) {
            if (!_this.treeview) {
                return;
            }
            event.originalEvent.preventDefault();
            if (!_this.treeview.isActive) {
                _this.treeview.focus();
            }
        }), this.navigationService.up.subscribe(function (event) {
            if (!_this.treeview) {
                return;
            }
            event.originalEvent.preventDefault();
            if (_this.filterable && _this.treeview['navigationService']['activeIndex'] === '0') {
                _this.filterInput.nativeElement.focus();
            }
        }));
    };
    DropDownTreeComponent.prototype.subscribeTouchEvents = function () {
        var _this = this;
        if (!isDocumentAvailable() || !this.touchEnabled) {
            return;
        }
        this._zone.runOutsideAngular(function () {
            // Roll up DropDownTree on iOS when tapped outside
            return _this.touchstartDisposeHandler = _this.renderer.listen(document, 'touchstart', function (e) {
                var target = e.target;
                if (_this.isFocused && !inDropDown(_this.hostElement, target, _this.popupRef)) {
                    _this._zone.run(function () {
                        if (_this.isOpen) {
                            _this.treeview.blur();
                        }
                        _this.blur();
                    });
                }
            });
        });
    };
    DropDownTreeComponent.prototype.unsubscribeEvents = function () {
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        if (this.touchstartDisposeHandler) {
            this.touchstartDisposeHandler();
        }
    };
    DropDownTreeComponent.prototype.assignAriaDescribedBy = function () {
        var currentValue = this.wrapper.nativeElement.getAttribute('aria-describedby') || '';
        // add to the current value - don't replace it (the aria-describedby is used by the FormField component as well)
        var newValue = (this.valueLabelId + " " + currentValue.trim()).trim();
        this.renderer.setAttribute(this.wrapper.nativeElement, 'aria-describedby', newValue);
    };
    var DropDownTreeComponent_1;
    __decorate([
        HostBinding('class.k-widget'),
        HostBinding('class.k-dropdowntree'),
        HostBinding('class.k-dropdowntree-clearable'),
        __metadata("design:type", Boolean)
    ], DropDownTreeComponent.prototype, "hostClasses", void 0);
    __decorate([
        HostBinding('attr.dir'),
        __metadata("design:type", String)
    ], DropDownTreeComponent.prototype, "direction", void 0);
    __decorate([
        HostBinding('class.k-dropdowntree-clearable'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], DropDownTreeComponent.prototype, "clearable", null);
    __decorate([
        ContentChild(NoDataTemplateDirective, { static: false }),
        __metadata("design:type", NoDataTemplateDirective)
    ], DropDownTreeComponent.prototype, "noDataTemplate", void 0);
    __decorate([
        ContentChild(HeaderTemplateDirective, { static: false }),
        __metadata("design:type", HeaderTemplateDirective)
    ], DropDownTreeComponent.prototype, "headerTemplate", void 0);
    __decorate([
        ContentChild(FooterTemplateDirective, { static: false }),
        __metadata("design:type", FooterTemplateDirective)
    ], DropDownTreeComponent.prototype, "footerTemplate", void 0);
    __decorate([
        ContentChild(NodeTemplateDirective, { static: false }),
        __metadata("design:type", NodeTemplateDirective)
    ], DropDownTreeComponent.prototype, "nodeTemplate", void 0);
    __decorate([
        ContentChild(ValueTemplateDirective, { static: false }),
        __metadata("design:type", ValueTemplateDirective)
    ], DropDownTreeComponent.prototype, "valueTemplate", void 0);
    __decorate([
        ViewChild('popupTemplate', { static: true }),
        __metadata("design:type", TemplateRef)
    ], DropDownTreeComponent.prototype, "popupTemplate", void 0);
    __decorate([
        ViewChild('wrapper', { static: true }),
        __metadata("design:type", ElementRef)
    ], DropDownTreeComponent.prototype, "wrapper", void 0);
    __decorate([
        ViewChild('container', { read: ViewContainerRef, static: true }),
        __metadata("design:type", ViewContainerRef)
    ], DropDownTreeComponent.prototype, "container", void 0);
    __decorate([
        ViewChild('treeview', { static: false }),
        __metadata("design:type", TreeViewComponent),
        __metadata("design:paramtypes", [TreeViewComponent])
    ], DropDownTreeComponent.prototype, "treeview", null);
    __decorate([
        ViewChild('filterInput', { static: false }),
        __metadata("design:type", ElementRef)
    ], DropDownTreeComponent.prototype, "filterInput", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], DropDownTreeComponent.prototype, "open", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], DropDownTreeComponent.prototype, "opened", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], DropDownTreeComponent.prototype, "close", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], DropDownTreeComponent.prototype, "closed", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], DropDownTreeComponent.prototype, "nodeExpand", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], DropDownTreeComponent.prototype, "nodeCollapse", void 0);
    __decorate([
        Output('focus'),
        __metadata("design:type", EventEmitter)
    ], DropDownTreeComponent.prototype, "onFocus", void 0);
    __decorate([
        Output('blur'),
        __metadata("design:type", EventEmitter)
    ], DropDownTreeComponent.prototype, "onBlur", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], DropDownTreeComponent.prototype, "valueChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], DropDownTreeComponent.prototype, "filterChange", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], DropDownTreeComponent.prototype, "loading", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], DropDownTreeComponent.prototype, "clearButton", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array),
        __metadata("design:paramtypes", [Array])
    ], DropDownTreeComponent.prototype, "data", null);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], DropDownTreeComponent.prototype, "value", null);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], DropDownTreeComponent.prototype, "textField", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], DropDownTreeComponent.prototype, "valueField", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], DropDownTreeComponent.prototype, "valueDepth", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], DropDownTreeComponent.prototype, "hasChildren", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], DropDownTreeComponent.prototype, "fetchChildren", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], DropDownTreeComponent.prototype, "placeholder", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], DropDownTreeComponent.prototype, "popupSettings", null);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], DropDownTreeComponent.prototype, "dataItem", null);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], DropDownTreeComponent.prototype, "listHeight", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], DropDownTreeComponent.prototype, "disabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], DropDownTreeComponent.prototype, "readonly", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], DropDownTreeComponent.prototype, "valuePrimitive", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number),
        __metadata("design:paramtypes", [Number])
    ], DropDownTreeComponent.prototype, "tabindex", null);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], DropDownTreeComponent.prototype, "itemDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], DropDownTreeComponent.prototype, "isNodeExpanded", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], DropDownTreeComponent.prototype, "isNodeVisible", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], DropDownTreeComponent.prototype, "loadOnDemand", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], DropDownTreeComponent.prototype, "filterable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], DropDownTreeComponent.prototype, "filter", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], DropDownTreeComponent.prototype, "focusableId", void 0);
    DropDownTreeComponent = DropDownTreeComponent_1 = __decorate([
        Component({
            exportAs: 'kendoDropDownTree',
            providers: [
                DataService,
                SelectionService,
                NavigationService,
                DisabledItemsService,
                LocalizationService,
                {
                    provide: L10N_PREFIX,
                    useValue: 'kendo.dropdowntree'
                },
                {
                    multi: true,
                    provide: NG_VALUE_ACCESSOR,
                    useExisting: forwardRef(function () { return DropDownTreeComponent_1; })
                },
                {
                    provide: KendoInput,
                    useExisting: forwardRef(function () { return DropDownTreeComponent_1; })
                },
                {
                    provide: DataBoundComponent,
                    useExisting: forwardRef(function () { return DropDownTreeComponent_1; })
                },
                {
                    provide: ExpandableComponent,
                    useExisting: forwardRef(function () { return DropDownTreeComponent_1; })
                }
            ],
            selector: 'kendo-dropdowntree',
            template: "\n        <ng-container kendoDropDownTreeLocalizedMessages\n            i18n-noDataText=\"kendo.dropdowntree.noDataText|The text displayed in the popup when there are no items\"\n            noDataText=\"NO DATA FOUND\"\n\n            i18n-clearTitle=\"kendo.dropdowntree.clearTitle|The title of the clear button\"\n            clearTitle=\"clear\"\n        >\n        </ng-container>\n        <span\n            #wrapper\n            [ngClass]=\"{\n                'k-dropdown-wrap': true,\n                'k-state-disabled': this.disabled\n            }\"\n            [attr.id]=\"focusableId\"\n            role=\"listbox\"\n            aria-haspopup=\"tree\"\n            [attr.aria-expanded]=\"isOpen\"\n            [attr.aria-readonly]=\"readonly\"\n            [attr.tabindex]=\"tabindex\"\n            [attr.dir]=\"direction\"\n            (click)=\"handleClick()\"\n            (keydown)=\"handleKeydown($event)\"\n            [kendoEventsOutsideAngular]=\"{\n                focus: handleFocus,\n                blur: handleBlur\n            }\"\n            [scope]=\"this\"\n        >\n            <span\n                [attr.id]=\"valueLabelId\"\n                class=\"k-input\"\n            >\n                <ng-template *ngIf=\"valueTemplate\"\n                    [templateContext]=\"{\n                        templateRef: valueTemplate.templateRef,\n                        $implicit: dataItem\n                    }\">\n                </ng-template>\n                <ng-template [ngIf]=\"!valueTemplate\"> {{ text || placeholder }} </ng-template>\n            </span>\n            <span\n                *ngIf=\"!loading && !readonly && clearButton && text?.length\"\n                class=\"k-icon k-clear-value k-i-close\"\n                [style.visibility]=\"clearButtonVisiblity\"\n                aria-hidden=\"true\"\n                [attr.title]=\"messageFor('clearTitle')\"\n                (click)=\"clearValue($event)\"\n            >\n            </span>\n            <span class=\"k-select\" aria-hidden=\"true\">\n                <span class=\"k-icon k-i-arrow-60-down\"></span>\n            </span>\n        </span>\n        <ng-template #popupTemplate>\n            <span\n                *ngIf=\"filterable\"\n                class=\"k-list-filter\"\n            >\n                <input\n                    #filterInput\n                    (input)=\"handleFilterInputChange($event.target.value)\"\n                    [filterInput]=\"filterable && !touchEnabled\"\n                    (keydown.arrowdown)=\"handleKeydown($event)\"\n                    (keydown.alt.arrowup)=\"handleKeydown($event)\"\n                    [(ngModel)]=\"filter\"\n                    class=\"k-textbox\"\n                    role=\"textbox\"\n                    aria-haspopup=\"true\"\n                    aria-expanded=\"false\"\n                    tabindex=\"0\"\n                    aria-disabled=\"false\"\n                    aria-readonly=\"false\"\n                    [kendoEventsOutsideAngular]=\"{\n                        blur: handleBlur\n                    }\"\n                    [scope]=\"this\"\n                >\n                <span class=\"k-icon k-i-zoom\"></span>\n            </span>\n            <!--header template-->\n            <ng-template\n                *ngIf=\"headerTemplate\"\n                [templateContext]=\"{\n                    templateRef: headerTemplate?.templateRef\n                }\">\n            </ng-template>\n            <kendo-treeview\n                #treeview\n                *ngIf=\"data.length !== 0 && !allNodesHidden\"\n                [nodes]=\"data\"\n                [style.maxHeight.px]=\"listHeight\"\n                [animate]=\"false\"\n                [(selectedKeys)]=\"selectedKeys\"\n                [selectBy]=\"selectBy\"\n                [textField]=\"textField\"\n                kendoTreeViewSelectable\n                [children]=\"children\"\n                [hasChildren]=\"hasChildren\"\n                [loadOnDemand]=\"loadOnDemand\"\n                [isExpanded]=\"isNodeExpanded\"\n                [isDisabled]=\"itemDisabled\"\n                [nodeTemplate]=\"nodeTemplate\"\n                [filter]=\"filter\"\n                [isVisible]=\"isNodeVisible\"\n                (focusout)=\"handleBlur($event)\"\n                (keydown)=\"handleKeydown($event)\"\n                (selectionChange)=\"onSelectionChange($event)\"\n                (expand)=\"nodeExpand.emit($event)\"\n                (collapse)=\"nodeCollapse.emit($event)\"\n            >\n            </kendo-treeview>\n            <!--footer template-->\n            <ng-template\n                *ngIf=\"footerTemplate\"\n                [templateContext]=\"{\n                    templateRef: footerTemplate?.templateRef\n                }\">\n            </ng-template>\n            <!--no-data template-->\n            <div class=\"k-nodata\" *ngIf=\"data.length === 0 || allNodesHidden\">\n                <ng-template [ngIf]=\"noDataTemplate\"\n                    [templateContext]=\"{\n                        templateRef: noDataTemplate?.templateRef\n                    }\">\n                </ng-template>\n                <ng-template [ngIf]=\"!noDataTemplate\">\n                    <div>{{ messageFor('noDataText') }}</div>\n                </ng-template>\n            </div>\n        </ng-template>\n        <ng-container #container></ng-container>\n    ",
            changeDetection: ChangeDetectionStrategy.OnPush
        }),
        __param(7, Optional()), __param(7, Inject(TOUCH_ENABLED)),
        __metadata("design:paramtypes", [PopupService,
            NavigationService,
            Renderer2,
            ElementRef,
            NgZone,
            ChangeDetectorRef,
            LocalizationService, Boolean])
    ], DropDownTreeComponent);
    return DropDownTreeComponent;
}());

/* tslint:disable:member-ordering */
var DEFAULT_POPUP_SETTINGS$1 = { animate: true };
var DEFAULT_CHECKABLE_SETTINGS = { checkChildren: true, checkOnClick: true };
var hasChildren$1 = function () { return false; };
var fetchChildren$1 = function () { return of([]); };
var itemDisabled$1 = function () { return false; };
var isNodeVisible$1 = function () { return true; };
/**
 * Represents the [Kendo UI MultiSelectTree component for Angular]({% slug overview_multiselecttree %}).
 */
var MultiSelectTreeComponent = /** @class */ (function () {
    function MultiSelectTreeComponent(popupService, renderer, hostElement, navigationService, _zone, localization, cdr, touchEnabled$$1) {
        this.popupService = popupService;
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.navigationService = navigationService;
        this._zone = _zone;
        this.localization = localization;
        this.cdr = cdr;
        this.touchEnabled = touchEnabled$$1;
        this.hostClasses = true;
        /**
         * Sets the levels in the data set where the values can be found when `valueField` is an Array.
         * The field serves to correctly allocate a data item used when the MultiSelectTree is initialized with a value.
         */
        this.valueDepth = [];
        /**
         * The hint which is displayed when the component is empty.
         */
        this.placeholder = "";
        /**
         * Sets the height of the options list. By default, `listHeight` is 200px.
         *
         * > The `listHeight` property affects only the list of options and not the whole popup container.
         * > To set the height of the popup container, use `popupSettings.height`.
         */
        this.listHeight = 200;
        /**
         * Sets the disabled state of the component.
         */
        this.disabled = false;
        /**
         * Sets the read-only state of the component.
         */
        this.readonly = false;
        /**
         * Specifies the type of the selected value
         * ([more information and example]({% slug valuebinding_multiselecttree %}#toc-primitive-values)).
         * If set to `true`, the selected value has to be a primitive one.
         */
        this.valuePrimitive = false;
        /**
         * Indicates whether the child nodes will be fetched on node expand or will be initially prefetched.
         * @default false
         */
        this.loadOnDemand = false;
        /**
         * @hidden
         *
         * Used by the kendo-label and kendo-floatinglabel to access and associate the focusable element with the provided label via aria-labelledby.
         */
        this.focusableId = "k-" + guid();
        /**
         * If set to `true`, renders a button on hovering over the component.
         * Clicking this button resets the value of the component to `undefined` and triggers the `change` event.
         * @default true
         */
        this.clearButton = true;
        /**
         * Renders the built-in input element for filtering the MultiSelectTree.
         * If set to `true`, the component emits the `filterChange` event, which can be used to [filter the MultiSelectTree manually]({% slug filtering_multiselecttree %}#toc-manual-filtering).
         * A built-in filtering implementation is available to use with the [`kendoMultiSelectTreeHierarchyBinding`]({% slug api_dropdowns_multiselecttreehierarchybindingdirective %}) and [`kendoMultiSelectTreeFlatBinding`]({% slug api_dropdowns_multiselecttreeflatbindingdirective %}) directives.
         * @default false
         */
        this.filterable = false;
        /**
         * A function which determines if a specific node has child nodes.
         */
        this.hasChildren = hasChildren$1;
        /**
         * A function which provides the child nodes for a given parent node.
         */
        this.fetchChildren = fetchChildren$1;
        /**
         * A callback which determines whether a tree node should be rendered as hidden. The utility .k-display-none class is used to hide the nodes.
         * Useful for custom filtering implementations.
         */
        this.isNodeVisible = isNodeVisible$1;
        /**
         * A function that is executed for each data item and determines if a specific item is disabled.
         */
        this.itemDisabled = itemDisabled$1;
        /**
         * A user-defined callback function which receives an array of selected data items and maps them to an array of tags.
         *
         * @param { Any[] } dataItems - The selected data items from the list.
         * @returns { Any[] } - The tags that will be rendered by the component.
         */
        this.tagMapper = function (tags) { return tags || []; };
        /**
         * Fires each time the user focuses the MultiSelectTree.
         */
        this.onFocus = new EventEmitter();
        /**
         * Fires each time the MultiSelectTree gets blurred.
         */
        this.onBlur = new EventEmitter();
        /**
         * Fires each time the popup is about to open
         * ([see example]({% slug openstate_multiselecttree %})).
         * This event is preventable. If you cancel it, the popup will remain closed.
         */
        this.open = new EventEmitter();
        /**
         * Fires after the popup has been opened.
         */
        this.opened = new EventEmitter();
        /**
         * Fires each time the popup is about to close
         * ([see example]({% slug openstate_multiselecttree %})).
         * This event is preventable. If you cancel it, the popup will remain open.
         */
        this.close = new EventEmitter();
        /**
         * Fires after the popup has been closed.
         */
        this.closed = new EventEmitter();
        /**
         * Fires when the user expands a node in the popup TreeView.
         */
        this.nodeExpand = new EventEmitter();
        /**
         * Fires when the user collapses a node in the popup TreeView.
         */
        this.nodeCollapse = new EventEmitter();
        /**
         * Fires each time the value is changed
         * ([see example]({% slug overview_multiselecttree %}#toc-events)).
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time a tag is about to be removed.
         * This event is preventable. If you cancel it, the tag will not be removed.
         */
        this.removeTag = new EventEmitter();
        /**
         * Fires when the value of the built-in filter input element changes.
         */
        this.filterChange = new EventEmitter();
        /**
         * @hidden
         */
        this.filterStateChange = new EventEmitter();
        /**
         * @hidden
         */
        this.checkedItems = [];
        /**
         * @hidden
         */
        this.checkBy = function (item) { return item; };
        /**
         * @hidden
         */
        this.showAfter = 0;
        /**
         * @hidden
         */
        this.allNodesHidden = false;
        this.tagListId = guid();
        this.tagPrefix = "tag-" + guid();
        this.focusedTagIndex = undefined;
        this._value = [];
        this._tabindex = 0;
        this._popupSettings = DEFAULT_POPUP_SETTINGS$1;
        this._checkableSettings = DEFAULT_CHECKABLE_SETTINGS;
        this._isFocused = false;
        this.subscriptions = [];
        this.onTouchedCallback = noop;
        this.onChangeCallback = noop;
        this.direction = localization.rtl ? 'rtl' : 'ltr';
        this.subscribeEvents();
    }
    MultiSelectTreeComponent_1 = MultiSelectTreeComponent;
    Object.defineProperty(MultiSelectTreeComponent.prototype, "treeview", {
        get: function () {
            return this._treeview;
        },
        set: function (treeview) {
            var _this = this;
            this._treeview = treeview;
            if (treeview) {
                // If filtering is enabled, focus the TreeView on mobile devices instead of the filter input
                if (this.isFocused && !this.filterable || this.touchEnabled) {
                    treeview.focus();
                }
                /**
                 * the treeview animations are initially disabled (we don't want expand animations during popup opening)
                 * re-enables the animations for user interaction
                 * The Promise is required to properly change the `animate` property when
                 * the popup is appended to a container and opened upon initialization.
                 * Otherwise, the "Expression has changed..." type error will be thrown.
                 */
                Promise.resolve(null).then(function () { return _this.treeview.animate = true; });
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectTreeComponent.prototype, "tabindex", {
        get: function () {
            return this.disabled ? -1 : this._tabindex;
        },
        /**
         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        set: function (value) {
            var providedTabIndex = parseNumber(value);
            var defaultTabIndex = 0;
            this._tabindex = !isNaN(providedTabIndex) ? providedTabIndex : defaultTabIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectTreeComponent.prototype, "popupSettings", {
        get: function () {
            return this._popupSettings;
        },
        /**
         * Configures the popup of the MultiSelectTree.
         *
         * The available options are:
         * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
         * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped.
         * - `height: Number`&mdash;Sets the height of the popup container.
         * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
         * - `appendTo: "root" | "component" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.
         */
        set: function (settings) {
            this._popupSettings = Object.assign({}, DEFAULT_POPUP_SETTINGS$1, settings);
            // `detectChanges` needed, otherwise upon value initialization and `appendTo` property
            // an error is thrown => ExpressionChangedAfterItHasBeenCheckedError
            this.cdr.detectChanges();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectTreeComponent.prototype, "checkableSettings", {
        get: function () {
            return this._checkableSettings;
        },
        /**
         * Defines the checkable settings of the MultiSelecTree nodes.
         * If no value is provided, the default [`CheckableSettings`]({% slug api_dropdowns_multiselecttreecheckablesettings %}) are applied.
         */
        set: function (settings) {
            this._checkableSettings = Object.assign({}, DEFAULT_CHECKABLE_SETTINGS, settings);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectTreeComponent.prototype, "data", {
        get: function () {
            return this._nodes;
        },
        /**
         * Sets the data of the MultiSelectTree.
         *
         * > The data has to be provided in an array-like list with objects.
         */
        set: function (data) {
            this._nodes = data;
            this.setState();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectTreeComponent.prototype, "value", {
        get: function () {
            return this._value;
        },
        /**
         * Sets the value of the MultiSelectTree.
         * It can either be of the primitive (string, numbers) or of the complex (objects) type.
         * To define the type, use the `valuePrimitive` option.
         *
         */
        set: function (value) {
            this._value = value ? value : [];
            this.setState();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectTreeComponent.prototype, "dataItems", {
        get: function () {
            var _this = this;
            return this._dataItems || this.value.map(function (value, index) { return ({
                dataItem: value,
                index: null,
                level: _this.valueDepth[index] || 0
            }); });
        },
        /**
         * Keeps the current `dataItems` object in order to resolve selection.
         * Needs to be provided when when programmatically setting a `value` and `valuePrimitive` is set to `true`.
         */
        set: function (items) {
            var _this = this;
            this._dataItems = (items || []).map(function (item, index) {
                if (hasProps(item, ['dataItem', 'index', 'level'])) {
                    return item;
                }
                return {
                    dataItem: item,
                    index: null,
                    level: _this.valueDepth[index] || 0
                };
            });
            this.setState();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectTreeComponent.prototype, "focusedTagId", {
        /**
         * @hidden
         */
        get: function () {
            if (!isPresent(this.focusedTagIndex) || this.isOpen) {
                return null;
            }
            var dataItem = this.tags[this.focusedTagIndex];
            return this.tagPrefix + "-" + valueFrom({ dataItem: dataItem }, this.valueField);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectTreeComponent.prototype, "isFocused", {
        get: function () {
            return this._isFocused;
        },
        set: function (isFocused) {
            this.renderer[isFocused ? 'addClass' : 'removeClass'](this.hostElement.nativeElement, 'k-state-focused');
            this._isFocused = isFocused;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectTreeComponent.prototype, "isOpen", {
        /**
         * Returns the current open state of the popup.
         */
        get: function () {
            return isPresent(this.popupRef);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectTreeComponent.prototype, "width", {
        get: function () {
            var wrapperWidth = this.wrapper.nativeElement.offsetWidth;
            var width = this.popupSettings.width || wrapperWidth;
            var minWidth = isNaN(wrapperWidth) ? wrapperWidth : wrapperWidth + "px";
            var maxWidth = isNaN(width) ? width : width + "px";
            return { min: minWidth, max: maxWidth };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectTreeComponent.prototype, "height", {
        get: function () {
            var popupHeight = this.popupSettings.height;
            return isPresent(popupHeight) ? popupHeight + "px" : 'auto';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectTreeComponent.prototype, "appendTo", {
        get: function () {
            var appendTo = this.popupSettings.appendTo;
            if (!appendTo || appendTo === 'root') {
                return undefined;
            }
            return appendTo === 'component' ? this.container : appendTo;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectTreeComponent.prototype, "popupContainerClasses", {
        /**
         * @hidden
         */
        get: function () {
            var containerClasses = ['k-popup-dropdowntree', 'k-reset', 'k-group', 'k-list-container'];
            if (this.popupSettings.popupClass) {
                containerClasses.push(this.popupSettings.popupClass);
            }
            return containerClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectTreeComponent.prototype, "nodes", {
        get: function () {
            return this.data;
        },
        /**
         * @hidden
         *
         * Alias for `data`. Used for compatibility with the `DataBoundComponent` interface.
         * Required for the data-binding directives.
         */
        set: function (nodes) {
            this.data = nodes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectTreeComponent.prototype, "children", {
        get: function () {
            return this.fetchChildren;
        },
        /**
         * @hidden
         *
         * Alias for `fetchChildren`. Used for compatibility with the `DataBoundComponent` interface.
         * Required for the data-binding directives
         */
        set: function (callback) {
            this.fetchChildren = callback;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectTreeComponent.prototype, "expand", {
        /**
         * @hidden
         *
         * Alias for `nodeExpand`. Used for compatibility with the `ExpandableComponent` interface.
         * Required for the expand-directive.
         */
        get: function () {
            return this.nodeExpand;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectTreeComponent.prototype, "collapse", {
        /**
         * @hidden
         *
         * Alias for `nodeCollapse`. Used for compatibility with the `ExpandableComponent` interface.
         * Required for the expand-directive.
         */
        get: function () {
            return this.nodeCollapse;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectTreeComponent.prototype, "isExpanded", {
        get: function () {
            return this.isNodeExpanded;
        },
        /**
         * @hidden
         *
         * Alias for `isNodeExpanded`. Used for compatibility with the `ExpandableComponent` interface.
         * Required for the expand-directive.
         */
        set: function (callback) {
            this.isNodeExpanded = callback;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectTreeComponent.prototype, "isVisible", {
        get: function () {
            return this.isNodeVisible;
        },
        /**
         * @hidden
         *
         * Alias for `isNodeVisible`. Used for compatibility with the `DataBoundComponent` interface.
         * The `DataBoundComponent` interface is used in the data-binding directives.
         */
        set: function (callback) {
            this.isNodeVisible = callback;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectTreeComponent.prototype, "isTagFocused", {
        get: function () {
            return !this.isOpen && this.focusedTagIndex !== undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectTreeComponent.prototype, "isTreeViewActive", {
        get: function () {
            return this.treeview && this.treeview.isActive;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiSelectTreeComponent.prototype, "isWrapperActive", {
        get: function () {
            return document.activeElement === this.wrapper.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    MultiSelectTreeComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.renderer.removeAttribute(this.hostElement.nativeElement, 'tabindex');
        this.renderer.setAttribute(this.wrapper.nativeElement, 'aria-expanded', String(this.isOpen));
        this.subscriptions.push(this.localization
            .changes.subscribe(function (_a) {
            var rtl = _a.rtl;
            _this.direction = rtl ? 'rtl' : 'ltr';
            _this.cdr.markForCheck();
        }));
    };
    /**
     * @hidden
     */
    MultiSelectTreeComponent.prototype.ngOnDestroy = function () {
        this.destroyPopup();
        this.unsubscribeEvents();
    };
    /**
     * @hidden
     */
    MultiSelectTreeComponent.prototype.ngOnChanges = function (changes) {
        var _this = this;
        if (anyChanged(['textField', 'valueField', 'valuePrimitive'], changes, false)) {
            this.setState();
        }
        if (anyChanged(['valueDepth', 'value', 'dataItems'], changes, false)) {
            if (changes.value && !changes.dataItems && !this.valuePrimitive) {
                // Update the dataItems if the value is updated programmatically (non-primitive values only)
                // In the primitive case, the client should update the dataItems as well
                this.dataItems = this.value;
            }
            else {
                // Re-map the dataItems because `valueDepth` is not yet available when the check directive parses the items
                this.dataItems = this.dataItems.map(function (item, index) { return (__assign({}, item, { level: _this.valueDepth[index] || 0 })); });
            }
        }
    };
    /**
     * @hidden
     */
    MultiSelectTreeComponent.prototype.ngAfterContentChecked = function () {
        this.verifySettings();
    };
    /**
     * @hidden
     *
     * Used by the kendo-floatinglabel component to determine if the floating label
     * should be rendered inside the input when the component is not focused.
     */
    MultiSelectTreeComponent.prototype.isEmpty = function () {
        return !Boolean(this.placeholder) && (!isPresent(this.value) || this.value.length === 0);
    };
    /**
     * Focuses the MultiSelectTree.
     */
    MultiSelectTreeComponent.prototype.focus = function () {
        if (!this.disabled) {
            this.wrapper.nativeElement.focus();
        }
    };
    /**
     * Blurs the MultiSelectTree.
     */
    MultiSelectTreeComponent.prototype.blur = function () {
        if (!this.disabled) {
            this.wrapper.nativeElement.blur();
        }
    };
    /**
     * Focuses a specific item of the MultiSelectTree based on a provided index in the format of `1_1`.
     * The targeted item should be expanded in order for it to be focused.
     * If null or invalid index is provided the focus will be set on the first item.
     */
    MultiSelectTreeComponent.prototype.focusItemAt = function (index) {
        if (this.treeview) {
            var lookup = this.treeview.itemLookup(index);
            var isItemDisabled = !isPresent(lookup) || this.treeview.isDisabled(lookup.item.dataItem, lookup.item.index);
            if (!isItemDisabled) {
                this.treeview.focus(index);
            }
        }
    };
    /**
     * Resets the value of the MultiSelectTree.
     * If you use the `reset` method to clear the value of the component,
     * the model will not update automatically and the `valueChange` event will not be fired.
     */
    MultiSelectTreeComponent.prototype.reset = function () {
        this.value = [];
        this.dataItems = [];
        this.valueDepth = [];
    };
    /**
     * Toggles the visibility of the popup
     * ([see example]({% slug openstate_multiselecttree %})).
     * If you use the `toggle` method to open or close the popup, the `open` and `close` events will not be fired.
     *
     * @param open - The state of the popup.
     */
    MultiSelectTreeComponent.prototype.toggle = function (open) {
        var _this = this;
        // The Promise is required to open the popup on load.
        // Otherwise, the "ViewContainerRef not found..." error will be thrown.
        Promise.resolve(null).then(function () {
            var shouldOpen = isPresent(open) ? open : !isPresent(_this.popupRef);
            _this.destroyPopup();
            if (shouldOpen) {
                _this.createPopup();
            }
        });
    };
    /**
     * @hidden
     */
    MultiSelectTreeComponent.prototype.handleFocus = function () {
        var _this = this;
        if (!this.isFocused) {
            this.isFocused = true;
            if (hasObservers(this.onFocus)) {
                this._zone.run(function () {
                    _this.onFocus.emit();
                });
            }
            // Re-focus the treeview if `close` is prevented
            if (this.isOpen && this.treeview) {
                this.lastNodeOnFocus.setAttribute('tabindex', '0');
                this.treeview.focus();
            }
        }
    };
    /**
     * @hidden
     */
    MultiSelectTreeComponent.prototype.handleBlur = function (e) {
        var _this = this;
        var relatedTarget = e && e.relatedTarget;
        if (this.hostElement.nativeElement.contains(relatedTarget) ||
            (this.isOpen && this.popupRef.popupElement.contains(relatedTarget))) {
            return;
        }
        this.isFocused = false;
        this.togglePopup(false);
        if (hasObservers(this.onBlur) ||
            isUntouched(this.hostElement.nativeElement)) {
            this._zone.run(function () {
                _this.onBlur.emit();
                _this.onTouchedCallback();
            });
        }
    };
    /**
     * @hidden
     */
    MultiSelectTreeComponent.prototype.handleClick = function () {
        this.togglePopup(!this.isOpen);
    };
    /**
     * @hidden
     */
    MultiSelectTreeComponent.prototype.handleKeydown = function (event) {
        var deleteTag = this.isWrapperActive && event.keyCode === Keys.Backspace && this.tags.length > 0;
        if (deleteTag) {
            this.handleBackspace();
            return;
        }
        if (this.disabled || this.readonly) {
            return;
        }
        var eventData = event;
        var action = this.navigationService.process({
            originalEvent: eventData
        });
        if (action === NavigationAction.Open) {
            eventData.preventDefault();
        }
    };
    /**
     * @hidden
     */
    MultiSelectTreeComponent.prototype.handleNodeClick = function (node) {
        if (!this.isFocused) {
            // Re-focus the MultiSelectTree when popup close is prevented and a node is clicked
            // On click the focus should be on the clicked element which is why we need to update the lastNodeOnFocus
            var parent_1 = node.originalEvent.target.parentElement.parentElement;
            this.lastNodeOnFocus = parent_1;
            this.focus();
        }
    };
    /**
     * @hidden
     */
    MultiSelectTreeComponent.prototype.togglePopup = function (open) {
        var _this = this;
        var isDisabled = this.disabled || this.readonly;
        var sameState = this.isOpen === open;
        this._zone.run(function () {
            _this.focusedTagIndex = undefined;
        });
        if (isDisabled || sameState) {
            return;
        }
        var togglePrevented = this.triggerPopupEvents(open);
        if (!togglePrevented) {
            open ?
                this.createPopup() :
                this.destroyPopup();
        }
        else {
            this.removeTreeViewFromTabOrder();
        }
    };
    /**
     * @hidden
     */
    MultiSelectTreeComponent.prototype.messageFor = function (key) {
        return this.localization.get(key);
    };
    /**
     * @hidden
     */
    MultiSelectTreeComponent.prototype.handleCheckedItemsChange = function (items) {
        this.valueDepth = items.map(function (item) { return item.level; });
        this.dataItems = items.slice();
        this.updateValue(this.dataItems);
    };
    /**
     * @hidden
     */
    MultiSelectTreeComponent.prototype.handleRemoveTag = function (_a) {
        var _this = this;
        var tag = _a.tag, index = _a.index;
        if (this.disabled || this.readonly) {
            return;
        }
        var eventArgs = new RemoveTagEvent(tag);
        this.removeTag.emit(eventArgs);
        if (eventArgs.isDefaultPrevented()) {
            return;
        }
        // Remove tags based on their position index
        if (tag instanceof Array) {
            // Remove group tag
            this.dataItems = this.dataItems.filter(function (_item, i) { return i < _this.showAfter || _this.disabledIndices.has(i); });
            this.valueDepth = this.valueDepth.filter(function (_item, i) { return i < _this.showAfter || _this.disabledIndices.has(i); });
        }
        else {
            // Remove single tag
            this.dataItems = this.dataItems.filter(function (_item, i) { return i !== index || _this.disabledIndices.has(i); });
            this.valueDepth = this.valueDepth.filter(function (_item, i) { return i !== index || _this.disabledIndices.has(i); });
        }
        this.updateValue(this.dataItems);
        // focus the wrapper if the component is not focused - the floating label reacts to focus/blur
        if (!this.isFocused) {
            this.focus();
        }
    };
    /**
     * @hidden
     */
    MultiSelectTreeComponent.prototype.handleTagMapperChange = function (showAfter) {
        this.showAfter = parseNumber(showAfter);
        this.setTags();
    };
    /**
     * @hidden
     */
    MultiSelectTreeComponent.prototype.clearAll = function (event) {
        var _this = this;
        event.stopImmediatePropagation();
        event.preventDefault();
        this.focus();
        this.value = this.value.filter(function (_item, index) { return _this.disabledIndices.has(index); });
        this.dataItems = this.dataItems.filter(function (_item, index) { return _this.disabledIndices.has(index); });
        this.valueDepth = this.valueDepth.filter(function (_depth, index) { return _this.disabledIndices.has(index); });
        this.emitValueChange(this.value);
    };
    /**
     * @hidden
     */
    MultiSelectTreeComponent.prototype.writeValue = function (value) {
        this.value = value || [];
        // Update the dataItems if the value is updated programmatically (non-primitive values only)
        // In the primitive case, the client should update the dataItems as well
        if (!this.valuePrimitive) {
            this.dataItems = this.value;
        }
    };
    /**
     * @hidden
     */
    MultiSelectTreeComponent.prototype.registerOnChange = function (fn) {
        this.onChangeCallback = fn;
    };
    /**
     * @hidden
     */
    MultiSelectTreeComponent.prototype.registerOnTouched = function (fn) {
        this.onTouchedCallback = fn;
    };
    /**
     * @hidden
     */
    MultiSelectTreeComponent.prototype.setDisabledState = function (isDisabled) {
        this.disabled = isDisabled;
        this.cdr.markForCheck();
    };
    /**
     * @hidden
     */
    MultiSelectTreeComponent.prototype.handleFilterInputChange = function (term) {
        var _this = this;
        this.filterChange.next(term);
        this.allNodesHidden = this.nodes.every(function (node, index) { return !_this.isVisible(node, String(index)); });
    };
    MultiSelectTreeComponent.prototype.verifySettings = function () {
        if (!isDevMode()) {
            return;
        }
        if (!isPresent(this.valueField) || !isPresent(this.textField)) {
            throw new Error(MultiSelectTreeMessages.textAndValue);
        }
        if (!isArray(this.value)) {
            throw new Error(MultiSelectTreeMessages.array);
        }
        if (this.value.length > 0) {
            if (this.valuePrimitive && this.value.some(function (item) { return isObject(item); })) {
                throw new Error(MultiSelectTreeMessages.primitive);
            }
            var isEveryDataItemObject = this.dataItems.every(function (item) { return isObject(item.dataItem); });
            if (this.valuePrimitive && !isArray(this.dataItems)) {
                throw new Error(MultiSelectTreeMessages.dataItems);
            }
            if (this.valuePrimitive && !isEveryDataItemObject) {
                throw new Error(MultiSelectTreeMessages.dataItems);
            }
            if (this.valuePrimitive && this.dataItems.length !== this.value.length) {
                throw new Error(MultiSelectTreeMessages.dataItemsLength);
            }
            if (!this.valuePrimitive && !isObjectArray(this.value)) {
                throw new Error(MultiSelectTreeMessages.object);
            }
            if ((isArray(this.valueField) || isArray(this.textField)) && !isArray(this.valueDepth)) {
                throw new Error(MultiSelectTreeMessages.valueDepth);
            }
            if ((isArray(this.valueField) || isArray(this.textField)) && this.valueDepth.length === 0) {
                throw new Error(MultiSelectTreeMessages.valueDepth);
            }
            if ((isArray(this.valueField) || isArray(this.textField)) && this.valueDepth.length !== this.value.length) {
                throw new Error(MultiSelectTreeMessages.valueDepthLength);
            }
        }
    };
    MultiSelectTreeComponent.prototype.emitValueChange = function (value) {
        this.onChangeCallback(value);
        this.valueChange.emit(value);
    };
    MultiSelectTreeComponent.prototype.triggerPopupEvents = function (open) {
        var eventArgs = new PreventableEvent();
        open ?
            this.open.emit(eventArgs) :
            this.close.emit(eventArgs);
        return eventArgs.isDefaultPrevented();
    };
    MultiSelectTreeComponent.prototype.createPopup = function () {
        var _this = this;
        var horizontalAlign = this.direction === "rtl" ? "right" : "left";
        var anchorPosition = { horizontal: horizontalAlign, vertical: 'bottom' };
        var popupPosition = { horizontal: horizontalAlign, vertical: 'top' };
        this.popupRef = this.popupService.open({
            anchor: this.wrapper,
            appendTo: this.appendTo,
            anchorAlign: anchorPosition,
            content: this.popupTemplate,
            popupAlign: popupPosition,
            positionMode: 'absolute',
            popupClass: this.popupContainerClasses
        });
        var popupWrapper = this.popupRef.popupElement;
        var _a = this.width, min = _a.min, max = _a.max;
        popupWrapper.style.minWidth = min;
        popupWrapper.style.width = max;
        popupWrapper.style.height = this.height;
        this.renderer.setAttribute(popupWrapper, 'dir', this.direction);
        this.renderer.setAttribute(this.wrapper.nativeElement, 'aria-expanded', 'true');
        this.popupRef.popupOpen.subscribe(function () {
            _this.cdr.detectChanges();
            _this.opened.emit();
        });
        this.popupRef.popupClose.subscribe(function () {
            _this.closed.emit();
        });
    };
    MultiSelectTreeComponent.prototype.destroyPopup = function () {
        var _this = this;
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
            this.renderer.setAttribute(this.wrapper.nativeElement, 'aria-expanded', 'false');
            if (this.filter !== "") {
                this.filter = "";
                this.allNodesHidden = false;
                if (hasObservers(this.filterChange)) {
                    this._zone.run(function () {
                        _this.filterChange.emit("");
                    });
                }
            }
        }
    };
    MultiSelectTreeComponent.prototype.subscribeEvents = function () {
        var _this = this;
        this.subscriptions.push(this.navigationService.open.subscribe(function () { return _this.togglePopup(true); }), this.navigationService.enter
            .pipe(tap(function (event) { return event.originalEvent.preventDefault(); }))
            .subscribe(function () { return _this.togglePopup(true); }), merge(this.navigationService.close, this.navigationService.esc).subscribe(function () {
            _this.focus();
            _this.togglePopup(false);
        }), this.navigationService.tab.subscribe(this.handleTabKey.bind(this)), this.navigationService.up.subscribe(this.handleUpKey.bind(this)), this.navigationService.down.subscribe(this.handleDownKey.bind(this)), this.navigationService.left
            .pipe(filter(function () { return !_this.isTreeViewActive; }))
            .subscribe(this.direction === 'rtl' ? this.handleRightKey.bind(this) : this.handleLeftKey.bind(this)), this.navigationService.right
            .pipe(filter(function () { return !_this.isTreeViewActive; }))
            .subscribe(this.direction === 'rtl' ? this.handleLeftKey.bind(this) : this.handleRightKey.bind(this)), this.navigationService.home.pipe(filter(function () { return !_this.isOpen; })).subscribe(this.handleHome.bind(this)), this.navigationService.end.pipe(filter(function () { return !_this.isOpen; })).subscribe(this.handleEnd.bind(this)), this.navigationService.backspace.pipe(filter(function () { return _this.isTagFocused; })).subscribe(this.handleBackspace.bind(this)), this.navigationService.delete.pipe(filter(function () { return _this.isTagFocused; })).subscribe(this.handleDelete.bind(this)));
    };
    MultiSelectTreeComponent.prototype.handleTabKey = function () {
        this.focus();
        if (this.isOpen) {
            this.treeview.blur();
            this.removeTreeViewFromTabOrder();
        }
    };
    MultiSelectTreeComponent.prototype.handleUpKey = function (event) {
        if (!this.treeview) {
            return;
        }
        event.originalEvent.preventDefault();
        // Prevent toggling the focus between the filterInput and the wrapper elements with `up` key
        if (this.isWrapperActive) {
            return;
        }
        var isFirstNodeActive = this.treeview['navigationService']['activeIndex'] === '0';
        if (this.filterable) {
            var isFilterActive = this.filterInput.nativeElement === document.activeElement;
            if (isFilterActive) {
                this.focus();
            }
            else if (!isFilterActive && isFirstNodeActive) {
                this.filterInput.nativeElement.focus();
            }
        }
        if (!this.filterable && isFirstNodeActive) {
            this.focus();
        }
    };
    MultiSelectTreeComponent.prototype.handleDownKey = function (event) {
        if (!this.treeview) {
            return;
        }
        event.originalEvent.preventDefault();
        // Put the focus back on the filter input if the wrapper is focused
        if (this.filterable && this.isWrapperActive) {
            this.filterInput.nativeElement.focus();
        }
        else if (!this.treeview.isActive) {
            this.treeview.focus();
        }
        this.focusedTagIndex = undefined;
    };
    MultiSelectTreeComponent.prototype.handleRightKey = function (event) {
        event.originalEvent.preventDefault();
        var last = this.tags.length - 1;
        if (this.focusedTagIndex === last) {
            this.focusedTagIndex = undefined;
        }
        else if (this.focusedTagIndex < last) {
            this.focusedTagIndex++;
        }
        else if (!this.focusedTagIndex) {
            this.focusedTagIndex = 0;
        }
    };
    MultiSelectTreeComponent.prototype.handleLeftKey = function (event) {
        event.originalEvent.preventDefault();
        if (this.focusedTagIndex === undefined || this.focusedTagIndex < 0) {
            this.focusedTagIndex = this.tags.length - 1;
        }
        else if (this.focusedTagIndex !== 0) {
            this.focusedTagIndex--;
        }
    };
    MultiSelectTreeComponent.prototype.handleEnd = function (event) {
        event.originalEvent.preventDefault();
        this.focusedTagIndex = this.tags.length - 1;
    };
    MultiSelectTreeComponent.prototype.handleHome = function (event) {
        event.originalEvent.preventDefault();
        this.focusedTagIndex = 0;
    };
    MultiSelectTreeComponent.prototype.handleBackspace = function () {
        if (this.focusedTagIndex !== undefined) {
            this.handleDelete();
        }
        else {
            var tag = this.tags[this.tags.length - 1];
            var index = this.tags.length - 1;
            this.handleRemoveTag({ tag: tag, index: index });
        }
    };
    MultiSelectTreeComponent.prototype.handleDelete = function () {
        var tag = this.tags[this.focusedTagIndex];
        var index = this.focusedTagIndex;
        this.handleRemoveTag({ tag: tag, index: index });
        if (this.focusedTagIndex === this.tags.length) {
            this.focusedTagIndex = undefined;
        }
    };
    MultiSelectTreeComponent.prototype.unsubscribeEvents = function () {
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
    };
    /**
     * Remove the `TreeView` from the tab order, otherwise a focus loop between the page elements will occur
     * and the user will not be able to tab to the rest of the browser elements
     */
    MultiSelectTreeComponent.prototype.removeTreeViewFromTabOrder = function () {
        var _this = this;
        var nodes = this.treeview.element.nativeElement.querySelectorAll('li');
        nodes.forEach(function (item) {
            if (item.getAttribute('tabindex') === '0') {
                _this.lastNodeOnFocus = item;
                _this.lastNodeOnFocus.setAttribute('tabindex', '-1');
            }
        });
    };
    MultiSelectTreeComponent.prototype.setState = function () {
        if (isPresent(this.dataItems) && isPresent(this.valueField)) {
            this.setTags();
            this.checkedItems = this.dataItems.slice();
        }
        this.cdr.markForCheck();
    };
    MultiSelectTreeComponent.prototype.setTags = function () {
        var source = this.dataItems.map(function (item) { return item.dataItem; });
        this.tags = this.tagMapper(source);
        this.disabledIndices = this.disabledItemsMapper();
    };
    MultiSelectTreeComponent.prototype.updateValue = function (value) {
        var _this = this;
        var newValue = this.valuePrimitive ?
            value.map(function (item) { return valueFrom(item, _this.valueField); }) :
            value.map(function (item) { return item.dataItem; });
        this.value = newValue;
        this.emitValueChange(this.value);
    };
    /**
     * @hidden
     *
     * Determines which of the provided tags should be disabled and stores their position indices
     */
    MultiSelectTreeComponent.prototype.disabledItemsMapper = function () {
        var _this = this;
        return new Set(this.dataItems.reduce(function (indices, item, index) {
            if (_this.itemDisabled(item.dataItem, item.index)) {
                indices.push(index);
            }
            return indices;
        }, []));
    };
    var MultiSelectTreeComponent_1;
    __decorate([
        HostBinding('class.k-widget'),
        HostBinding('class.k-dropdowntree'),
        __metadata("design:type", Boolean)
    ], MultiSelectTreeComponent.prototype, "hostClasses", void 0);
    __decorate([
        HostBinding('attr.dir'),
        __metadata("design:type", String)
    ], MultiSelectTreeComponent.prototype, "direction", void 0);
    __decorate([
        ContentChild(HeaderTemplateDirective, { static: false }),
        __metadata("design:type", HeaderTemplateDirective)
    ], MultiSelectTreeComponent.prototype, "headerTemplate", void 0);
    __decorate([
        ContentChild(FooterTemplateDirective, { static: false }),
        __metadata("design:type", FooterTemplateDirective)
    ], MultiSelectTreeComponent.prototype, "footerTemplate", void 0);
    __decorate([
        ContentChild(NodeTemplateDirective, { static: false }),
        __metadata("design:type", NodeTemplateDirective)
    ], MultiSelectTreeComponent.prototype, "nodeTemplate", void 0);
    __decorate([
        ContentChild(NoDataTemplateDirective, { static: false }),
        __metadata("design:type", NoDataTemplateDirective)
    ], MultiSelectTreeComponent.prototype, "noDataTemplate", void 0);
    __decorate([
        ContentChild(TagTemplateDirective, { static: false }),
        __metadata("design:type", TagTemplateDirective)
    ], MultiSelectTreeComponent.prototype, "tagTemplate", void 0);
    __decorate([
        ContentChild(GroupTagTemplateDirective, { static: false }),
        __metadata("design:type", GroupTagTemplateDirective)
    ], MultiSelectTreeComponent.prototype, "groupTagTemplate", void 0);
    __decorate([
        ViewChild('popupTemplate', { static: true }),
        __metadata("design:type", TemplateRef)
    ], MultiSelectTreeComponent.prototype, "popupTemplate", void 0);
    __decorate([
        ViewChild('wrapper', { static: true }),
        __metadata("design:type", ElementRef)
    ], MultiSelectTreeComponent.prototype, "wrapper", void 0);
    __decorate([
        ViewChild('container', { read: ViewContainerRef, static: true }),
        __metadata("design:type", ViewContainerRef)
    ], MultiSelectTreeComponent.prototype, "container", void 0);
    __decorate([
        ViewChild('treeview', { static: false }),
        __metadata("design:type", TreeViewComponent),
        __metadata("design:paramtypes", [TreeViewComponent])
    ], MultiSelectTreeComponent.prototype, "treeview", null);
    __decorate([
        ViewChild('filterInput', { static: false }),
        __metadata("design:type", ElementRef)
    ], MultiSelectTreeComponent.prototype, "filterInput", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number),
        __metadata("design:paramtypes", [Number])
    ], MultiSelectTreeComponent.prototype, "tabindex", null);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], MultiSelectTreeComponent.prototype, "popupSettings", null);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], MultiSelectTreeComponent.prototype, "checkableSettings", null);
    __decorate([
        Input(),
        __metadata("design:type", Array),
        __metadata("design:paramtypes", [Array])
    ], MultiSelectTreeComponent.prototype, "data", null);
    __decorate([
        Input(),
        __metadata("design:type", Array),
        __metadata("design:paramtypes", [Array])
    ], MultiSelectTreeComponent.prototype, "value", null);
    __decorate([
        Input(),
        __metadata("design:type", Array),
        __metadata("design:paramtypes", [Array])
    ], MultiSelectTreeComponent.prototype, "dataItems", null);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], MultiSelectTreeComponent.prototype, "textField", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], MultiSelectTreeComponent.prototype, "valueField", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], MultiSelectTreeComponent.prototype, "valueDepth", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], MultiSelectTreeComponent.prototype, "loading", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], MultiSelectTreeComponent.prototype, "placeholder", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], MultiSelectTreeComponent.prototype, "listHeight", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], MultiSelectTreeComponent.prototype, "disabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], MultiSelectTreeComponent.prototype, "readonly", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], MultiSelectTreeComponent.prototype, "valuePrimitive", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], MultiSelectTreeComponent.prototype, "loadOnDemand", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], MultiSelectTreeComponent.prototype, "focusableId", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], MultiSelectTreeComponent.prototype, "clearButton", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], MultiSelectTreeComponent.prototype, "filterable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], MultiSelectTreeComponent.prototype, "hasChildren", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], MultiSelectTreeComponent.prototype, "fetchChildren", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], MultiSelectTreeComponent.prototype, "isNodeExpanded", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], MultiSelectTreeComponent.prototype, "isNodeVisible", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], MultiSelectTreeComponent.prototype, "itemDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], MultiSelectTreeComponent.prototype, "tagMapper", void 0);
    __decorate([
        Output('focus'),
        __metadata("design:type", EventEmitter)
    ], MultiSelectTreeComponent.prototype, "onFocus", void 0);
    __decorate([
        Output('blur'),
        __metadata("design:type", EventEmitter)
    ], MultiSelectTreeComponent.prototype, "onBlur", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MultiSelectTreeComponent.prototype, "open", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MultiSelectTreeComponent.prototype, "opened", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MultiSelectTreeComponent.prototype, "close", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MultiSelectTreeComponent.prototype, "closed", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MultiSelectTreeComponent.prototype, "nodeExpand", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MultiSelectTreeComponent.prototype, "nodeCollapse", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MultiSelectTreeComponent.prototype, "valueChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MultiSelectTreeComponent.prototype, "removeTag", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MultiSelectTreeComponent.prototype, "filterChange", void 0);
    MultiSelectTreeComponent = MultiSelectTreeComponent_1 = __decorate([
        Component({
            exportAs: 'kendoMultiSelectTree',
            providers: [
                LocalizationService,
                NavigationService,
                DataService,
                DisabledItemsService,
                SelectionService,
                {
                    provide: L10N_PREFIX,
                    useValue: 'kendo.multiselecttree'
                },
                {
                    multi: true,
                    provide: NG_VALUE_ACCESSOR,
                    useExisting: forwardRef(function () { return MultiSelectTreeComponent_1; })
                },
                {
                    provide: DataBoundComponent,
                    useExisting: forwardRef(function () { return MultiSelectTreeComponent_1; })
                },
                {
                    provide: ExpandableComponent,
                    useExisting: forwardRef(function () { return MultiSelectTreeComponent_1; })
                },
                {
                    provide: KendoInput,
                    useExisting: forwardRef(function () { return MultiSelectTreeComponent_1; })
                }
            ],
            selector: 'kendo-multiselecttree',
            template: "\n        <ng-container kendoMultiSelectTreeLocalizedMessages\n            i18n-noDataText=\"kendo.multiselecttree.noDataText|The text displayed in the popup when there are no items\"\n            noDataText=\"NO DATA FOUND\"\n\n            i18n-clearTitle=\"kendo.multiselecttree.clearTitle|The title of the clear button\"\n            clearTitle=\"clear\"\n        >\n        </ng-container>\n        <div #wrapper\n            [ngClass]=\"{\n                'k-multiselect-wrap': true,\n                'k-floatwrap': true,\n                'k-state-disabled': this.disabled\n            }\"\n            role=\"listbox\"\n            aria-haspopup=\"tree\"\n            [attr.aria-describedby]=\"tagListId\"\n            [attr.aria-readonly]=\"readonly\"\n            [attr.aria-activedescendant]=\"focusedTagId\"\n            [attr.tabindex]=\"tabindex\"\n            [attr.id]=\"focusableId\"\n            [attr.dir]=\"direction\"\n            (click)=\"handleClick()\"\n            (keydown)=\"handleKeydown($event)\"\n            [kendoEventsOutsideAngular]=\"{\n                focus: handleFocus,\n                blur: handleBlur\n            }\"\n            [scope]=\"this\"\n        >\n            <kendo-taglist\n                [id]=\"tagListId\"\n                [tags]=\"tags\"\n                [focused]=\"focusedTagIndex\"\n                [textField]=\"textField\"\n                [valueField]=\"valueField\"\n                [valueDepth]=\"valueDepth\"\n                [disabled]=\"disabled\"\n                [tagPrefix]=\"tagPrefix\"\n                [template]=\"tagTemplate\"\n                [groupTemplate]=\"groupTagTemplate\"\n                [disabledIndices]=\"disabledIndices\"\n                (removeTag)=\"handleRemoveTag($event)\"\n            >\n            </kendo-taglist>\n            <span *ngIf=\"!tags || !tags.length\"\n                class=\"k-input k-readonly\"\n            >\n                {{ placeholder }}\n            </span>\n            <span\n                *ngIf=\"!disabled && !loading && !readonly && clearButton && tags?.length\"\n                class=\"k-icon k-clear-value k-i-close\"\n                [attr.title]=\"messageFor('clearTitle')\"\n                role=\"button\"\n                tabindex=\"-1\"\n                (click)=\"clearAll($event)\"\n            >\n            </span>\n            <span\n                *ngIf=\"loading\"\n                class=\"k-icon k-i-loading\"\n            >\n            </span>\n        </div>\n        <ng-template #popupTemplate>\n            <span\n                *ngIf=\"filterable\"\n                class=\"k-list-filter\"\n            >\n                <input\n                    #filterInput\n                    (input)=\"handleFilterInputChange($event.target.value)\"\n                    [filterInput]=\"filterable && !touchEnabled\"\n                    (keydown.arrowdown)=\"handleKeydown($event)\"\n                    (keydown.arrowup)=\"handleKeydown($event)\"\n                    (keydown.alt.arrowup)=\"handleKeydown($event)\"\n                    [(ngModel)]=\"filter\"\n                    class=\"k-textbox\"\n                    role=\"textbox\"\n                    aria-haspopup=\"true\"\n                    aria-expanded=\"false\"\n                    tabindex=\"0\"\n                    aria-disabled=\"false\"\n                    aria-readonly=\"false\"\n                    [kendoEventsOutsideAngular]=\"{\n                        blur: handleBlur\n                    }\"\n                    [scope]=\"this\"\n                >\n                <span class=\"k-icon k-i-zoom\"></span>\n            </span>\n            <!--header template-->\n            <ng-template\n                *ngIf=\"headerTemplate\"\n                [templateContext]=\"{\n                    templateRef: headerTemplate?.templateRef\n                }\">\n            </ng-template>\n            <kendo-treeview\n                #treeview\n                [nodes]=\"data\"\n                [style.maxHeight.px]=\"listHeight\"\n                [animate]=\"false\"\n                kendoMultiSelectTreeCheckable\n                [checkable]=\"checkableSettings\"\n                [checkedItems]=\"checkedItems\"\n                [valueField]=\"valueField\"\n                [textField]=\"textField\"\n                [children]=\"children\"\n                [hasChildren]=\"hasChildren\"\n                [isExpanded]=\"isNodeExpanded\"\n                [isDisabled]=\"itemDisabled\"\n                [nodeTemplate]=\"nodeTemplate\"\n                [loadOnDemand]=\"loadOnDemand\"\n                [filter]=\"filter\"\n                [isVisible]=\"isNodeVisible\"\n                (keydown)=\"handleKeydown($event)\"\n                (nodeClick)=\"handleNodeClick($event)\"\n                (expand)=\"nodeExpand.emit($event)\"\n                (collapse)=\"nodeCollapse.emit($event)\"\n                (checkedItemsChange)=\"handleCheckedItemsChange($event)\"\n                [kendoEventsOutsideAngular]=\"{\n                    focusout: handleBlur\n                }\"\n                [scope]=\"this\"\n            >\n            </kendo-treeview>\n            <!--footer template-->\n            <ng-template\n                *ngIf=\"footerTemplate\"\n                [templateContext]=\"{\n                    templateRef: footerTemplate?.templateRef\n                }\">\n            </ng-template>\n            <!--no-data template-->\n            <div class=\"k-nodata\" *ngIf=\"data?.length === 0 || allNodesHidden\">\n                <ng-template [ngIf]=\"noDataTemplate\"\n                    [templateContext]=\"{\n                        templateRef: noDataTemplate?.templateRef\n                    }\">\n                </ng-template>\n                <ng-template [ngIf]=\"!noDataTemplate\">\n                    <div>{{ messageFor('noDataText') }}</div>\n                </ng-template>\n            </div>\n        </ng-template>\n        <ng-container #container></ng-container>\n    "
        }),
        __param(7, Optional()), __param(7, Inject(TOUCH_ENABLED)),
        __metadata("design:paramtypes", [PopupService,
            Renderer2,
            ElementRef,
            NavigationService,
            NgZone,
            LocalizationService,
            ChangeDetectorRef, Boolean])
    ], MultiSelectTreeComponent);
    return MultiSelectTreeComponent;
}());

/**
 * A directive which encapsulates the retrieval of the child nodes when flat data is provided.
 */
var DropDownTreeFlatBindingDirective = /** @class */ (function (_super) {
    __extends(DropDownTreeFlatBindingDirective, _super);
    function DropDownTreeFlatBindingDirective(dropDownTree) {
        return _super.call(this, dropDownTree) || this;
    }
    __decorate([
        Input('kendoDropDownTreeFlatBinding'),
        __metadata("design:type", Array)
    ], DropDownTreeFlatBindingDirective.prototype, "nodes", void 0);
    __decorate([
        Input('valueField'),
        __metadata("design:type", String)
    ], DropDownTreeFlatBindingDirective.prototype, "idField", void 0);
    DropDownTreeFlatBindingDirective = __decorate([
        Directive({
            selector: '[kendoDropDownTreeFlatBinding]'
        }),
        __metadata("design:paramtypes", [DataBoundComponent])
    ], DropDownTreeFlatBindingDirective);
    return DropDownTreeFlatBindingDirective;
}(FlatDataBindingDirective));

/**
 * A directive which encapsulates the retrieval of the child nodes when hierarchical data is provided.
 */
var DropDownTreeHierarchyBindingDirective = /** @class */ (function (_super) {
    __extends(DropDownTreeHierarchyBindingDirective, _super);
    function DropDownTreeHierarchyBindingDirective(dropDownTree) {
        var _this = _super.call(this, dropDownTree) || this;
        _this.dropDownTree = dropDownTree;
        return _this;
    }
    Object.defineProperty(DropDownTreeHierarchyBindingDirective.prototype, "data", {
        /**
         * The nodes which will be displayed by the DropDownTree.
         */
        set: function (nodes) {
            this.dropDownTree.nodes = nodes;
            this.nodes = nodes;
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        Input('kendoDropDownTreeHierarchyBinding'),
        __metadata("design:type", Array),
        __metadata("design:paramtypes", [Array])
    ], DropDownTreeHierarchyBindingDirective.prototype, "data", null);
    DropDownTreeHierarchyBindingDirective = __decorate([
        Directive({
            selector: '[kendoDropDownTreeHierarchyBinding]'
        }),
        __metadata("design:paramtypes", [DataBoundComponent])
    ], DropDownTreeHierarchyBindingDirective);
    return DropDownTreeHierarchyBindingDirective;
}(HierarchyBindingDirective));

/**
 * A directive which encapsulates the retrieval of the child nodes when flat data is provided.
 */
var MultiSelectTreeFlatBindingDirective = /** @class */ (function (_super) {
    __extends(MultiSelectTreeFlatBindingDirective, _super);
    function MultiSelectTreeFlatBindingDirective(multiSelectTree) {
        return _super.call(this, multiSelectTree) || this;
    }
    __decorate([
        Input('kendoMultiSelectTreeFlatBinding'),
        __metadata("design:type", Array)
    ], MultiSelectTreeFlatBindingDirective.prototype, "nodes", void 0);
    __decorate([
        Input('valueField'),
        __metadata("design:type", String)
    ], MultiSelectTreeFlatBindingDirective.prototype, "idField", void 0);
    MultiSelectTreeFlatBindingDirective = __decorate([
        Directive({
            selector: '[kendoMultiSelectTreeFlatBinding]'
        }),
        __metadata("design:paramtypes", [DataBoundComponent])
    ], MultiSelectTreeFlatBindingDirective);
    return MultiSelectTreeFlatBindingDirective;
}(FlatDataBindingDirective));

/**
 * A directive which encapsulates the retrieval of the child nodes when hierarchical data is provided.
 */
var MultiSelectTreeHierarchyBindingDirective = /** @class */ (function (_super) {
    __extends(MultiSelectTreeHierarchyBindingDirective, _super);
    function MultiSelectTreeHierarchyBindingDirective(multiSelectTree) {
        var _this = _super.call(this, multiSelectTree) || this;
        _this.multiSelectTree = multiSelectTree;
        return _this;
    }
    Object.defineProperty(MultiSelectTreeHierarchyBindingDirective.prototype, "data", {
        /**
         * The nodes which will be displayed by the MultiSelectTree.
         */
        set: function (nodes) {
            this.multiSelectTree.nodes = nodes;
            this.nodes = nodes;
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        Input('kendoMultiSelectTreeHierarchyBinding'),
        __metadata("design:type", Array),
        __metadata("design:paramtypes", [Array])
    ], MultiSelectTreeHierarchyBindingDirective.prototype, "data", null);
    MultiSelectTreeHierarchyBindingDirective = __decorate([
        Directive({
            selector: '[kendoMultiSelectTreeHierarchyBinding]'
        }),
        __metadata("design:paramtypes", [DataBoundComponent])
    ], MultiSelectTreeHierarchyBindingDirective);
    return MultiSelectTreeHierarchyBindingDirective;
}(HierarchyBindingDirective));

/**
 * A directive which manages the expanded state of the popup TreeView.
 */
var DropDownTreesExpandDirective = /** @class */ (function (_super) {
    __extends(DropDownTreesExpandDirective, _super);
    function DropDownTreesExpandDirective(dropDownTree) {
        return _super.call(this, dropDownTree) || this;
    }
    __decorate([
        Input('isNodeExpanded'),
        __metadata("design:type", Function)
    ], DropDownTreesExpandDirective.prototype, "isExpanded", void 0);
    DropDownTreesExpandDirective = __decorate([
        Directive({
            selector: '[kendoDropDownTreeExpandable], [kendoMultiSelectTreeExpandable]'
        }),
        __metadata("design:paramtypes", [ExpandableComponent])
    ], DropDownTreesExpandDirective);
    return DropDownTreesExpandDirective;
}(ExpandDirective));

/**
 * @hidden
 */
var TagListComponent = /** @class */ (function () {
    function TagListComponent() {
        /**
         * A collection with the disabled tags' indices.
         */
        this.disabledIndices = new Set();
        this.removeTag = new EventEmitter();
    }
    TagListComponent.prototype.tagProp = function (tag, prop, index) {
        var propField = prop && this.getPropField(tag, prop, index);
        return getter$1(tag, propField);
    };
    TagListComponent.prototype.isTagDisabled = function (tag, positionIndex) {
        var _this = this;
        if (this.isGroupTag(tag)) {
            /** The `positionIndex` is used to determine after how many single tags is the group tag displayed =>
             * => it is used to increment the indices inside the group tag so that we determine the actual position index
             * of each group tag item as they appear in the `value` (important to check against `disabledIndices`)
             * e.g. `disabledIndices = [0, 1]` && `tags = ['Small', ['Medium', 'Large']]` => without the incrementation with
             * `positionIndex`, the group tag would yield [0, 1] as indices, while it should yield [1, 2]
             */
            return tag.every(function (_tag, index) { return _this.disabledIndices.has(index + positionIndex); });
        }
        return this.disabledIndices.has(positionIndex);
    };
    TagListComponent.prototype.deleteTag = function (event, tag, index) {
        event.preventDefault();
        event.stopImmediatePropagation();
        if (!this.disabled && event.which === 1) {
            this.removeTag.emit({ tag: tag, index: index });
        }
    };
    TagListComponent.prototype.itemId = function (tag, index) {
        if (tag) { //because of custom values
            return this.tagPrefix + "-" + this.tagProp(tag, this.valueField, index);
        }
    };
    TagListComponent.prototype.isGroupTag = function (tag) {
        return tag instanceof Array;
    };
    TagListComponent.prototype.tagAriaHidden = function (index) {
        return isPresent(this.focused) && this.focused !== index;
    };
    TagListComponent.prototype.getPropField = function (tag, prop, index) {
        // Needed for MultiSelectTree value binding (Heterogeneous Data)
        var fieldsCount = prop.length - 1;
        if (typeof prop === 'string') {
            return prop;
        }
        else if (this.valueDepth) {
            var depth = this.valueDepth[index];
            return fieldsCount < depth ? prop[fieldsCount] : prop[depth];
        }
        else {
            return prop.find(function (item) { return item in tag; });
        }
    };
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], TagListComponent.prototype, "tags", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TagListComponent.prototype, "textField", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TagListComponent.prototype, "valueField", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], TagListComponent.prototype, "valueDepth", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], TagListComponent.prototype, "focused", void 0);
    __decorate([
        Input(),
        __metadata("design:type", TagTemplateDirective)
    ], TagListComponent.prototype, "template", void 0);
    __decorate([
        Input(),
        __metadata("design:type", GroupTagTemplateDirective)
    ], TagListComponent.prototype, "groupTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TagListComponent.prototype, "disabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TagListComponent.prototype, "tagPrefix", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TagListComponent.prototype, "id", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Set)
    ], TagListComponent.prototype, "disabledIndices", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], TagListComponent.prototype, "removeTag", void 0);
    TagListComponent = __decorate([
        Component({
            selector: 'kendo-taglist',
            template: "\n        <ul [attr.id]=\"id\" class=\"k-reset\">\n            <li\n                *ngFor=\"let tag of tags; let index = index;\"\n                role=\"option\"\n                [attr.id]=\"itemId(tag, index)\"\n                [attr.aria-hidden]=\"tagAriaHidden(index)\"\n                aria-selected=\"true\"\n                [attr.aria-setsize]=\"tags?.length\"\n                class=\"k-button\"\n                [ngClass]=\"{\n                    'k-state-focused': index === focused,\n                    'k-state-disabled': isTagDisabled(tag, index)\n                }\"\n            >\n                <ng-template *ngIf=\"isGroupTag(tag); then groupTag else singleTag\"></ng-template>\n                    <ng-template #groupTag>\n                        <span>\n                            <ng-template *ngIf=\"groupTemplate\"\n                                [templateContext]=\"{\n                                templateRef: groupTemplate.templateRef,\n                                $implicit: tag\n                            }\">\n                            </ng-template>\n                            <ng-template [ngIf]=\"!groupTemplate\">{{ tag.length }} {{ tag.length === 1 ? 'item' : 'items' }} selected</ng-template>\n                        </span>\n                    </ng-template>\n                    <ng-template #singleTag>\n                        <span>\n                            <ng-template *ngIf=\"template\"\n                                [templateContext]=\"{\n                                templateRef: template.templateRef,\n                                $implicit: tag\n                            }\">\n                            </ng-template>\n                            <ng-template [ngIf]=\"!template\">{{ tagProp(tag, textField, index) }}</ng-template>\n                        </span>\n                    </ng-template>\n\n                <span aria-label=\"delete\" [attr.aria-hidden]=\"index !== focused\" class=\"k-select\">\n                    <span class=\"k-icon k-i-close\" (mousedown)=\"deleteTag($event, tag, index)\">\n                    </span>\n                </span>\n            </li>\n        </ul>\n  "
        })
    ], TagListComponent);
    return TagListComponent;
}());

/**
 * @hidden
 */
var Messages = /** @class */ (function (_super) {
    __extends(Messages, _super);
    function Messages() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], Messages.prototype, "noDataText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], Messages.prototype, "clearTitle", void 0);
    return Messages;
}(ComponentMessages));

/**
 * @hidden
 */
var LocalizedMessagesDirective = /** @class */ (function (_super) {
    __extends(LocalizedMessagesDirective, _super);
    function LocalizedMessagesDirective(service) {
        var _this = _super.call(this) || this;
        _this.service = service;
        return _this;
    }
    LocalizedMessagesDirective_1 = LocalizedMessagesDirective;
    var LocalizedMessagesDirective_1;
    LocalizedMessagesDirective = LocalizedMessagesDirective_1 = __decorate([
        Directive({
            providers: [
                {
                    provide: Messages,
                    useExisting: forwardRef(function () { return LocalizedMessagesDirective_1; })
                }
            ],
            selector: "\n    [kendoDropDownListLocalizedMessages],\n    [kendoDropDownTreeLocalizedMessages],\n    [kendoComboBoxLocalizedMessages],\n    [kendoMultiColumnComboBoxLocalizedMessages],\n    [kendoAutoCompleteLocalizedMessages],\n    [kendoMultiSelectLocalizedMessages],\n    [kendoMultiSelectTreeLocalizedMessages]\n  "
        }),
        __metadata("design:paramtypes", [LocalizationService])
    ], LocalizedMessagesDirective);
    return LocalizedMessagesDirective;
}(Messages));

/**
 * Custom component messages override default component messages
 * ([see example]({% slug rtl_dropdowns %}#toc-messages)).
 */
var CustomMessagesComponent = /** @class */ (function (_super) {
    __extends(CustomMessagesComponent, _super);
    function CustomMessagesComponent(service) {
        var _this = _super.call(this) || this;
        _this.service = service;
        return _this;
    }
    CustomMessagesComponent_1 = CustomMessagesComponent;
    Object.defineProperty(CustomMessagesComponent.prototype, "override", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    var CustomMessagesComponent_1;
    CustomMessagesComponent = CustomMessagesComponent_1 = __decorate([
        Component({
            providers: [
                {
                    provide: Messages,
                    useExisting: forwardRef(function () { return CustomMessagesComponent_1; })
                }
            ],
            selector: 'kendo-dropdownlist-messages,kendo-combobox-messages,kendo-multicolumncombobox-messages,kendo-autocomplete-messages,kendo-multiselect-messages,kendo-dropdowntree-messages,kendo-multiselecttree-messages',
            template: ""
        }),
        __metadata("design:paramtypes", [LocalizationService])
    ], CustomMessagesComponent);
    return CustomMessagesComponent;
}(Messages));

var DEFAULT_FILTER_SETTINGS = {
    caseSensitive: false,
    operator: 'startsWith'
};
/**
 * Implements an event handler for the `filterChange` event of a DropDowns component
 * which performs simple data filtering.
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-autocomplete
 *      [data]="data"
 *      kendoDropDownFilter
 *      placeholder="e.g. Andorra"
 *  >
 *  </kendo-autocomplete>
 * `
 * })
 * class AppComponent {
 *     public data: Array<string> = ["Albania", "Andorra", "Armenia", "Austria", "Azerbaijan"];
 * }
 * ```
 */
var FilterDirective = /** @class */ (function () {
    function FilterDirective(component) {
        this.component = component;
        /**
         * @hidden
         *
         * Sets whether the filtering functionality is enabled on component init.
         */
        this.filterable = true;
        this._data = [];
    }
    Object.defineProperty(FilterDirective.prototype, "data", {
        get: function () {
            return this._data;
        },
        /**
         * The initial data that will be used as a source array for the filtering operations.
         */
        set: function (data) {
            this._data = data || [];
        },
        enumerable: true,
        configurable: true
    });
    FilterDirective.prototype.ngOnInit = function () {
        this.component.filterable = this.filterable;
        this.filterChangeSubscription = this.component.filterChange
            .subscribe(this.handleFilterChange.bind(this));
    };
    FilterDirective.prototype.ngOnDestroy = function () {
        if (isPresent(this.filterChangeSubscription)) {
            this.filterChangeSubscription.unsubscribe();
        }
    };
    FilterDirective.prototype.handleFilterChange = function (query) {
        var _this = this;
        this.component.data = this.data.filter(function (item) { return _this.matchesAnyField(item, query); });
    };
    FilterDirective.prototype.matchesAnyField = function (item, query) {
        var _this = this;
        var normalizedQuery = this.normalizeValue(query);
        var fields = this.filterSettings.fields;
        // if no filter fields are present, we are dealing with primitive data
        if (fields.length === 0) {
            return this.checkItem(item, normalizedQuery);
        }
        return fields.some(function (field) { return _this.checkItem(getter$1(item, field), normalizedQuery); });
    };
    FilterDirective.prototype.checkItem = function (target, query) {
        target = this.normalizeValue(target);
        if (this.filterSettings.operator === 'contains') {
            return target.indexOf(query) !== -1;
        }
        else {
            return target.indexOf(query) === 0;
        }
    };
    FilterDirective.prototype.normalizeValue = function (value) {
        var normalizedValue = isPresent(value) ? value.toString() : '';
        return this.filterSettings.caseSensitive ? normalizedValue : normalizedValue.toLowerCase();
    };
    FilterDirective.prototype.getFilterFields = function (providedFields) {
        // ignore provided fields if the component deals with primitive data
        if (!this.component.textField && !this.component.valueField) {
            return [];
        }
        if (isArray(providedFields) && providedFields.length > 0) {
            return providedFields;
        }
        else {
            // the autocomplete uses `valueField` for text extraction
            var textField = this.component.textField || this.component.valueField;
            return [textField];
        }
    };
    Object.defineProperty(FilterDirective.prototype, "filterSettings", {
        get: function () {
            var settings = this.rawSettings;
            var providedFields = isPresent(settings) && typeof settings === 'object' ? settings.fields : [];
            return Object.assign({}, DEFAULT_FILTER_SETTINGS, settings, { fields: this.getFilterFields(providedFields) });
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        Input(),
        __metadata("design:type", Array),
        __metadata("design:paramtypes", [Array])
    ], FilterDirective.prototype, "data", null);
    __decorate([
        Input('kendoDropDownFilter'),
        __metadata("design:type", Object)
    ], FilterDirective.prototype, "rawSettings", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], FilterDirective.prototype, "filterable", void 0);
    FilterDirective = __decorate([
        Directive({
            selector: '[kendoDropDownFilter]'
        }),
        __metadata("design:paramtypes", [FilterableComponent])
    ], FilterDirective);
    return FilterDirective;
}());

/**
 * @hidden
 */
var FilterInputDirective = /** @class */ (function () {
    function FilterInputDirective(element, zone) {
        this.element = element;
        this.zone = zone;
    }
    FilterInputDirective.prototype.ngOnChanges = function () {
        var _this = this;
        if (this.focused) {
            this.nextTick(function () { return _this.element.nativeElement.focus(); });
        }
    };
    FilterInputDirective.prototype.nextTick = function (fn) {
        this.zone.runOutsideAngular(function () { return setTimeout(fn); });
    };
    __decorate([
        Input('filterInput'),
        __metadata("design:type", Boolean)
    ], FilterInputDirective.prototype, "focused", void 0);
    FilterInputDirective = __decorate([
        Directive({
            selector: '[filterInput]' // tslint:disable-line
        }),
        __metadata("design:paramtypes", [ElementRef,
            NgZone])
    ], FilterInputDirective);
    return FilterInputDirective;
}());

var SHARED_DIRECTIVES = [
    HeaderTemplateDirective,
    FooterTemplateDirective,
    ItemTemplateDirective,
    GroupTemplateDirective,
    FixedGroupTemplateDirective,
    NoDataTemplateDirective,
    ValueTemplateDirective,
    TagTemplateDirective,
    GroupTagTemplateDirective,
    LocalizedMessagesDirective,
    CustomMessagesComponent,
    FilterDirective,
    FilterInputDirective
];
/**
 * @hidden
 *
 * The exported package module.
 *
 * The package exports:
 * - `ItemTemplateDirective`&mdash;The item template directive.
 * - `ValueTemplateDirective`&mdash;The value template directive.
 * - `HeaderTemplateDirective`&mdash;The header template directive.
 * - `FooterTemplateDirective`&mdash;The footer template directive.
 * - `NoDataTemplateDirective`&mdash;The noData template directive.
 * - `TagTemplateDirective`&mdash;The tag template directive.
 * - `SummaryTagTemplateDirective`&mdash;The summary tag template directive.
 */
var SharedDirectivesModule = /** @class */ (function () {
    function SharedDirectivesModule() {
    }
    SharedDirectivesModule = __decorate([
        NgModule({
            declarations: [SHARED_DIRECTIVES],
            exports: [SHARED_DIRECTIVES]
        })
    ], SharedDirectivesModule);
    return SharedDirectivesModule;
}());

/**
 * @hidden
 */
var SelectableDirective = /** @class */ (function () {
    function SelectableDirective(selectionService) {
        this.checkboxes = { enabled: false };
        // @HostBinding('attr.offset-index')
        // @Input() public offsetIndex: number;
        this.multipleSelection = false;
        this.selectionService = selectionService;
    }
    Object.defineProperty(SelectableDirective.prototype, "focusedClassName", {
        get: function () {
            return this.selectionService.isFocused(this.index);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectableDirective.prototype, "selectedClassName", {
        get: function () {
            return !this.checkboxes.enabled && this.selectionService.isSelected(this.index);
        },
        enumerable: true,
        configurable: true
    });
    SelectableDirective.prototype.onClick = function (event) {
        event.stopPropagation();
        if (this.checkboxes.enabled && !this.checkboxes.checkOnClick) {
            return;
        }
        if (this.multipleSelection) {
            if (this.selectionService.isSelected(this.index)) {
                this.selectionService.unselect(this.index);
            }
            else {
                this.selectionService.add(this.index);
            }
        }
        else {
            this.selectionService.change(this.index);
        }
    };
    __decorate([
        HostBinding('attr.index'),
        Input(),
        __metadata("design:type", Number)
    ], SelectableDirective.prototype, "index", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SelectableDirective.prototype, "checkboxes", void 0);
    __decorate([
        HostBinding('style.height.px'),
        HostBinding('style.minHeight.px'),
        Input(),
        __metadata("design:type", Number)
    ], SelectableDirective.prototype, "height", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SelectableDirective.prototype, "multipleSelection", void 0);
    __decorate([
        HostBinding('class.k-state-focused'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], SelectableDirective.prototype, "focusedClassName", null);
    __decorate([
        HostBinding('class.k-state-selected'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], SelectableDirective.prototype, "selectedClassName", null);
    __decorate([
        HostListener('click', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], SelectableDirective.prototype, "onClick", null);
    SelectableDirective = __decorate([
        Directive({
            selector: '[kendoDropDownsSelectable]'
        }),
        __metadata("design:paramtypes", [SelectionService])
    ], SelectableDirective);
    return SelectableDirective;
}());

/**
 * @hidden
 */
var TemplateContextDirective = /** @class */ (function () {
    function TemplateContextDirective(viewContainerRef) {
        this.viewContainerRef = viewContainerRef;
    }
    Object.defineProperty(TemplateContextDirective.prototype, "templateContext", {
        set: function (context) {
            if (this.insertedViewRef) {
                this.viewContainerRef.remove(this.viewContainerRef.indexOf(this.insertedViewRef));
                this.insertedViewRef = undefined;
            }
            if (context.templateRef) {
                this.insertedViewRef = this.viewContainerRef.createEmbeddedView(context.templateRef, context);
            }
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], TemplateContextDirective.prototype, "templateContext", null);
    TemplateContextDirective = __decorate([
        Directive({
            selector: '[templateContext]' // tslint:disable-line
        }),
        __metadata("design:paramtypes", [ViewContainerRef])
    ], TemplateContextDirective);
    return TemplateContextDirective;
}());

/**
 * @hidden
 *
 * A directive which manages the in-memory checked state of the MultiSelectTree nodes.
 */
var CheckDirective = /** @class */ (function () {
    function CheckDirective(treeView) {
        this.treeView = treeView;
        /**
         * Fires when the `checkedItems` collection was updated.
         */
        this.checkedItemsChange = new EventEmitter();
        /**
         * Holds a Set with just the checked item keys.
         *
         * Should be updated each time the `checkedItems` value or content is changed.
         * Can be used for efficient look-up of whether an item is checked or not (O(1) access time).
         */
        this.checkedKeys = new Set();
        this.subscriptions = new Subscription();
        this.subscriptions.add(this.treeView.checkedChange
            .subscribe(this.handleCheckedChange.bind(this)));
        this.treeView.isChecked = this.getCheckedState.bind(this);
    }
    CheckDirective.prototype.ngOnChanges = function (changes) {
        var _this = this;
        if (isPresent(changes.checkable)) {
            this.toggleCheckOnClick();
        }
        if (isPresent(changes.checkedItems)) {
            this.checkedItems = this.checkedItems || [];
            this.checkedKeys = new Set(this.checkedItems.map(function (item) { return valueFrom(item, _this.valueField); }));
        }
    };
    CheckDirective.prototype.ngOnDestroy = function () {
        this.subscriptions.unsubscribe();
        this.unsubscribeClick();
    };
    CheckDirective.prototype.getCheckedState = function (dataItem, index) {
        if (this.isItemChecked({ dataItem: dataItem, index: index })) {
            return 'checked';
        }
        else if (this.checkable.checkChildren && this.isItemIndeterminate(this.treeView.itemLookup(index))) {
            return 'indeterminate';
        }
        else {
            return 'none';
        }
    };
    CheckDirective.prototype.handleCheckedChange = function (node) {
        this.checkNode(node);
        // parents should be checked if `checkChildren` is set to `true` (single config option for both)
        var checkParents = this.checkable.checkChildren;
        if (checkParents) {
            this.checkParents(node.parent);
        }
        this.checkedItemsChange.emit(this.checkedItems.slice());
    };
    CheckDirective.prototype.toggleCheckOnClick = function () {
        var _this = this;
        this.unsubscribeClick();
        if (this.checkable.checkOnClick) {
            this.clickSubscription = this.treeView.nodeClick
                .pipe(filter(function (event) { return event.type === 'click'; }))
                .subscribe(function (event) {
                var lookup = _this.treeView.itemLookup(event.item.index);
                _this.handleCheckedChange(lookup);
            });
        }
    };
    CheckDirective.prototype.unsubscribeClick = function () {
        if (this.clickSubscription) {
            this.clickSubscription.unsubscribe();
            this.clickSubscription = null;
        }
    };
    CheckDirective.prototype.checkNode = function (lookup) {
        var _this = this;
        if (this.treeView.isDisabled(lookup.item.dataItem, lookup.item.index)) {
            return;
        }
        var target = lookup.item;
        var pendingCheck = [target];
        // TODO: extract in a separate `checkChildren` method?
        if (this.checkable.checkChildren) {
            var filter_1 = function (item) {
                return _this.treeView.isVisible(item.dataItem, item.index) &&
                    !_this.treeView.isDisabled(item.dataItem, item.index);
            };
            fetchDescendentNodes(lookup, filter_1)
                .forEach(function (lookup) { return pendingCheck.push(lookup.item); });
        }
        var shouldCheck = !this.isItemChecked(target);
        pendingCheck.forEach(function (item) {
            if (shouldCheck) {
                _this.addItem(item);
            }
            else {
                _this.removeItem(item);
            }
        });
    };
    CheckDirective.prototype.checkParents = function (parent) {
        var _this = this;
        var currentParent = parent;
        while (currentParent) {
            var allChildrenSelected = currentParent.children.every(function (item) { return _this.isItemChecked(item); });
            if (allChildrenSelected) {
                this.addItem(currentParent.item);
            }
            else {
                this.removeItem(currentParent.item);
            }
            currentParent = currentParent.parent;
        }
    };
    CheckDirective.prototype.addItem = function (item) {
        if (this.isItemChecked(item)) {
            return;
        }
        var level = getHierarchicalItemLevel(item.index);
        var candidate = __assign({}, item, { level: level });
        this.checkedItems.push(candidate);
        this.checkedKeys.add(valueFrom(candidate, this.valueField));
    };
    CheckDirective.prototype.removeItem = function (item) {
        var _this = this;
        if (!this.isItemChecked(item)) {
            return;
        }
        var level = getHierarchicalItemLevel(item.index);
        var candidate = __assign({}, item, { level: level });
        this.checkedItems = this.checkedItems
            .filter(function (item) { return valueFrom(item, _this.valueField) !== valueFrom(candidate, _this.valueField); });
        this.checkedKeys.delete(valueFrom(candidate, this.valueField));
    };
    CheckDirective.prototype.isItemChecked = function (item) {
        return this.checkedKeys.has(valueFrom(item, this.valueField));
    };
    CheckDirective.prototype.isItemIndeterminate = function (lookup) {
        var children = lookup.children;
        if (!Array.isArray(children) || children.length === 0) {
            return false;
        }
        var index = 0;
        var child = children[index];
        while (isPresent(child)) {
            if (this.isItemChecked(child.item) || this.isItemIndeterminate(child)) {
                return true;
            }
            index += 1;
            child = children[index];
        }
        return false;
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CheckDirective.prototype, "checkable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CheckDirective.prototype, "valueField", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], CheckDirective.prototype, "checkedItems", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], CheckDirective.prototype, "checkedItemsChange", void 0);
    CheckDirective = __decorate([
        Directive({
            selector: '[kendoMultiSelectTreeCheckable]'
        }),
        __metadata("design:paramtypes", [TreeViewComponent])
    ], CheckDirective);
    return CheckDirective;
}());

var INTERNAL_DIRECTIVES = [
    ListComponent,
    ListItemDirective,
    SelectableDirective,
    SearchBarComponent,
    TemplateContextDirective,
    TagListComponent,
    CheckDirective
];
/**
 * @hidden
 */
var SharedModule = /** @class */ (function () {
    function SharedModule() {
    }
    SharedModule = __decorate([
        NgModule({
            declarations: [INTERNAL_DIRECTIVES],
            exports: [INTERNAL_DIRECTIVES, CommonModule, FormsModule, PopupModule, ResizeSensorModule, SharedDirectivesModule, EventsModule],
            imports: [CommonModule, FormsModule, PopupModule, ResizeSensorModule, SharedDirectivesModule, EventsModule]
        })
    ], SharedModule);
    return SharedModule;
}());

/**
 * A directive which configures the MultiSelectTree to show one single summary tag for all selected data items.
 * When a number is provided, the summary tag is displayed after the given amount of data items are selected
 * ([more information and examples]({% slug api_dropdowns_multiselecttreesummarytagdirective %})).
 *
 * @example
 * ```ts-no-run
 * <kendo-multiselecttree kendoMultiSelectTreeSummaryTag [data]="data"></kendo-multiselecttree>
 * ```
 *
 * @example
 * ```ts-no-run
 * <kendo-multiselecttree [kendoMultiSelectTreeSummaryTag]="2" [data]="data"></kendo-multiselecttree>
 * ```
 */
var MultiSelectTreeSummaryTagDirective = /** @class */ (function () {
    function MultiSelectTreeSummaryTagDirective(multiSelectTreeComponent) {
        this.multiSelectTreeComponent = multiSelectTreeComponent;
        /**
         * A numeric value that indicates the number of selected data items after which the summary tag will appear.
         */
        this.showAfter = 0;
        this.createTagMapper();
    }
    MultiSelectTreeSummaryTagDirective.prototype.ngOnChanges = function (changes) {
        if (isPresent(changes.showAfter)) {
            this.createTagMapper();
            this.multiSelectTreeComponent.handleTagMapperChange(this.showAfter);
        }
    };
    MultiSelectTreeSummaryTagDirective.prototype.createTagMapper = function () {
        var showAfter = parseNumber(this.showAfter);
        this.multiSelectTreeComponent.tagMapper = function (tags) {
            if (tags.length > showAfter) {
                // tags provided in an array are rendered as a single group tag
                return tags.slice(0, showAfter).concat([tags.slice(showAfter)]);
            }
            else {
                return tags;
            }
        };
    };
    __decorate([
        Input('kendoMultiSelectTreeSummaryTag'),
        __metadata("design:type", Object)
    ], MultiSelectTreeSummaryTagDirective.prototype, "showAfter", void 0);
    MultiSelectTreeSummaryTagDirective = __decorate([
        Directive({
            selector: '[kendoMultiSelectTreeSummaryTag]'
        }),
        __metadata("design:paramtypes", [MultiSelectTreeComponent])
    ], MultiSelectTreeSummaryTagDirective);
    return MultiSelectTreeSummaryTagDirective;
}());

var DROPDOWNTREE_DIRECTIVES = [
    DropDownTreeComponent,
    MultiSelectTreeComponent,
    DropDownTreeFlatBindingDirective,
    DropDownTreeHierarchyBindingDirective,
    MultiSelectTreeFlatBindingDirective,
    MultiSelectTreeHierarchyBindingDirective,
    DropDownTreesExpandDirective,
    NodeTemplateDirective,
    MultiSelectTreeSummaryTagDirective
];
/**
 * @hidden
 */
var DropDownTreesModule = /** @class */ (function () {
    function DropDownTreesModule() {
    }
    DropDownTreesModule = __decorate([
        NgModule({
            declarations: [DROPDOWNTREE_DIRECTIVES],
            exports: [DROPDOWNTREE_DIRECTIVES, SharedDirectivesModule],
            imports: [SharedModule, TreeViewModule]
        })
    ], DropDownTreesModule);
    return DropDownTreesModule;
}());

/**
 * A directive which configures the MultiSelect to show one single summary tag for all selected data items.
 * When a number is provided, the summary tag is displayed after the given amount of data items are selected
 * ([more information and examples]({% slug summarytagmode_multiselect %})).
 *
 * @example
 * ```ts-no-run
 * <kendo-multiselect kendoMultiSelectSummaryTag [data]="data"></kendo-multiselect>
 * ```
 *
 * @example
 * ```ts-no-run
 * <kendo-multiselect [kendoMultiSelectSummaryTag]="2" [data]="data"></kendo-multiselect>
 * ```
 */
var SummaryTagDirective = /** @class */ (function () {
    function SummaryTagDirective(multiSelectComponent) {
        this.multiSelectComponent = multiSelectComponent;
        /**
         * A numeric value that indicates the number of selected data items after which the summary tag will appear.
         */
        this.showAfter = 0;
        this.createTagMapper();
    }
    SummaryTagDirective.prototype.ngOnChanges = function (changes) {
        if (isPresent(changes.showAfter)) {
            this.createTagMapper();
            this.multiSelectComponent.onTagMapperChange();
        }
    };
    SummaryTagDirective.prototype.createTagMapper = function () {
        var showAfter = parseNumber(this.showAfter);
        this.multiSelectComponent.tagMapper = function (tags) {
            if (tags.length > showAfter) {
                var result = void 0;
                result = tags.slice(0, showAfter);
                result.push(tags.slice(showAfter, tags.length));
                return result;
            }
            else {
                return tags;
            }
        };
    };
    __decorate([
        Input('kendoMultiSelectSummaryTag'),
        __metadata("design:type", Object)
    ], SummaryTagDirective.prototype, "showAfter", void 0);
    SummaryTagDirective = __decorate([
        Directive({
            selector: '[kendoMultiSelectSummaryTag]'
        }),
        __metadata("design:paramtypes", [MultiSelectComponent])
    ], SummaryTagDirective);
    return SummaryTagDirective;
}());

var AUTOCOMPLETE_DIRECTIVES = [
    AutoCompleteComponent
];
/**
 * @hidden
 *
 * The exported package module.
 *
 * The package exports:
 * - `AutoCompleteComponent`&mdash;The AutoComplete component class.
 * - `ItemTemplateDirective`&mdash;The item template directive.
 * - `HeaderTemplateDirective`&mdash;The header template directive.
 * - `FooterTemplateDirective`&mdash;The footer template directive.
 */
var AutoCompleteModule = /** @class */ (function () {
    function AutoCompleteModule() {
    }
    AutoCompleteModule = __decorate([
        NgModule({
            declarations: [AUTOCOMPLETE_DIRECTIVES],
            exports: [AUTOCOMPLETE_DIRECTIVES, SharedDirectivesModule],
            imports: [SharedModule]
        })
    ], AutoCompleteModule);
    return AutoCompleteModule;
}());

var COMBOBOX_DIRECTIVES = [
    ComboBoxComponent,
    MultiColumnComboBoxComponent,
    ComboBoxColumnComponent,
    ColumnHeaderTemplateDirective,
    ColumnCellTemplateDirective
];
var Éµ0$4 = touchEnabled;
/**
 * @hidden
 *
 * The exported package module.
 *
 * The package exports:
 * - `ComboBoxComponent`&mdash;The ComboBox component class.
 * - `MultiColumnComboBoxComponent`&mdash;The MultiColumnComboBox component class.
 * - `ItemTemplateDirective`&mdash;The item template directive.
 * - `HeaderTemplateDirective`&mdash;The header template directive.
 * - `FooterTemplateDirective`&mdash;The footer template directive.
 * - `ColumnHeaderTemplateDirective`&mdash;The column header template directive.
 * - `ColumnCellTemplateDirective`&mdash;The column cell template directive.
 */
var ComboBoxModule = /** @class */ (function () {
    function ComboBoxModule() {
    }
    ComboBoxModule = __decorate([
        NgModule({
            declarations: [COMBOBOX_DIRECTIVES],
            exports: [COMBOBOX_DIRECTIVES, SharedDirectivesModule],
            imports: [SharedModule],
            providers: [{ provide: TOUCH_ENABLED, useValue: Éµ0$4 }]
        })
    ], ComboBoxModule);
    return ComboBoxModule;
}());

var DROPDOWNLIST_DIRECTIVES = [
    DropDownListComponent
];
/**
 * @hidden
 *
 * The exported package module.
 *
 * The package exports:
 * - `DropDownListComponent`&mdash;The DropDownList component class.
 * - `ItemTemplateDirective`&mdash;The item template directive.
 * - `ValueTemplateDirective`&mdash;The value template directive.
 * - `HeaderTemplateDirective`&mdash;The header template directive.
 * - `FooterTemplateDirective`&mdash;The footer template directive.
 */
var DropDownListModule = /** @class */ (function () {
    function DropDownListModule() {
    }
    DropDownListModule = __decorate([
        NgModule({
            declarations: [DROPDOWNLIST_DIRECTIVES],
            exports: [DROPDOWNLIST_DIRECTIVES, SharedDirectivesModule],
            imports: [SharedModule]
        })
    ], DropDownListModule);
    return DropDownListModule;
}());

var MULTISELECT_DIRECTIVES = [
    MultiSelectComponent,
    SummaryTagDirective,
    CustomItemTemplateDirective
];
var Éµ0$5 = touchEnabled;
/**
 * @hidden
 *
 * The exported package module.
 *
 * The package exports:
 * - `MultiSelectComponent`&mdash;The MultiSelect component class.
 * - `SummaryTagDirective`&mdash;The MultiSelect summary tag directive.
 * - `ItemTemplateDirective`&mdash;The item template directive.
 * - `CustomItemTemplateDirective`&mdash;The custom item template directive.
 * - `TagTemplateDirective`&mdash;The tag template directive.
 * - `SummaryTagTemplateDirective`&mdash;The summary tag template directive.
 * - `HeaderTemplateDirective`&mdash;The header template directive.
 * - `FooterTemplateDirective`&mdash;The footer template directive.
 * - `NoDataTemplateDirective`&mdash;The no-data template directive.
 */
var MultiSelectModule = /** @class */ (function () {
    function MultiSelectModule() {
    }
    MultiSelectModule = __decorate([
        NgModule({
            declarations: [MULTISELECT_DIRECTIVES],
            exports: [MULTISELECT_DIRECTIVES, SharedDirectivesModule],
            imports: [SharedModule],
            providers: [{ provide: TOUCH_ENABLED, useValue: Éµ0$5 }]
        })
    ], MultiSelectModule);
    return MultiSelectModule;
}());

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Dropdowns components.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Dropdowns module
 * import { DropDownsModule } from '@progress/kendo-angular-dropdowns';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare the app component
 *     imports:      [BrowserModule, DropDownsModule], // import the Dropdowns module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
var DropDownsModule = /** @class */ (function () {
    function DropDownsModule() {
    }
    DropDownsModule = __decorate([
        NgModule({
            exports: [AutoCompleteModule, ComboBoxModule, DropDownListModule, MultiSelectModule, DropDownTreesModule]
        })
    ], DropDownsModule);
    return DropDownsModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { AUTOCOMPLETE_VALUE_ACCESSOR, COMBOBOX_VALUE_ACCESSOR, TOUCH_ENABLED, DataService, DisabledItemsService, FilterInputDirective, FilterableComponent, ListItemDirective, CustomMessagesComponent, LocalizedMessagesDirective, Messages, NavigationService, SearchBarComponent, SelectionService, TagListComponent, NoDataTemplateDirective, TagTemplateDirective, DROPDOWNLIST_VALUE_ACCESSOR, CheckDirective, MultiSelectTreeSummaryTagDirective, AutoCompleteComponent, ComboBoxComponent, DropDownListComponent, MultiSelectComponent, MultiColumnComboBoxComponent, ComboBoxColumnComponent, ColumnCellTemplateDirective, ColumnHeaderTemplateDirective, DropDownTreeComponent, MultiSelectTreeComponent, DropDownTreeFlatBindingDirective, DropDownTreeHierarchyBindingDirective, MultiSelectTreeFlatBindingDirective, MultiSelectTreeHierarchyBindingDirective, DropDownTreesExpandDirective, DropDownTreesModule, NodeTemplateDirective, ItemTemplateDirective, GroupTemplateDirective, FixedGroupTemplateDirective, CustomItemTemplateDirective, HeaderTemplateDirective, FooterTemplateDirective, ValueTemplateDirective, TemplateContextDirective, GroupTagTemplateDirective, SelectableDirective, SummaryTagDirective, FilterDirective, DropDownsModule, MultiSelectModule, SharedModule, AutoCompleteModule, ComboBoxModule, DropDownListModule, SharedDirectivesModule, ListComponent, PreventableEvent, RemoveTagEvent };
