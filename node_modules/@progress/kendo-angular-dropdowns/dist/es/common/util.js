/**-----------------------------------------------------------------------------------------
* Copyright © 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
/* tslint:disable:no-bitwise */
import { isDocumentAvailable } from '@progress/kendo-angular-common';
import { getter as fieldAccessor } from '@progress/kendo-common';
/**
 * @hidden
 */
export var isPresent = function (value) { return value !== null && value !== undefined; };
/**
 * @hidden
 */
export var isNumber = function (value) { return !isNaN(value); };
/**
 * @hidden
 */
export var guid = function () {
    var id = "";
    var i;
    var random;
    for (i = 0; i < 32; i++) {
        random = Math.random() * 16 | 0;
        if (i === 8 || i === 12 || i === 16 || i === 20) {
            id += "-";
        }
        id += (i === 12 ? 4 : (i === 16 ? (random & 3 | 8) : random)).toString(16);
    }
    return id;
};
/**
 * @hidden
 */
export var combineStr = function (begin, end) {
    return begin.concat(end.substr(end.toLowerCase().indexOf(begin.toLowerCase()) + begin.length));
};
/**
 * @hidden
 */
export var isWindowAvailable = function () { return typeof window !== 'undefined'; };
/**
 * @hidden
 */
export var isArray = function (value) { return Array.isArray(value); };
/**
 * @hidden
 */
export var isObject = function (value) { return isPresent(value) && typeof value === 'object'; };
/**
 * @hidden
 */
export var isEmptyString = function (value) { return typeof value === 'string' && value.length === 0; };
/**
 * @hidden
 */
export var resolveValuesInArray = function (values, data, valueField) {
    if (data === void 0) { data = []; }
    return values
        .map(function (value) {
        return data.find(function (item) { return getter(item, valueField) === value; });
    })
        .filter(function (value) { return value !== undefined; });
};
/**
 * @hidden
 */
export var validateComplexValues = function (values, valueField) {
    return isArray(values) && values.filter(function (item) {
        return isObject(item) && isPresent(getter(item, valueField));
    });
};
/**
 * @hidden
 */
export var resolveAllValues = function (value, data, valueField) {
    var customValues = validateComplexValues(value, valueField) || [];
    var resolvedValues = resolveValuesInArray(value, data, valueField) || [];
    return resolvedValues.concat(customValues);
};
/**
 * @hidden
 */
export var isObjectArray = function (values) {
    return isArray(values) && values.every(function (item) { return isObject(item); });
};
/**
 * @hidden
 */
export var selectedIndices = function (values, data, valueField) {
    var extractedValues = data.map(function (item) {
        return isPresent(item) && isPresent(getter(item, valueField)) ? getter(item, valueField) : item;
    });
    return values.reduce(function (arr, item) {
        var value = isPresent(item) && isPresent(getter(item, valueField)) ? getter(item, valueField) : item;
        var index = extractedValues.indexOf(value);
        if (index !== -1) {
            arr.push(index);
        }
        return arr;
    }, []);
};
/**
 * @hidden
 */
export var getter = function (dataItem, field) {
    if (!isPresent(dataItem)) {
        return null;
    }
    if (!isPresent(field) || !isObject(dataItem)) {
        return dataItem;
    }
    // creates a field accessor supporting nested fields processing
    var valueFrom = fieldAccessor(field);
    return valueFrom(dataItem);
};
/**
 * @hidden
 */
export var resolveValue = function (args) {
    var dataItem;
    if (isPresent(args.value)) {
        var data = [args.defaultItem].concat(args.data);
        dataItem = data.find(function (element) { return getter(element, args.valueField) === args.value; });
        return {
            dataItem: dataItem,
            focused: args.data.indexOf(dataItem),
            selected: args.data.indexOf(dataItem)
        };
    }
    else if (args.index) {
        dataItem = args.data[args.index];
        return {
            dataItem: args.data[args.index],
            focused: args.index,
            selected: args.index
        };
    }
    return {
        dataItem: args.defaultItem,
        focused: -1,
        selected: -1
    };
};
/**
 * @hidden
 */
export var sameCharsOnly = function (word, character) {
    for (var idx = 0; idx < word.length; idx++) {
        if (word.charAt(idx) !== character) {
            return false;
        }
    }
    return true;
};
/**
 * @hidden
 */
export var shuffleData = function (data, splitIndex, defaultItem) {
    var result = data;
    if (defaultItem) {
        result = [defaultItem].concat(result);
    }
    return result.slice(splitIndex).concat(result.slice(0, splitIndex));
};
/**
 * @hidden
 */
export var matchText = function (text, word, ignoreCase) {
    if (!isPresent(text)) {
        return false;
    }
    var temp = String(text);
    if (ignoreCase) {
        temp = temp.toLowerCase();
    }
    return temp.indexOf(word) === 0;
};
/**
 * @hidden
 */
export var elementFromPoint = function (x, y) {
    if (!isDocumentAvailable()) {
        return;
    }
    return document.elementFromPoint(x, y);
};
/**
 * @hidden
 *
 * Checks whether the passed object has all of the listed properties.
 */
export var hasProps = function (obj, props) {
    if (!isPresent(obj)) {
        return false;
    }
    return props.every(function (prop) { return obj.hasOwnProperty(prop); });
};
/**
 * @hidden
 *
 * Checks whether an element is untouched by looking for the ng-untouched css class
 */
export var isUntouched = function (element) { return element.className.includes('ng-untouched'); };
/**
 * @hidden
 */
export var noop = function (_) { };
/**
 * IE element `matches` polyfill.
 * https://developer.mozilla.org/en-US/docs/Web/API/Element/matches
 */
var matches = function (element, selector) {
    var matcher = element.matches || element.msMatchesSelector || element.webkitMatchesSelector;
    if (!matcher) {
        return false;
    }
    return matcher.call(element, selector);
};
var ɵ0 = matches;
/**
 * @hidden
 *
 * IE element `closest` polyfill.
 * https://developer.mozilla.org/en-US/docs/Web/API/Element/closest
 */
export var closest = function (element, selector) {
    var parent = element;
    while (parent !== null && parent.nodeType === 1) {
        if (matches(parent, selector)) {
            return parent;
        }
        parent = parent.parentElement || parent.parentNode;
    }
    return null;
};
/**
 * @hidden
 *
 * Parses a provided value to its type 'number' representation.
 * If the parsed value (via Number(value)) is NaN, the provided default value is returned.
 * Uses 0 as default value if a second param is not provided.
 */
export var parseNumber = function (num, defaultValue) {
    if (defaultValue === void 0) { defaultValue = 0; }
    var normalizedValue = Number(num);
    return isNaN(normalizedValue) ? defaultValue : normalizedValue;
};
/**
 * @hidden
 *
 * Checks whether the passed target element is inside the provided host or popupRef.
 */
export var inDropDown = function (host, target, popupRef) {
    return host.nativeElement.contains(target) || (popupRef && popupRef.popupElement.contains(target));
};
/**
 * @hidden
 *
 * Calculates the hierarchical level of an item, based on the provided index.
 * The result level is zero-based (starts from 0).
 */
export var getHierarchicalItemLevel = function (index) {
    return (index || '').split('_').length - 1;
};
/**
 * @hidden
 *
 * Retrieves all descendant nodes' lookups which are currently registered in the provided lookup item as a flat array.
 */
export var fetchDescendentNodes = function (lookup, filterExpression) {
    if (!isPresent(lookup) || lookup.children.length === 0) {
        return [];
    }
    var descendants = lookup.children;
    if (isPresent(filterExpression)) {
        descendants = descendants.filter(function (descendent) { return filterExpression(descendent.item); });
    }
    descendants.forEach(function (child) {
        return descendants = descendants.concat(fetchDescendentNodes(child, filterExpression));
    });
    return descendants;
};
/**
 * @hidden
 *
 * Retrieves the correct value based on the item's level and the provided value field/s.
 * Used in the MultiSelectTree component.
 */
export var valueFrom = function (_a, valueField) {
    var dataItem = _a.dataItem, index = _a.index, level = _a.level;
    var fields = Array.isArray(valueField) ? valueField : [valueField];
    // either use the explicitly provided value level, or infer it from the item index
    var valueLevel = isPresent(level) ? level : getHierarchicalItemLevel(index);
    // fall-back to the last available one, if the current node is in a deeper level
    var normalizedLevel = Math.min(valueLevel, fields.length - 1);
    var field = fields[normalizedLevel];
    return fieldAccessor(field)(dataItem);
};
export { ɵ0 };
