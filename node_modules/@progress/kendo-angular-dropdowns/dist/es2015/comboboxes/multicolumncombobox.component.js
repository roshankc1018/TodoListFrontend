/**-----------------------------------------------------------------------------------------
* Copyright Â© 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
var MultiColumnComboBoxComponent_1;
import { ChangeDetectorRef, Component, ContentChildren, ElementRef, forwardRef, HostBinding, Inject, isDevMode, NgZone, QueryList, Renderer2, ViewChild } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { isDocumentAvailable, KendoInput } from '@progress/kendo-angular-common';
import { L10N_PREFIX, LocalizationService } from '@progress/kendo-angular-l10n';
import { PopupService } from '@progress/kendo-angular-popup';
import { ComboBoxComponent } from './combobox.component';
import { ComboBoxColumnComponent } from './combobox-column/combobox-column.component';
import { DataService } from '../common/data.service';
import { DisabledItemsService } from '../common/disabled-items/disabled-items.service';
import { NavigationService } from '../common/navigation/navigation.service';
import { SelectionService } from '../common/selection/selection.service';
import { TOUCH_ENABLED } from '../common/constants/touch-enabled';
import { getter, isObject, isPresent, noop } from '../common/util';
import { getRowWidthFromColumnsMeta, scrollbarWidth } from './combobox-column/util';
import { FilterableComponent } from '../common/filtering/filterable-component';
import { MultiColumnComboBoxMessages } from '../common/constants/error-messages';
/**
 * Represents the [Kendo UI MultiColumnComboBox component for Angular]({% slug overview_multicolumncombobox %}).
 */
let MultiColumnComboBoxComponent = MultiColumnComboBoxComponent_1 = class MultiColumnComboBoxComponent extends ComboBoxComponent {
    constructor(localization, popupService, selectionService, navigationService, disabledItemsService, dataService, zone, changeDetector, renderer, hostElement, touchEnabled) {
        super(localization, popupService, selectionService, navigationService, disabledItemsService, dataService, zone, changeDetector, renderer, hostElement, touchEnabled);
        /**
         * @hidden
         */
        this.hostClasses = true;
        this.removeWindowResizeListener = noop;
        // the row height in @progress/kendo-theme-default
        this.defaultVirtualItemHeight = 36;
        // use a smaller virtual page size as columns with multiple cells can cause poor performance
        this.defaultVirtualPageSize = 30;
    }
    /**
     * @hidden
     */
    set header(header) {
        // updates the header padding on initial render as the resize senzor doesn't kick in as early
        this.updateHeaderPadding(header && header.nativeElement);
    }
    get popupWidth() {
        const wrapperOffsetWidth = this.wrapper.nativeElement.offsetWidth;
        const min = `${wrapperOffsetWidth}px`;
        const width = this.popupSettings.width || getRowWidthFromColumnsMeta(this.columns) || wrapperOffsetWidth;
        const max = isNaN(width) ? width : `${width}px`;
        return { min, max };
    }
    /**
     * @hidden
     */
    get listContainerClasses() {
        return [
            'k-list-container',
            'k-popup',
            'k-reset',
            'k-group',
            'k-dropdowngrid-popup',
            'k-popup-flush',
            'k-state-border-up'
        ].concat(this.popupSettings.popupClass || []);
    }
    ngAfterViewInit() {
        this.updateColumnsMediaState();
        this.addWindowResizeListener();
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this.removeWindowResizeListener();
    }
    /**
     * @hidden
     */
    textFrom(dataItem, field) {
        return getter(dataItem, field);
    }
    /**
     * @hidden
     *
     * Adds or removes a padding value at the end of the header container equal to the size of the scrollbar.
     * As when the items container has a scrollbar, the column headers and the cells are misaligned.
     * When the container has a scrollbar, the padding style is added, and when there is none - it is removed.
     */
    updateHeaderPadding(header) {
        if (!isPresent(header)) {
            return;
        }
        // the scrollbar is rendered on the left in rtl
        const headerPaddingPosition = this.localization.rtl ? 'padding-left' : 'padding-right';
        if (this.optionsList.hasScrollbar() && scrollbarWidth() > 0) {
            this.renderer.setStyle(header, headerPaddingPosition, `${scrollbarWidth()}px`);
        }
        else {
            this.renderer.removeStyle(header, headerPaddingPosition);
        }
    }
    verifySettings() {
        if (!isDevMode()) {
            return;
        }
        if (isPresent(this.data) && this.data.length > 0 && this.data.some(item => !isObject(item))) {
            throw new Error(MultiColumnComboBoxMessages.data);
        }
        if (!isPresent(this.valueField) || !isPresent(this.textField)) {
            throw new Error(MultiColumnComboBoxMessages.textAndValue);
        }
        super.verifySettings();
    }
    addWindowResizeListener() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.zone.runOutsideAngular(() => this.removeWindowResizeListener = this.renderer.listen(window, 'resize', this.updateColumnsMediaState.bind(this)));
    }
    updateColumnsMediaState() {
        if (!(isPresent(this.columns) && isDocumentAvailable())) {
            return;
        }
        this.columns.forEach(column => {
            const matchesMedia = !column.media || window.matchMedia(column.media).matches;
            if (column.matchesMedia !== matchesMedia) {
                column.matchesMedia = matchesMedia;
                if (this.isOpen) {
                    // enter the zone only if the popup is actually open
                    // update its width in case it's dependent on the columns' width
                    this.zone.run(() => this.popupRef.popupElement.style.width = this.popupWidth.max);
                }
            }
        });
    }
};
tslib_1.__decorate([
    HostBinding('class.k-dropdowngrid'),
    tslib_1.__metadata("design:type", Boolean)
], MultiColumnComboBoxComponent.prototype, "hostClasses", void 0);
tslib_1.__decorate([
    ContentChildren(ComboBoxColumnComponent),
    tslib_1.__metadata("design:type", QueryList)
], MultiColumnComboBoxComponent.prototype, "columns", void 0);
tslib_1.__decorate([
    ViewChild('header', { static: false }),
    tslib_1.__metadata("design:type", ElementRef),
    tslib_1.__metadata("design:paramtypes", [ElementRef])
], MultiColumnComboBoxComponent.prototype, "header", null);
MultiColumnComboBoxComponent = MultiColumnComboBoxComponent_1 = tslib_1.__decorate([
    Component({
        providers: [
            SelectionService,
            DataService,
            NavigationService,
            DisabledItemsService,
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.multicolumncombobox'
            },
            {
                multi: true,
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => MultiColumnComboBoxComponent_1)
            },
            {
                provide: KendoInput,
                useExisting: forwardRef(() => MultiColumnComboBoxComponent_1)
            },
            {
                provide: FilterableComponent,
                useExisting: forwardRef(() => MultiColumnComboBoxComponent_1)
            }
        ],
        selector: 'kendo-multicolumncombobox',
        template: `
        <ng-container
            kendoMultiColumnComboBoxLocalizedMessages

            i18n-noDataText="kendo.multicolumncombobox.noDataText|The text displayed in the popup when there are no items"
            noDataText="NO DATA FOUND"

            i18n-clearTitle="kendo.multicolumncombobox.clearTitle|The title of the clear button"
            clearTitle="clear"
        >
        </ng-container>
        <span
            #wrapper
            unselectable="on"
            class="k-dropdown-wrap"
            [class.k-state-disabled]="disabled"
        >
            <kendo-searchbar
                #searchbar
                [role]="'combobox'"
                [id]="focusableId"
                [listId]="listBoxId"
                [activeDescendant]="activeDescendant"
                [noDataLabel]="noDataLabel"
                [userInput]="text"
                [suggestedText]="getSuggestion()"
                [disabled]="disabled"
                [readonly]="readonly"
                [tabIndex]="tabIndex"
                [popupOpen]="isOpen"
                [placeholder]="placeholder"
                (onNavigate)="handleNavigate($event)"
                (valueChange)="searchBarChange($event)"
                (onBlur)="handleBlur()"
                (onFocus)="handleFocus()"
            >
            </kendo-searchbar>

            <span
                *ngIf="clearButton && !loading && !disabled && !readonly && text?.length"
                class="k-icon k-clear-value k-i-close"
                [style.visibility]="clearButtonVisiblity"
                aria-hidden="true"
                [attr.title]="clearTitle"
                (click)="clearValue($event)"
                [kendoEventsOutsideAngular]="{
                    mousedown: preventEventDefault
                }"
            >
            </span>

            <span
                #select
                aria-hidden="true"
                unselectable="on"
                class="k-select"
                [kendoEventsOutsideAngular]="{
                    mousedown: preventEventDefault
                }"
            >
                <span
                    class="k-icon"
                    [ngClass]="buttonClasses"
                >
                </span>
            </span>
        </span>

        <ng-template #popupTemplate>
            <!--user-defined header template -->
            <ng-template
                *ngIf="headerTemplate"
                [templateContext]="{
                    templateRef: headerTemplate?.templateRef
                }"
            >
            </ng-template>

            <!--grid header-->
            <div
                #header
                class="k-grid-header"
            >
                <div class="k-grid-header-wrap">
                    <table role="presentation">
                        <colgroup>
                            <ng-container *ngFor="let column of columns">
                                <col
                                    *ngIf="!column.hidden && column.matchesMedia"
                                    [style.width.px]="column.width"
                                />
                            </ng-container>
                        </colgroup>
                        <tbody>
                            <tr>
                                <ng-container *ngFor="let column of columns">
                                    <th
                                        *ngIf="!column.hidden && column.matchesMedia"
                                        class="k-header"
                                        [ngStyle]="column.headerStyle"
                                        [ngClass]="column.headerClass"
                                    >
                                        <ng-container *ngIf="!column.headerTemplate">
                                            {{ column.title || column.field }}
                                        </ng-container>
                                        <ng-template
                                            *ngIf="column.headerTemplate"
                                            [templateContext]="{
                                                templateRef: column.headerTemplate?.templateRef,
                                                $implicit: column,
                                                column: column
                                            }"
                                        >
                                        </ng-template>
                                    </th>
                                </ng-container>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- item template -->
            <ng-template #rowTemplate let-dataItem>
                <ng-container *ngFor="let column of columns">
                    <span
                        *ngIf="!column.hidden && column.matchesMedia"
                        class="k-cell"
                        [ngClass]="column.class"
                        [style.width.px]="column.width"
                        [ngStyle]="column.style"
                    >
                        <ng-container *ngIf="!column.cellTemplate">
                            {{ textFrom(dataItem, column.field) }}
                        </ng-container>
                        <ng-template
                            *ngIf="column.cellTemplate"
                            [templateContext]="{
                                templateRef: column.cellTemplate?.templateRef,
                                $implicit: dataItem,
                                dataItem: dataItem,
                                column: column
                            }"
                        >
                        </ng-template>
                    </span>
                </ng-container>
            </ng-template>

            <!--list-->
            <kendo-list
                #optionsList
                [id]="listBoxId"
                [optionPrefix]="optionPrefix"
                [data]="data"
                [textField]="textField"
                [valueField]="valueField"
                [template]="{ templateRef: rowTemplate }"
                [groupTemplate]="groupTemplate"
                [fixedGroupTemplate]="fixedGroupTemplate"
                [height]="listHeight"
                [show]="isOpen"
                [virtual]="virtual"
                [listClass]="'k-reset k-grid-list'"
                (pageChange)="pageChange($event)"
                (listResize)="updateHeaderPadding(header)"
            >
            </kendo-list>

            <!--no-data template-->
            <div
                class="k-nodata"
                *ngIf="data.length === 0"
            >
                <ng-template
                    [ngIf]="noDataTemplate"
                    [templateContext]="{
                        templateRef: noDataTemplate?.templateRef
                    }"
                >
                </ng-template>
                <ng-template [ngIf]="!noDataTemplate">
                    <div>{{ noDataText }}</div>
                </ng-template>
            </div>

            <!--user-defined footer template-->
            <ng-container *ngIf="footerTemplate">
                <div class="k-footer">
                    <ng-template
                        [templateContext]="{
                            templateRef: footerTemplate.templateRef
                        }"
                    >
                    </ng-template>
                </div>
            </ng-container>
        </ng-template>

        <kendo-resize-sensor
            *ngIf="isOpen"
            (resize)="onResize()"
        >
        </kendo-resize-sensor>

        <!-- when the popupSettings.appendTo value is set to 'component', this container is used -->
        <ng-container #container></ng-container>
    `
    }),
    tslib_1.__param(10, Inject(TOUCH_ENABLED)),
    tslib_1.__metadata("design:paramtypes", [LocalizationService,
        PopupService,
        SelectionService,
        NavigationService,
        DisabledItemsService,
        DataService,
        NgZone,
        ChangeDetectorRef,
        Renderer2,
        ElementRef, Boolean])
], MultiColumnComboBoxComponent);
export { MultiColumnComboBoxComponent };
