/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { __decorate, __metadata } from 'tslib';
import { EventEmitter, Input, Output, Directive, ElementRef, NgZone, NgModule, Renderer2, Injectable, Component } from '@angular/core';
import Draggable from '@telerik/kendo-draggable';
import { CommonModule } from '@angular/common';
import { auditTime } from 'rxjs/operators';
import { merge, fromEvent, from } from 'rxjs';

import * as ɵngcc0 from '@angular/core';
const isDocumentAvailable = () => typeof document !== 'undefined';

const isChanged = (propertyName, changes, skipFirstChange = true) => (typeof changes[propertyName] !== 'undefined' &&
    (!changes[propertyName].isFirstChange() || !skipFirstChange) &&
    changes[propertyName].previousValue !== changes[propertyName].currentValue);

const anyChanged = (propertyNames, changes, skipFirstChange = true) => propertyNames.some(name => isChanged(name, changes, skipFirstChange));

const hasObservers = (emitter) => emitter && emitter.observers.length > 0;

const guid = () => {
    let id = "";
    for (let i = 0; i < 32; i++) {
        const random = Math.random() * 16 | 0; // tslint:disable-line:no-bitwise
        if (i === 8 || i === 12 || i === 16 || i === 20) {
            id += "-";
        }
        // tslint:disable-next-line:no-bitwise
        id += (i === 12 ? 4 : (i === 16 ? (random & 3 | 8) : random)).toString(16);
    }
    return id;
};

let DraggableDirective = class DraggableDirective {
    constructor(element, ngZone) {
        this.element = element;
        this.ngZone = ngZone;
        this.enableDrag = true;
        this.kendoPress = new EventEmitter();
        this.kendoDrag = new EventEmitter();
        this.kendoRelease = new EventEmitter();
    }
    ngOnInit() {
        this.toggleDraggable();
    }
    ngOnChanges(changes) {
        if (isChanged('enableDrag', changes)) {
            this.toggleDraggable();
        }
    }
    ngOnDestroy() {
        this.destroyDraggable();
    }
    toggleDraggable() {
        if (isDocumentAvailable()) {
            this.destroyDraggable();
            if (this.enableDrag) {
                this.draggable = new Draggable({
                    drag: (e) => this.kendoDrag.next(e),
                    press: (e) => this.kendoPress.next(e),
                    release: (e) => this.kendoRelease.next(e)
                });
                this.ngZone.runOutsideAngular(() => this.draggable.bindTo(this.element.nativeElement));
            }
        }
    }
    destroyDraggable() {
        if (this.draggable) {
            this.draggable.destroy();
            this.draggable = null;
        }
    }
};
DraggableDirective.ɵfac = function DraggableDirective_Factory(t) { return new (t || DraggableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
DraggableDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DraggableDirective, selectors: [["", "kendoDraggable", ""]], inputs: { enableDrag: "enableDrag" }, outputs: { kendoPress: "kendoPress", kendoDrag: "kendoDrag", kendoRelease: "kendoRelease" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DraggableDirective.prototype, "enableDrag", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], DraggableDirective.prototype, "kendoPress", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], DraggableDirective.prototype, "kendoDrag", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], DraggableDirective.prototype, "kendoRelease", void 0);
DraggableDirective = __decorate([ __metadata("design:paramtypes", [ElementRef, NgZone])
], DraggableDirective);

/**
 * @hidden
 */
let DraggableModule = class DraggableModule {
};
DraggableModule.ɵfac = function DraggableModule_Factory(t) { return new (t || DraggableModule)(); };
DraggableModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: DraggableModule });
DraggableModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });

const closestInScope = (node, predicate, scope) => {
    while (node && node !== scope && !predicate(node)) {
        node = node.parentNode;
    }
    if (node !== scope) {
        return node;
    }
};

const closest = (node, predicate) => {
    while (node && !predicate(node)) {
        node = node.parentNode;
    }
    return node;
};

const contains = (parent, node, matchSelf = false) => {
    const outside = !closest(node, (child) => child === parent);
    if (outside) {
        return false;
    }
    const el = closest(node, (child) => child === node);
    return el && (matchSelf || el !== parent);
};

const findElement = (node, predicate, matchSelf = true) => {
    if (!node) {
        return;
    }
    if (matchSelf && predicate(node)) {
        return node;
    }
    node = node.firstChild;
    while (node) {
        if (node.nodeType === 1) {
            const element = findElement(node, predicate);
            if (element) {
                return element;
            }
        }
        node = node.nextSibling;
    }
};

const focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;
const isFocusable = (element) => {
    if (!element.tagName) {
        return false;
    }
    const tagName = element.tagName.toLowerCase();
    const hasTabIndex = Boolean(element.getAttribute('tabIndex'));
    const focusable = !element.disabled && focusableRegex.test(tagName);
    return focusable || hasTabIndex;
};

const isVisible = (element) => {
    const rect = element.getBoundingClientRect();
    const hasSize = rect.width > 0 && rect.height > 0;
    const hasPosition = rect.x !== 0 && rect.y !== 0;
    // Elements can have zero size due to styling, but they will still count as visible.
    // For example, the selection checkbox has no size, but is made visible through styling.
    return (hasSize || hasPosition) && window.getComputedStyle(element).visibility !== 'hidden';
};

const isFocusableWithTabKey = (element, checkVisibility = true) => {
    if (!isFocusable(element)) {
        return false;
    }
    const tabIndex = element.getAttribute('tabIndex');
    const visible = !checkVisibility || isVisible(element);
    return visible && tabIndex !== '-1';
};

const findFocusableChild = (element, checkVisibility = true) => {
    return findElement(element, (node) => isFocusableWithTabKey(node, checkVisibility), false);
};

const findFocusable = (element, checkVisibility = true) => {
    return findElement(element, (node) => isFocusableWithTabKey(node, checkVisibility));
};

const toClassList = (classNames) => String(classNames).trim().split(' ');
const hasClasses = (element, classNames) => {
    const namesList = toClassList(classNames);
    return Boolean(toClassList(element.className).find((className) => namesList.indexOf(className) >= 0));
};

const matchesClasses = (classNames) => (element) => hasClasses(element, classNames);

const NODE_NAME_PREDICATES = {};
const matchesNodeName = (nodeName) => {
    if (!NODE_NAME_PREDICATES[nodeName]) {
        NODE_NAME_PREDICATES[nodeName] = (element) => String(element.nodeName).toLowerCase() === nodeName.toLowerCase();
    }
    return NODE_NAME_PREDICATES[nodeName];
};

/**
 * Normalizes a scroll position value in RTL mode.
 */
function rtlScrollPosition(position, element, initial) {
    let result = position;
    if (initial < 0) {
        result = -position;
    }
    else if (initial > 0) {
        result = element.scrollWidth - element.offsetWidth - position;
    }
    return result;
}

/* tslint:disable:no-input-rename */
/**
 * @hidden
 */
let EventsOutsideAngularDirective = class EventsOutsideAngularDirective {
    constructor(element, ngZone, renderer) {
        this.element = element;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.events = {};
    }
    ngOnInit() {
        if (!this.element || !this.element.nativeElement) {
            return;
        }
        const events = this.events;
        this.subscriptions = [];
        this.ngZone.runOutsideAngular(() => {
            for (let name in events) {
                if (events.hasOwnProperty(name)) {
                    this.subscriptions.push(this.renderer.listen(this.element.nativeElement, name, this.scope ? events[name].bind(this.scope) : events[name]));
                }
            }
        });
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            for (let idx = 0; idx < this.subscriptions.length; idx++) {
                this.subscriptions[idx]();
            }
            this.subscriptions = null;
        }
    }
};
EventsOutsideAngularDirective.ɵfac = function EventsOutsideAngularDirective_Factory(t) { return new (t || EventsOutsideAngularDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
EventsOutsideAngularDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: EventsOutsideAngularDirective, selectors: [["", "kendoEventsOutsideAngular", ""]], inputs: { events: ["kendoEventsOutsideAngular", "events"], scope: "scope" } });
__decorate([
    Input('kendoEventsOutsideAngular'),
    __metadata("design:type", Object)
], EventsOutsideAngularDirective.prototype, "events", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], EventsOutsideAngularDirective.prototype, "scope", void 0);
EventsOutsideAngularDirective = __decorate([ __metadata("design:paramtypes", [ElementRef,
        NgZone,
        Renderer2])
], EventsOutsideAngularDirective);

/**
 * @hidden
 */
let EventsModule = class EventsModule {
};
EventsModule.ɵfac = function EventsModule_Factory(t) { return new (t || EventsModule)(); };
EventsModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: EventsModule });
EventsModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});

class ResizeService {
    constructor(resizeBatchService) {
        this.resizeBatchService = resizeBatchService;
        this.resize = new EventEmitter();
        this.acceptedSize = false;
        this.state = 0 /* Initial */;
    }
    acceptSize(size = this.measure()) {
        this.lastWidth = size.width;
        this.lastHeight = size.height;
        this.acceptedSize = true;
    }
    checkChanges() {
        if (!isDocumentAvailable()) {
            return;
        }
        if (this.state === 0 /* Initial */) {
            this.state = 1 /* Initializing */;
            // batch initial measure
            this.resizeBatchService.schedule(this, this.init);
        }
    }
    destroy() {
        this.resizeBatchService.cancel(this);
    }
    checkSize() {
        if (!this.parentElement) {
            return;
        }
        const { width, height } = this.measure();
        const sameSize = width === this.lastWidth && height === this.lastHeight;
        if (sameSize) {
            return;
        }
        this.lastWidth = width;
        this.lastHeight = height;
        this.acceptedSize = false;
        this.resize.emit();
        return true;
    }
    initSize() {
        const size = this.measure();
        this.lastWidth = size.width;
        this.lastHeight = size.height;
    }
    measure() {
        let width = 0;
        let height = 0;
        if (this.parentElement) {
            height = this.parentElement.offsetHeight;
            width = this.parentElement.offsetWidth;
        }
        return { height, width };
    }
}

// tslint:disable:deprecation
const div = style => {
    const el = document.createElement('div');
    el.style.cssText = style;
    return el;
};
const computedProp = (elem, prop) => getComputedStyle(elem, null).getPropertyValue(prop);
const WRAP_STYLE = 'position: absolute; display: block; left: 0; top: 0; right: 0; bottom: 0; z-index: -1;' +
    'overflow: hidden; visibility: hidden;';
const EXPAND_CHILD_STYLE = 'position: absolute; left: 0; top: 0; transition: 0s;';
const SHRINK_CHILD_STYLE = EXPAND_CHILD_STYLE + 'width: 200%; height: 200%;';
class ResizeCompatService extends ResizeService {
    constructor(resizeBatchService, element, ngZone) {
        super(resizeBatchService);
        this.element = element;
        this.ngZone = ngZone;
    }
    checkChanges() {
        if (this.state === 2 /* Initialized */) {
            if (!this.resizeBatchService.isScheduled(this)) {
                this.resizeBatchService.schedule(this, this.checkSize);
            }
            return;
        }
        super.checkChanges();
    }
    destroy() {
        super.destroy();
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        if (this.expand) {
            const element = this.element.nativeElement;
            element.removeChild(this.expand);
            element.removeChild(this.shrink);
            this.expand.removeChild(this.expandChild);
            this.expand = this.expandChild = this.shrink = this.element = null;
        }
    }
    checkSize() {
        if (super.checkSize()) {
            this.reset();
            return true;
        }
    }
    init() {
        const parentElement = this.parentElement = this.element.nativeElement.parentElement;
        if (computedProp(parentElement, 'position') === 'static') {
            parentElement.style.position = 'relative';
        }
        this.state = 2 /* Initialized */;
        this.render();
        this.reset();
        this.initSize();
        this.subscribe();
    }
    render() {
        const element = this.element.nativeElement;
        element.style.cssText = WRAP_STYLE;
        element.setAttribute('dir', 'ltr');
        this.expand = div(WRAP_STYLE);
        this.expandChild = div(EXPAND_CHILD_STYLE);
        this.expand.appendChild(this.expandChild);
        element.appendChild(this.expand);
        this.shrink = div(WRAP_STYLE);
        const shrinkChild = div(SHRINK_CHILD_STYLE);
        this.shrink.appendChild(shrinkChild);
        element.appendChild(this.shrink);
    }
    reset() {
        const expandChild = this.expandChild;
        expandChild.style.width = 100000 + 'px';
        expandChild.style.height = 100000 + 'px';
        const expand = this.expand;
        expand.scrollLeft = 100000;
        expand.scrollTop = 100000;
        const shrink = this.shrink;
        shrink.scrollLeft = 100000;
        shrink.scrollTop = 100000;
    }
    subscribe() {
        this.ngZone.runOutsideAngular(() => {
            this.subscription = merge(fromEvent(this.shrink, 'scroll'), fromEvent(this.expand, 'scroll'))
                .subscribe(() => {
                this.checkSize();
            });
        });
    }
}

const HAS_OBSERVER = typeof ResizeObserver !== 'undefined';
/**
 * @hidden
 */
class ResizeObserverService extends ResizeService {
    constructor(resizeBatchService, element, ngZone) {
        super(resizeBatchService);
        this.element = element;
        this.ngZone = ngZone;
    }
    static supported() {
        return HAS_OBSERVER;
    }
    destroy() {
        super.destroy();
        if (this.resizeObserver) {
            this.resizeObserver.disconnect();
            this.resizeObserver = null;
        }
        this.parentElement = null;
    }
    init() {
        this.parentElement = this.element.nativeElement.parentElement;
        this.initSize();
        this.state = 2 /* Initialized */;
        this.ngZone.runOutsideAngular(() => {
            this.resizeObserver = new ResizeObserver(() => {
                this.checkSize();
            });
            this.resizeObserver.observe(this.parentElement);
        });
    }
}

/* tslint:disable:align */
/**
 * @hidden
 */
let ResizeBatchService = class ResizeBatchService {
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.scheduled = [];
        this.resolvedPromise = Promise.resolve(null);
        this.flush = this.flush.bind(this);
    }
    schedule(instance, method) {
        this.scheduled.push({ instance, method });
        if (!this.subscription) {
            this.ngZone.runOutsideAngular(() => {
                this.subscription = from(this.resolvedPromise)
                    .subscribe(this.flush);
            });
        }
    }
    isScheduled(instance) {
        return Boolean(this.scheduled.find(item => item.instance === instance));
    }
    cancel(instance) {
        const scheduled = this.scheduled;
        const count = scheduled.length;
        for (let idx = 0; idx < count; idx++) {
            if (scheduled[idx].instance === instance) {
                scheduled.splice(idx, 1);
                if (!scheduled.length) {
                    this.unsubscribe();
                }
                return;
            }
        }
    }
    ngOnDestroy() {
        this.unsubscribe();
    }
    unsubscribe() {
        if (this.subscription) {
            this.subscription.unsubscribe();
            this.subscription = null;
        }
    }
    flush() {
        this.scheduled.forEach(item => {
            item.method.call(item.instance);
        });
        this.scheduled = [];
        this.unsubscribe();
    }
};
ResizeBatchService.ɵfac = function ResizeBatchService_Factory(t) { return new (t || ResizeBatchService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
ResizeBatchService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ResizeBatchService, factory: function (t) { return ResizeBatchService.ɵfac(t); } });
ResizeBatchService = __decorate([ __metadata("design:paramtypes", [NgZone])
], ResizeBatchService);

/**
 * Emit up to 10 resize events per second by default.
 * Chosen as a compromise between responsiveness and performance.
 */
const DEFAULT_RATE_LIMIT = 10;
/**
 * Resize Sensor Component
 *
 * Triggers a "resize" event whenever the parent DOM element size changes.
 */
let ResizeSensorComponent = class ResizeSensorComponent {
    constructor(resizeBatchService, element, ngZone) {
        /**
         * The maximum number of resize events to emit per second.
         *
         * Defaults to 10.
         */
        this.rateLimit = DEFAULT_RATE_LIMIT;
        /**
         * Fires when the parent DOM element has been resized.
         */
        this.resize = new EventEmitter();
        const serviceType = ResizeObserverService.supported() ? ResizeObserverService : ResizeCompatService;
        this.resizeService = new serviceType(resizeBatchService, element, ngZone);
        const throttleTime = 1000 / (this.rateLimit || DEFAULT_RATE_LIMIT);
        this.subscription = this.resizeService.resize
            .pipe(auditTime(throttleTime))
            .subscribe(() => {
            if (!this.resizeService.acceptedSize) {
                this.resize.emit();
            }
        });
    }
    ngAfterViewChecked() {
        this.resizeService.checkChanges();
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
        this.resizeService.destroy();
    }
    acceptSize(size) {
        this.resizeService.acceptSize(size);
    }
};
ResizeSensorComponent.ɵfac = function ResizeSensorComponent_Factory(t) { return new (t || ResizeSensorComponent)(ɵngcc0.ɵɵdirectiveInject(ResizeBatchService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
ResizeSensorComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ResizeSensorComponent, selectors: [["kendo-resize-sensor"]], inputs: { rateLimit: "rateLimit" }, outputs: { resize: "resize" }, decls: 0, vars: 0, template: function ResizeSensorComponent_Template(rf, ctx) { }, encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Number)
], ResizeSensorComponent.prototype, "rateLimit", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ResizeSensorComponent.prototype, "resize", void 0);
ResizeSensorComponent = __decorate([ __metadata("design:paramtypes", [ResizeBatchService, ElementRef, NgZone])
], ResizeSensorComponent);

const COMPONENT_DIRECTIVES = [ResizeSensorComponent];
/**
 * Resize Sensor module
 */
let ResizeSensorModule = class ResizeSensorModule {
};
ResizeSensorModule.ɵfac = function ResizeSensorModule_Factory(t) { return new (t || ResizeSensorModule)(); };
ResizeSensorModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: ResizeSensorModule });
ResizeSensorModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [ResizeBatchService] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DraggableDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDraggable]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { enableDrag: [{
            type: Input
        }], kendoPress: [{
            type: Output
        }], kendoDrag: [{
            type: Output
        }], kendoRelease: [{
            type: Output
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DraggableModule, [{
        type: NgModule,
        args: [{
                declarations: [DraggableDirective],
                exports: [DraggableDirective],
                imports: [CommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DraggableModule, { declarations: function () { return [DraggableDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [DraggableDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(EventsOutsideAngularDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoEventsOutsideAngular]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }]; }, { events: [{
            type: Input,
            args: ['kendoEventsOutsideAngular']
        }], scope: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(EventsModule, [{
        type: NgModule,
        args: [{
                declarations: [EventsOutsideAngularDirective],
                exports: [EventsOutsideAngularDirective]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(EventsModule, { declarations: [EventsOutsideAngularDirective], exports: [EventsOutsideAngularDirective] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ResizeBatchService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ResizeSensorComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-resize-sensor',
                template: ''
            }]
    }], function () { return [{ type: ResizeBatchService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { rateLimit: [{
            type: Input
        }], resize: [{
            type: Output
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ResizeSensorModule, [{
        type: NgModule,
        args: [{
                declarations: [COMPONENT_DIRECTIVES],
                exports: [COMPONENT_DIRECTIVES],
                providers: [ResizeBatchService]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ResizeSensorModule, { declarations: [ResizeSensorComponent], exports: [ResizeSensorComponent] }); })();

class KendoInput {
}

/**
 * Enum with key codes.
 */
var Keys;
(function (Keys) {
    Keys[Keys["Alt"] = 18] = "Alt";
    Keys[Keys["ArrowDown"] = 40] = "ArrowDown";
    Keys[Keys["ArrowLeft"] = 37] = "ArrowLeft";
    Keys[Keys["ArrowRight"] = 39] = "ArrowRight";
    Keys[Keys["ArrowUp"] = 38] = "ArrowUp";
    Keys[Keys["Backspace"] = 8] = "Backspace";
    Keys[Keys["Control"] = 17] = "Control";
    Keys[Keys["Delete"] = 46] = "Delete";
    Keys[Keys["Digit0"] = 48] = "Digit0";
    Keys[Keys["Digit1"] = 49] = "Digit1";
    Keys[Keys["Digit2"] = 50] = "Digit2";
    Keys[Keys["Digit3"] = 51] = "Digit3";
    Keys[Keys["Digit4"] = 52] = "Digit4";
    Keys[Keys["Digit5"] = 53] = "Digit5";
    Keys[Keys["Digit6"] = 54] = "Digit6";
    Keys[Keys["Digit7"] = 55] = "Digit7";
    Keys[Keys["Digit8"] = 56] = "Digit8";
    Keys[Keys["Digit9"] = 57] = "Digit9";
    Keys[Keys["End"] = 35] = "End";
    Keys[Keys["Enter"] = 13] = "Enter";
    Keys[Keys["Escape"] = 27] = "Escape";
    Keys[Keys["F1"] = 112] = "F1";
    Keys[Keys["F2"] = 113] = "F2";
    Keys[Keys["F10"] = 121] = "F10";
    Keys[Keys["Home"] = 36] = "Home";
    Keys[Keys["Insert"] = 45] = "Insert";
    Keys[Keys["KeyA"] = 65] = "KeyA";
    Keys[Keys["KeyB"] = 66] = "KeyB";
    Keys[Keys["KeyC"] = 67] = "KeyC";
    Keys[Keys["KeyD"] = 68] = "KeyD";
    Keys[Keys["KeyE"] = 69] = "KeyE";
    Keys[Keys["KeyF"] = 70] = "KeyF";
    Keys[Keys["KeyG"] = 71] = "KeyG";
    Keys[Keys["KeyH"] = 72] = "KeyH";
    Keys[Keys["KeyI"] = 73] = "KeyI";
    Keys[Keys["KeyJ"] = 74] = "KeyJ";
    Keys[Keys["KeyK"] = 75] = "KeyK";
    Keys[Keys["KeyL"] = 76] = "KeyL";
    Keys[Keys["KeyM"] = 77] = "KeyM";
    Keys[Keys["KeyN"] = 78] = "KeyN";
    Keys[Keys["KeyO"] = 79] = "KeyO";
    Keys[Keys["KeyP"] = 80] = "KeyP";
    Keys[Keys["KeyQ"] = 81] = "KeyQ";
    Keys[Keys["KeyR"] = 82] = "KeyR";
    Keys[Keys["KeyS"] = 83] = "KeyS";
    Keys[Keys["KeyT"] = 84] = "KeyT";
    Keys[Keys["KeyU"] = 85] = "KeyU";
    Keys[Keys["KeyV"] = 86] = "KeyV";
    Keys[Keys["KeyW"] = 87] = "KeyW";
    Keys[Keys["KeyX"] = 88] = "KeyX";
    Keys[Keys["KeyY"] = 89] = "KeyY";
    Keys[Keys["KeyZ"] = 90] = "KeyZ";
    Keys[Keys["NumpadDecimal"] = 110] = "NumpadDecimal";
    Keys[Keys["PageDown"] = 34] = "PageDown";
    Keys[Keys["PageUp"] = 33] = "PageUp";
    Keys[Keys["Shift"] = 16] = "Shift";
    Keys[Keys["Space"] = 32] = "Space";
    Keys[Keys["Tab"] = 9] = "Tab";
})(Keys || (Keys = {}));

class PreventableEvent {
    constructor() {
        this.prevented = false;
    }
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses
     * the built-in behavior that follows the event.
     */
    preventDefault() {
        this.prevented = true;
    }
    /**
     * Returns `true` if the event was prevented
     * by any of its subscribers.
     *
     * @returns `true` if the default action was prevented.
     * Otherwise, returns `false`.
     */
    isDefaultPrevented() {
        return this.prevented;
    }
}

/**
 * Generated bundle index. Do not edit.
 */

export { ResizeService, PreventableEvent, DraggableDirective, DraggableModule, closestInScope, closest, contains, findElement, findFocusableChild, findFocusable, hasClasses, isFocusableWithTabKey, isFocusable, isVisible, matchesClasses, matchesNodeName, rtlScrollPosition, EventsOutsideAngularDirective, EventsModule, ResizeSensorComponent, ResizeBatchService, ResizeCompatService, ResizeObserverService, ResizeSensorModule, KendoInput, isDocumentAvailable, isChanged, anyChanged, hasObservers, guid, Keys };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztvVEFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OzRGQU9vQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztzUEFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OzhEQU1pQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2dLQUFFO0FBQ0YsaUNBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7bVRBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBS0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttTUFPdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIENvcHlyaWdodCDCqSAyMDIwIFByb2dyZXNzIFNvZnR3YXJlIENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciBjb21tZXJjaWFsIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IF9fZGVjb3JhdGUsIF9fbWV0YWRhdGEgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgTmdab25lLCBOZ01vZHVsZSwgUmVuZGVyZXIyLCBJbmplY3RhYmxlLCBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCBEcmFnZ2FibGUgZnJvbSAnQHRlbGVyaWsva2VuZG8tZHJhZ2dhYmxlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBhdWRpdFRpbWUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBtZXJnZSwgZnJvbUV2ZW50LCBmcm9tIH0gZnJvbSAncnhqcyc7XG5cbmNvbnN0IGlzRG9jdW1lbnRBdmFpbGFibGUgPSAoKSA9PiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG5jb25zdCBpc0NoYW5nZWQgPSAocHJvcGVydHlOYW1lLCBjaGFuZ2VzLCBza2lwRmlyc3RDaGFuZ2UgPSB0cnVlKSA9PiAodHlwZW9mIGNoYW5nZXNbcHJvcGVydHlOYW1lXSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAoIWNoYW5nZXNbcHJvcGVydHlOYW1lXS5pc0ZpcnN0Q2hhbmdlKCkgfHwgIXNraXBGaXJzdENoYW5nZSkgJiZcbiAgICBjaGFuZ2VzW3Byb3BlcnR5TmFtZV0ucHJldmlvdXNWYWx1ZSAhPT0gY2hhbmdlc1twcm9wZXJ0eU5hbWVdLmN1cnJlbnRWYWx1ZSk7XG5cbmNvbnN0IGFueUNoYW5nZWQgPSAocHJvcGVydHlOYW1lcywgY2hhbmdlcywgc2tpcEZpcnN0Q2hhbmdlID0gdHJ1ZSkgPT4gcHJvcGVydHlOYW1lcy5zb21lKG5hbWUgPT4gaXNDaGFuZ2VkKG5hbWUsIGNoYW5nZXMsIHNraXBGaXJzdENoYW5nZSkpO1xuXG5jb25zdCBoYXNPYnNlcnZlcnMgPSAoZW1pdHRlcikgPT4gZW1pdHRlciAmJiBlbWl0dGVyLm9ic2VydmVycy5sZW5ndGggPiAwO1xuXG5jb25zdCBndWlkID0gKCkgPT4ge1xuICAgIGxldCBpZCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJhbmRvbSA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDA7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tYml0d2lzZVxuICAgICAgICBpZiAoaSA9PT0gOCB8fCBpID09PSAxMiB8fCBpID09PSAxNiB8fCBpID09PSAyMCkge1xuICAgICAgICAgICAgaWQgKz0gXCItXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWJpdHdpc2VcbiAgICAgICAgaWQgKz0gKGkgPT09IDEyID8gNCA6IChpID09PSAxNiA/IChyYW5kb20gJiAzIHwgOCkgOiByYW5kb20pKS50b1N0cmluZygxNik7XG4gICAgfVxuICAgIHJldHVybiBpZDtcbn07XG5cbmxldCBEcmFnZ2FibGVEaXJlY3RpdmUgPSBjbGFzcyBEcmFnZ2FibGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG5nWm9uZSkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5lbmFibGVEcmFnID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5rZW5kb1ByZXNzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmtlbmRvRHJhZyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5rZW5kb1JlbGVhc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnRvZ2dsZURyYWdnYWJsZSgpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChpc0NoYW5nZWQoJ2VuYWJsZURyYWcnLCBjaGFuZ2VzKSkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVEcmFnZ2FibGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95RHJhZ2dhYmxlKCk7XG4gICAgfVxuICAgIHRvZ2dsZURyYWdnYWJsZSgpIHtcbiAgICAgICAgaWYgKGlzRG9jdW1lbnRBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95RHJhZ2dhYmxlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5lbmFibGVEcmFnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2FibGUgPSBuZXcgRHJhZ2dhYmxlKHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZzogKGUpID0+IHRoaXMua2VuZG9EcmFnLm5leHQoZSksXG4gICAgICAgICAgICAgICAgICAgIHByZXNzOiAoZSkgPT4gdGhpcy5rZW5kb1ByZXNzLm5leHQoZSksXG4gICAgICAgICAgICAgICAgICAgIHJlbGVhc2U6IChlKSA9PiB0aGlzLmtlbmRvUmVsZWFzZS5uZXh0KGUpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gdGhpcy5kcmFnZ2FibGUuYmluZFRvKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveURyYWdnYWJsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnYWJsZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmRyYWdnYWJsZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERyYWdnYWJsZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZW5hYmxlRHJhZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIERyYWdnYWJsZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwia2VuZG9QcmVzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIERyYWdnYWJsZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwia2VuZG9EcmFnXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgRHJhZ2dhYmxlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJrZW5kb1JlbGVhc2VcIiwgdm9pZCAwKTtcbkRyYWdnYWJsZURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvRHJhZ2dhYmxlXSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE5nWm9uZV0pXG5dLCBEcmFnZ2FibGVEaXJlY3RpdmUpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IERyYWdnYWJsZU1vZHVsZSA9IGNsYXNzIERyYWdnYWJsZU1vZHVsZSB7XG59O1xuRHJhZ2dhYmxlTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtEcmFnZ2FibGVEaXJlY3RpdmVdLFxuICAgICAgICBleHBvcnRzOiBbRHJhZ2dhYmxlRGlyZWN0aXZlXSxcbiAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV1cbiAgICB9KVxuXSwgRHJhZ2dhYmxlTW9kdWxlKTtcblxuY29uc3QgY2xvc2VzdEluU2NvcGUgPSAobm9kZSwgcHJlZGljYXRlLCBzY29wZSkgPT4ge1xuICAgIHdoaWxlIChub2RlICYmIG5vZGUgIT09IHNjb3BlICYmICFwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgIT09IHNjb3BlKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbn07XG5cbmNvbnN0IGNsb3Nlc3QgPSAobm9kZSwgcHJlZGljYXRlKSA9PiB7XG4gICAgd2hpbGUgKG5vZGUgJiYgIXByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmNvbnN0IGNvbnRhaW5zID0gKHBhcmVudCwgbm9kZSwgbWF0Y2hTZWxmID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCBvdXRzaWRlID0gIWNsb3Nlc3Qobm9kZSwgKGNoaWxkKSA9PiBjaGlsZCA9PT0gcGFyZW50KTtcbiAgICBpZiAob3V0c2lkZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGVsID0gY2xvc2VzdChub2RlLCAoY2hpbGQpID0+IGNoaWxkID09PSBub2RlKTtcbiAgICByZXR1cm4gZWwgJiYgKG1hdGNoU2VsZiB8fCBlbCAhPT0gcGFyZW50KTtcbn07XG5cbmNvbnN0IGZpbmRFbGVtZW50ID0gKG5vZGUsIHByZWRpY2F0ZSwgbWF0Y2hTZWxmID0gdHJ1ZSkgPT4ge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtYXRjaFNlbGYgJiYgcHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZmluZEVsZW1lbnQobm9kZSwgcHJlZGljYXRlKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxufTtcblxuY29uc3QgZm9jdXNhYmxlUmVnZXggPSAvXig/OmF8aW5wdXR8c2VsZWN0fG9wdGlvbnx0ZXh0YXJlYXxidXR0b258b2JqZWN0KSQvaTtcbmNvbnN0IGlzRm9jdXNhYmxlID0gKGVsZW1lbnQpID0+IHtcbiAgICBpZiAoIWVsZW1lbnQudGFnTmFtZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHRhZ05hbWUgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBoYXNUYWJJbmRleCA9IEJvb2xlYW4oZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RhYkluZGV4JykpO1xuICAgIGNvbnN0IGZvY3VzYWJsZSA9ICFlbGVtZW50LmRpc2FibGVkICYmIGZvY3VzYWJsZVJlZ2V4LnRlc3QodGFnTmFtZSk7XG4gICAgcmV0dXJuIGZvY3VzYWJsZSB8fCBoYXNUYWJJbmRleDtcbn07XG5cbmNvbnN0IGlzVmlzaWJsZSA9IChlbGVtZW50KSA9PiB7XG4gICAgY29uc3QgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgaGFzU2l6ZSA9IHJlY3Qud2lkdGggPiAwICYmIHJlY3QuaGVpZ2h0ID4gMDtcbiAgICBjb25zdCBoYXNQb3NpdGlvbiA9IHJlY3QueCAhPT0gMCAmJiByZWN0LnkgIT09IDA7XG4gICAgLy8gRWxlbWVudHMgY2FuIGhhdmUgemVybyBzaXplIGR1ZSB0byBzdHlsaW5nLCBidXQgdGhleSB3aWxsIHN0aWxsIGNvdW50IGFzIHZpc2libGUuXG4gICAgLy8gRm9yIGV4YW1wbGUsIHRoZSBzZWxlY3Rpb24gY2hlY2tib3ggaGFzIG5vIHNpemUsIGJ1dCBpcyBtYWRlIHZpc2libGUgdGhyb3VnaCBzdHlsaW5nLlxuICAgIHJldHVybiAoaGFzU2l6ZSB8fCBoYXNQb3NpdGlvbikgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkudmlzaWJpbGl0eSAhPT0gJ2hpZGRlbic7XG59O1xuXG5jb25zdCBpc0ZvY3VzYWJsZVdpdGhUYWJLZXkgPSAoZWxlbWVudCwgY2hlY2tWaXNpYmlsaXR5ID0gdHJ1ZSkgPT4ge1xuICAgIGlmICghaXNGb2N1c2FibGUoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB0YWJJbmRleCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0YWJJbmRleCcpO1xuICAgIGNvbnN0IHZpc2libGUgPSAhY2hlY2tWaXNpYmlsaXR5IHx8IGlzVmlzaWJsZShlbGVtZW50KTtcbiAgICByZXR1cm4gdmlzaWJsZSAmJiB0YWJJbmRleCAhPT0gJy0xJztcbn07XG5cbmNvbnN0IGZpbmRGb2N1c2FibGVDaGlsZCA9IChlbGVtZW50LCBjaGVja1Zpc2liaWxpdHkgPSB0cnVlKSA9PiB7XG4gICAgcmV0dXJuIGZpbmRFbGVtZW50KGVsZW1lbnQsIChub2RlKSA9PiBpc0ZvY3VzYWJsZVdpdGhUYWJLZXkobm9kZSwgY2hlY2tWaXNpYmlsaXR5KSwgZmFsc2UpO1xufTtcblxuY29uc3QgZmluZEZvY3VzYWJsZSA9IChlbGVtZW50LCBjaGVja1Zpc2liaWxpdHkgPSB0cnVlKSA9PiB7XG4gICAgcmV0dXJuIGZpbmRFbGVtZW50KGVsZW1lbnQsIChub2RlKSA9PiBpc0ZvY3VzYWJsZVdpdGhUYWJLZXkobm9kZSwgY2hlY2tWaXNpYmlsaXR5KSk7XG59O1xuXG5jb25zdCB0b0NsYXNzTGlzdCA9IChjbGFzc05hbWVzKSA9PiBTdHJpbmcoY2xhc3NOYW1lcykudHJpbSgpLnNwbGl0KCcgJyk7XG5jb25zdCBoYXNDbGFzc2VzID0gKGVsZW1lbnQsIGNsYXNzTmFtZXMpID0+IHtcbiAgICBjb25zdCBuYW1lc0xpc3QgPSB0b0NsYXNzTGlzdChjbGFzc05hbWVzKTtcbiAgICByZXR1cm4gQm9vbGVhbih0b0NsYXNzTGlzdChlbGVtZW50LmNsYXNzTmFtZSkuZmluZCgoY2xhc3NOYW1lKSA9PiBuYW1lc0xpc3QuaW5kZXhPZihjbGFzc05hbWUpID49IDApKTtcbn07XG5cbmNvbnN0IG1hdGNoZXNDbGFzc2VzID0gKGNsYXNzTmFtZXMpID0+IChlbGVtZW50KSA9PiBoYXNDbGFzc2VzKGVsZW1lbnQsIGNsYXNzTmFtZXMpO1xuXG5jb25zdCBOT0RFX05BTUVfUFJFRElDQVRFUyA9IHt9O1xuY29uc3QgbWF0Y2hlc05vZGVOYW1lID0gKG5vZGVOYW1lKSA9PiB7XG4gICAgaWYgKCFOT0RFX05BTUVfUFJFRElDQVRFU1tub2RlTmFtZV0pIHtcbiAgICAgICAgTk9ERV9OQU1FX1BSRURJQ0FURVNbbm9kZU5hbWVdID0gKGVsZW1lbnQpID0+IFN0cmluZyhlbGVtZW50Lm5vZGVOYW1lKS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gTk9ERV9OQU1FX1BSRURJQ0FURVNbbm9kZU5hbWVdO1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemVzIGEgc2Nyb2xsIHBvc2l0aW9uIHZhbHVlIGluIFJUTCBtb2RlLlxuICovXG5mdW5jdGlvbiBydGxTY3JvbGxQb3NpdGlvbihwb3NpdGlvbiwgZWxlbWVudCwgaW5pdGlhbCkge1xuICAgIGxldCByZXN1bHQgPSBwb3NpdGlvbjtcbiAgICBpZiAoaW5pdGlhbCA8IDApIHtcbiAgICAgICAgcmVzdWx0ID0gLXBvc2l0aW9uO1xuICAgIH1cbiAgICBlbHNlIGlmIChpbml0aWFsID4gMCkge1xuICAgICAgICByZXN1bHQgPSBlbGVtZW50LnNjcm9sbFdpZHRoIC0gZWxlbWVudC5vZmZzZXRXaWR0aCAtIHBvc2l0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZTpuby1pbnB1dC1yZW5hbWUgKi9cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgRXZlbnRzT3V0c2lkZUFuZ3VsYXJEaXJlY3RpdmUgPSBjbGFzcyBFdmVudHNPdXRzaWRlQW5ndWxhckRpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgbmdab25lLCByZW5kZXJlcikge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IHt9O1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnQgfHwgIXRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXZlbnRzID0gdGhpcy5ldmVudHM7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIGluIGV2ZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2godGhpcy5yZW5kZXJlci5saXN0ZW4odGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIG5hbWUsIHRoaXMuc2NvcGUgPyBldmVudHNbbmFtZV0uYmluZCh0aGlzLnNjb3BlKSA6IGV2ZW50c1tuYW1lXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCB0aGlzLnN1YnNjcmlwdGlvbnMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uc1tpZHhdKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCdrZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEV2ZW50c091dHNpZGVBbmd1bGFyRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJldmVudHNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEV2ZW50c091dHNpZGVBbmd1bGFyRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzY29wZVwiLCB2b2lkIDApO1xuRXZlbnRzT3V0c2lkZUFuZ3VsYXJEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyXSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsXG4gICAgICAgIE5nWm9uZSxcbiAgICAgICAgUmVuZGVyZXIyXSlcbl0sIEV2ZW50c091dHNpZGVBbmd1bGFyRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBFdmVudHNNb2R1bGUgPSBjbGFzcyBFdmVudHNNb2R1bGUge1xufTtcbkV2ZW50c01vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbRXZlbnRzT3V0c2lkZUFuZ3VsYXJEaXJlY3RpdmVdLFxuICAgICAgICBleHBvcnRzOiBbRXZlbnRzT3V0c2lkZUFuZ3VsYXJEaXJlY3RpdmVdXG4gICAgfSlcbl0sIEV2ZW50c01vZHVsZSk7XG5cbmNsYXNzIFJlc2l6ZVNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKHJlc2l6ZUJhdGNoU2VydmljZSkge1xuICAgICAgICB0aGlzLnJlc2l6ZUJhdGNoU2VydmljZSA9IHJlc2l6ZUJhdGNoU2VydmljZTtcbiAgICAgICAgdGhpcy5yZXNpemUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuYWNjZXB0ZWRTaXplID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAwIC8qIEluaXRpYWwgKi87XG4gICAgfVxuICAgIGFjY2VwdFNpemUoc2l6ZSA9IHRoaXMubWVhc3VyZSgpKSB7XG4gICAgICAgIHRoaXMubGFzdFdpZHRoID0gc2l6ZS53aWR0aDtcbiAgICAgICAgdGhpcy5sYXN0SGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgIHRoaXMuYWNjZXB0ZWRTaXplID0gdHJ1ZTtcbiAgICB9XG4gICAgY2hlY2tDaGFuZ2VzKCkge1xuICAgICAgICBpZiAoIWlzRG9jdW1lbnRBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAwIC8qIEluaXRpYWwgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxIC8qIEluaXRpYWxpemluZyAqLztcbiAgICAgICAgICAgIC8vIGJhdGNoIGluaXRpYWwgbWVhc3VyZVxuICAgICAgICAgICAgdGhpcy5yZXNpemVCYXRjaFNlcnZpY2Uuc2NoZWR1bGUodGhpcywgdGhpcy5pbml0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnJlc2l6ZUJhdGNoU2VydmljZS5jYW5jZWwodGhpcyk7XG4gICAgfVxuICAgIGNoZWNrU2l6ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMubWVhc3VyZSgpO1xuICAgICAgICBjb25zdCBzYW1lU2l6ZSA9IHdpZHRoID09PSB0aGlzLmxhc3RXaWR0aCAmJiBoZWlnaHQgPT09IHRoaXMubGFzdEhlaWdodDtcbiAgICAgICAgaWYgKHNhbWVTaXplKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0V2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5sYXN0SGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLmFjY2VwdGVkU2l6ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlc2l6ZS5lbWl0KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpbml0U2l6ZSgpIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMubWVhc3VyZSgpO1xuICAgICAgICB0aGlzLmxhc3RXaWR0aCA9IHNpemUud2lkdGg7XG4gICAgICAgIHRoaXMubGFzdEhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgIH1cbiAgICBtZWFzdXJlKCkge1xuICAgICAgICBsZXQgd2lkdGggPSAwO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gMDtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5wYXJlbnRFbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5wYXJlbnRFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGhlaWdodCwgd2lkdGggfTtcbiAgICB9XG59XG5cbi8vIHRzbGludDpkaXNhYmxlOmRlcHJlY2F0aW9uXG5jb25zdCBkaXYgPSBzdHlsZSA9PiB7XG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbC5zdHlsZS5jc3NUZXh0ID0gc3R5bGU7XG4gICAgcmV0dXJuIGVsO1xufTtcbmNvbnN0IGNvbXB1dGVkUHJvcCA9IChlbGVtLCBwcm9wKSA9PiBnZXRDb21wdXRlZFN0eWxlKGVsZW0sIG51bGwpLmdldFByb3BlcnR5VmFsdWUocHJvcCk7XG5jb25zdCBXUkFQX1NUWUxFID0gJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsgZGlzcGxheTogYmxvY2s7IGxlZnQ6IDA7IHRvcDogMDsgcmlnaHQ6IDA7IGJvdHRvbTogMDsgei1pbmRleDogLTE7JyArXG4gICAgJ292ZXJmbG93OiBoaWRkZW47IHZpc2liaWxpdHk6IGhpZGRlbjsnO1xuY29uc3QgRVhQQU5EX0NISUxEX1NUWUxFID0gJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogMDsgdG9wOiAwOyB0cmFuc2l0aW9uOiAwczsnO1xuY29uc3QgU0hSSU5LX0NISUxEX1NUWUxFID0gRVhQQU5EX0NISUxEX1NUWUxFICsgJ3dpZHRoOiAyMDAlOyBoZWlnaHQ6IDIwMCU7JztcbmNsYXNzIFJlc2l6ZUNvbXBhdFNlcnZpY2UgZXh0ZW5kcyBSZXNpemVTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNpemVCYXRjaFNlcnZpY2UsIGVsZW1lbnQsIG5nWm9uZSkge1xuICAgICAgICBzdXBlcihyZXNpemVCYXRjaFNlcnZpY2UpO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICB9XG4gICAgY2hlY2tDaGFuZ2VzKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gMiAvKiBJbml0aWFsaXplZCAqLykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlc2l6ZUJhdGNoU2VydmljZS5pc1NjaGVkdWxlZCh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplQmF0Y2hTZXJ2aWNlLnNjaGVkdWxlKHRoaXMsIHRoaXMuY2hlY2tTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5jaGVja0NoYW5nZXMoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuZXhwYW5kKTtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5zaHJpbmspO1xuICAgICAgICAgICAgdGhpcy5leHBhbmQucmVtb3ZlQ2hpbGQodGhpcy5leHBhbmRDaGlsZCk7XG4gICAgICAgICAgICB0aGlzLmV4cGFuZCA9IHRoaXMuZXhwYW5kQ2hpbGQgPSB0aGlzLnNocmluayA9IHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tTaXplKCkge1xuICAgICAgICBpZiAoc3VwZXIuY2hlY2tTaXplKCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudEVsZW1lbnQgPSB0aGlzLnBhcmVudEVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICBpZiAoY29tcHV0ZWRQcm9wKHBhcmVudEVsZW1lbnQsICdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgICAgICAgICAgcGFyZW50RWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IDIgLyogSW5pdGlhbGl6ZWQgKi87XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgdGhpcy5pbml0U2l6ZSgpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gV1JBUF9TVFlMRTtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RpcicsICdsdHInKTtcbiAgICAgICAgdGhpcy5leHBhbmQgPSBkaXYoV1JBUF9TVFlMRSk7XG4gICAgICAgIHRoaXMuZXhwYW5kQ2hpbGQgPSBkaXYoRVhQQU5EX0NISUxEX1NUWUxFKTtcbiAgICAgICAgdGhpcy5leHBhbmQuYXBwZW5kQ2hpbGQodGhpcy5leHBhbmRDaGlsZCk7XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5leHBhbmQpO1xuICAgICAgICB0aGlzLnNocmluayA9IGRpdihXUkFQX1NUWUxFKTtcbiAgICAgICAgY29uc3Qgc2hyaW5rQ2hpbGQgPSBkaXYoU0hSSU5LX0NISUxEX1NUWUxFKTtcbiAgICAgICAgdGhpcy5zaHJpbmsuYXBwZW5kQ2hpbGQoc2hyaW5rQ2hpbGQpO1xuICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuc2hyaW5rKTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIGNvbnN0IGV4cGFuZENoaWxkID0gdGhpcy5leHBhbmRDaGlsZDtcbiAgICAgICAgZXhwYW5kQ2hpbGQuc3R5bGUud2lkdGggPSAxMDAwMDAgKyAncHgnO1xuICAgICAgICBleHBhbmRDaGlsZC5zdHlsZS5oZWlnaHQgPSAxMDAwMDAgKyAncHgnO1xuICAgICAgICBjb25zdCBleHBhbmQgPSB0aGlzLmV4cGFuZDtcbiAgICAgICAgZXhwYW5kLnNjcm9sbExlZnQgPSAxMDAwMDA7XG4gICAgICAgIGV4cGFuZC5zY3JvbGxUb3AgPSAxMDAwMDA7XG4gICAgICAgIGNvbnN0IHNocmluayA9IHRoaXMuc2hyaW5rO1xuICAgICAgICBzaHJpbmsuc2Nyb2xsTGVmdCA9IDEwMDAwMDtcbiAgICAgICAgc2hyaW5rLnNjcm9sbFRvcCA9IDEwMDAwMDtcbiAgICB9XG4gICAgc3Vic2NyaWJlKCkge1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IG1lcmdlKGZyb21FdmVudCh0aGlzLnNocmluaywgJ3Njcm9sbCcpLCBmcm9tRXZlbnQodGhpcy5leHBhbmQsICdzY3JvbGwnKSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrU2l6ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY29uc3QgSEFTX09CU0VSVkVSID0gdHlwZW9mIFJlc2l6ZU9ic2VydmVyICE9PSAndW5kZWZpbmVkJztcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBSZXNpemVPYnNlcnZlclNlcnZpY2UgZXh0ZW5kcyBSZXNpemVTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNpemVCYXRjaFNlcnZpY2UsIGVsZW1lbnQsIG5nWm9uZSkge1xuICAgICAgICBzdXBlcihyZXNpemVCYXRjaFNlcnZpY2UpO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICB9XG4gICAgc3RhdGljIHN1cHBvcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIEhBU19PQlNFUlZFUjtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5yZXNpemVPYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcmVudEVsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICB0aGlzLnBhcmVudEVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICB0aGlzLmluaXRTaXplKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAyIC8qIEluaXRpYWxpemVkICovO1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrU2l6ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5wYXJlbnRFbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZTphbGlnbiAqL1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBSZXNpemVCYXRjaFNlcnZpY2UgPSBjbGFzcyBSZXNpemVCYXRjaFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKG5nWm9uZSkge1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZWQgPSBbXTtcbiAgICAgICAgdGhpcy5yZXNvbHZlZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIHRoaXMuZmx1c2ggPSB0aGlzLmZsdXNoLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIHNjaGVkdWxlKGluc3RhbmNlLCBtZXRob2QpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZWQucHVzaCh7IGluc3RhbmNlLCBtZXRob2QgfSk7XG4gICAgICAgIGlmICghdGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IGZyb20odGhpcy5yZXNvbHZlZFByb21pc2UpXG4gICAgICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUodGhpcy5mbHVzaCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1NjaGVkdWxlZChpbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLnNjaGVkdWxlZC5maW5kKGl0ZW0gPT4gaXRlbS5pbnN0YW5jZSA9PT0gaW5zdGFuY2UpKTtcbiAgICB9XG4gICAgY2FuY2VsKGluc3RhbmNlKSB7XG4gICAgICAgIGNvbnN0IHNjaGVkdWxlZCA9IHRoaXMuc2NoZWR1bGVkO1xuICAgICAgICBjb25zdCBjb3VudCA9IHNjaGVkdWxlZC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGNvdW50OyBpZHgrKykge1xuICAgICAgICAgICAgaWYgKHNjaGVkdWxlZFtpZHhdLmluc3RhbmNlID09PSBpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlZC5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNjaGVkdWxlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmbHVzaCgpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZWQuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGl0ZW0ubWV0aG9kLmNhbGwoaXRlbS5pbnN0YW5jZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNjaGVkdWxlZCA9IFtdO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxufTtcblJlc2l6ZUJhdGNoU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05nWm9uZV0pXG5dLCBSZXNpemVCYXRjaFNlcnZpY2UpO1xuXG4vKipcbiAqIEVtaXQgdXAgdG8gMTAgcmVzaXplIGV2ZW50cyBwZXIgc2Vjb25kIGJ5IGRlZmF1bHQuXG4gKiBDaG9zZW4gYXMgYSBjb21wcm9taXNlIGJldHdlZW4gcmVzcG9uc2l2ZW5lc3MgYW5kIHBlcmZvcm1hbmNlLlxuICovXG5jb25zdCBERUZBVUxUX1JBVEVfTElNSVQgPSAxMDtcbi8qKlxuICogUmVzaXplIFNlbnNvciBDb21wb25lbnRcbiAqXG4gKiBUcmlnZ2VycyBhIFwicmVzaXplXCIgZXZlbnQgd2hlbmV2ZXIgdGhlIHBhcmVudCBET00gZWxlbWVudCBzaXplIGNoYW5nZXMuXG4gKi9cbmxldCBSZXNpemVTZW5zb3JDb21wb25lbnQgPSBjbGFzcyBSZXNpemVTZW5zb3JDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHJlc2l6ZUJhdGNoU2VydmljZSwgZWxlbWVudCwgbmdab25lKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgcmVzaXplIGV2ZW50cyB0byBlbWl0IHBlciBzZWNvbmQuXG4gICAgICAgICAqXG4gICAgICAgICAqIERlZmF1bHRzIHRvIDEwLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYXRlTGltaXQgPSBERUZBVUxUX1JBVEVfTElNSVQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBwYXJlbnQgRE9NIGVsZW1lbnQgaGFzIGJlZW4gcmVzaXplZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzaXplID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBjb25zdCBzZXJ2aWNlVHlwZSA9IFJlc2l6ZU9ic2VydmVyU2VydmljZS5zdXBwb3J0ZWQoKSA/IFJlc2l6ZU9ic2VydmVyU2VydmljZSA6IFJlc2l6ZUNvbXBhdFNlcnZpY2U7XG4gICAgICAgIHRoaXMucmVzaXplU2VydmljZSA9IG5ldyBzZXJ2aWNlVHlwZShyZXNpemVCYXRjaFNlcnZpY2UsIGVsZW1lbnQsIG5nWm9uZSk7XG4gICAgICAgIGNvbnN0IHRocm90dGxlVGltZSA9IDEwMDAgLyAodGhpcy5yYXRlTGltaXQgfHwgREVGQVVMVF9SQVRFX0xJTUlUKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLnJlc2l6ZVNlcnZpY2UucmVzaXplXG4gICAgICAgICAgICAucGlwZShhdWRpdFRpbWUodGhyb3R0bGVUaW1lKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlc2l6ZVNlcnZpY2UuYWNjZXB0ZWRTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemUuZW1pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdDaGVja2VkKCkge1xuICAgICAgICB0aGlzLnJlc2l6ZVNlcnZpY2UuY2hlY2tDaGFuZ2VzKCk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnJlc2l6ZVNlcnZpY2UuZGVzdHJveSgpO1xuICAgIH1cbiAgICBhY2NlcHRTaXplKHNpemUpIHtcbiAgICAgICAgdGhpcy5yZXNpemVTZXJ2aWNlLmFjY2VwdFNpemUoc2l6ZSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFJlc2l6ZVNlbnNvckNvbXBvbmVudC5wcm90b3R5cGUsIFwicmF0ZUxpbWl0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgUmVzaXplU2Vuc29yQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyZXNpemVcIiwgdm9pZCAwKTtcblJlc2l6ZVNlbnNvckNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tcmVzaXplLXNlbnNvcicsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbUmVzaXplQmF0Y2hTZXJ2aWNlLCBFbGVtZW50UmVmLCBOZ1pvbmVdKVxuXSwgUmVzaXplU2Vuc29yQ29tcG9uZW50KTtcblxuY29uc3QgQ09NUE9ORU5UX0RJUkVDVElWRVMgPSBbUmVzaXplU2Vuc29yQ29tcG9uZW50XTtcbi8qKlxuICogUmVzaXplIFNlbnNvciBtb2R1bGVcbiAqL1xubGV0IFJlc2l6ZVNlbnNvck1vZHVsZSA9IGNsYXNzIFJlc2l6ZVNlbnNvck1vZHVsZSB7XG59O1xuUmVzaXplU2Vuc29yTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtDT01QT05FTlRfRElSRUNUSVZFU10sXG4gICAgICAgIGV4cG9ydHM6IFtDT01QT05FTlRfRElSRUNUSVZFU10sXG4gICAgICAgIHByb3ZpZGVyczogW1Jlc2l6ZUJhdGNoU2VydmljZV1cbiAgICB9KVxuXSwgUmVzaXplU2Vuc29yTW9kdWxlKTtcblxuY2xhc3MgS2VuZG9JbnB1dCB7XG59XG5cbi8qKlxuICogRW51bSB3aXRoIGtleSBjb2Rlcy5cbiAqL1xudmFyIEtleXM7XG4oZnVuY3Rpb24gKEtleXMpIHtcbiAgICBLZXlzW0tleXNbXCJBbHRcIl0gPSAxOF0gPSBcIkFsdFwiO1xuICAgIEtleXNbS2V5c1tcIkFycm93RG93blwiXSA9IDQwXSA9IFwiQXJyb3dEb3duXCI7XG4gICAgS2V5c1tLZXlzW1wiQXJyb3dMZWZ0XCJdID0gMzddID0gXCJBcnJvd0xlZnRcIjtcbiAgICBLZXlzW0tleXNbXCJBcnJvd1JpZ2h0XCJdID0gMzldID0gXCJBcnJvd1JpZ2h0XCI7XG4gICAgS2V5c1tLZXlzW1wiQXJyb3dVcFwiXSA9IDM4XSA9IFwiQXJyb3dVcFwiO1xuICAgIEtleXNbS2V5c1tcIkJhY2tzcGFjZVwiXSA9IDhdID0gXCJCYWNrc3BhY2VcIjtcbiAgICBLZXlzW0tleXNbXCJDb250cm9sXCJdID0gMTddID0gXCJDb250cm9sXCI7XG4gICAgS2V5c1tLZXlzW1wiRGVsZXRlXCJdID0gNDZdID0gXCJEZWxldGVcIjtcbiAgICBLZXlzW0tleXNbXCJEaWdpdDBcIl0gPSA0OF0gPSBcIkRpZ2l0MFwiO1xuICAgIEtleXNbS2V5c1tcIkRpZ2l0MVwiXSA9IDQ5XSA9IFwiRGlnaXQxXCI7XG4gICAgS2V5c1tLZXlzW1wiRGlnaXQyXCJdID0gNTBdID0gXCJEaWdpdDJcIjtcbiAgICBLZXlzW0tleXNbXCJEaWdpdDNcIl0gPSA1MV0gPSBcIkRpZ2l0M1wiO1xuICAgIEtleXNbS2V5c1tcIkRpZ2l0NFwiXSA9IDUyXSA9IFwiRGlnaXQ0XCI7XG4gICAgS2V5c1tLZXlzW1wiRGlnaXQ1XCJdID0gNTNdID0gXCJEaWdpdDVcIjtcbiAgICBLZXlzW0tleXNbXCJEaWdpdDZcIl0gPSA1NF0gPSBcIkRpZ2l0NlwiO1xuICAgIEtleXNbS2V5c1tcIkRpZ2l0N1wiXSA9IDU1XSA9IFwiRGlnaXQ3XCI7XG4gICAgS2V5c1tLZXlzW1wiRGlnaXQ4XCJdID0gNTZdID0gXCJEaWdpdDhcIjtcbiAgICBLZXlzW0tleXNbXCJEaWdpdDlcIl0gPSA1N10gPSBcIkRpZ2l0OVwiO1xuICAgIEtleXNbS2V5c1tcIkVuZFwiXSA9IDM1XSA9IFwiRW5kXCI7XG4gICAgS2V5c1tLZXlzW1wiRW50ZXJcIl0gPSAxM10gPSBcIkVudGVyXCI7XG4gICAgS2V5c1tLZXlzW1wiRXNjYXBlXCJdID0gMjddID0gXCJFc2NhcGVcIjtcbiAgICBLZXlzW0tleXNbXCJGMVwiXSA9IDExMl0gPSBcIkYxXCI7XG4gICAgS2V5c1tLZXlzW1wiRjJcIl0gPSAxMTNdID0gXCJGMlwiO1xuICAgIEtleXNbS2V5c1tcIkYxMFwiXSA9IDEyMV0gPSBcIkYxMFwiO1xuICAgIEtleXNbS2V5c1tcIkhvbWVcIl0gPSAzNl0gPSBcIkhvbWVcIjtcbiAgICBLZXlzW0tleXNbXCJJbnNlcnRcIl0gPSA0NV0gPSBcIkluc2VydFwiO1xuICAgIEtleXNbS2V5c1tcIktleUFcIl0gPSA2NV0gPSBcIktleUFcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlCXCJdID0gNjZdID0gXCJLZXlCXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5Q1wiXSA9IDY3XSA9IFwiS2V5Q1wiO1xuICAgIEtleXNbS2V5c1tcIktleURcIl0gPSA2OF0gPSBcIktleURcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlFXCJdID0gNjldID0gXCJLZXlFXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5RlwiXSA9IDcwXSA9IFwiS2V5RlwiO1xuICAgIEtleXNbS2V5c1tcIktleUdcIl0gPSA3MV0gPSBcIktleUdcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlIXCJdID0gNzJdID0gXCJLZXlIXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5SVwiXSA9IDczXSA9IFwiS2V5SVwiO1xuICAgIEtleXNbS2V5c1tcIktleUpcIl0gPSA3NF0gPSBcIktleUpcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlLXCJdID0gNzVdID0gXCJLZXlLXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5TFwiXSA9IDc2XSA9IFwiS2V5TFwiO1xuICAgIEtleXNbS2V5c1tcIktleU1cIl0gPSA3N10gPSBcIktleU1cIjtcbiAgICBLZXlzW0tleXNbXCJLZXlOXCJdID0gNzhdID0gXCJLZXlOXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5T1wiXSA9IDc5XSA9IFwiS2V5T1wiO1xuICAgIEtleXNbS2V5c1tcIktleVBcIl0gPSA4MF0gPSBcIktleVBcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlRXCJdID0gODFdID0gXCJLZXlRXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5UlwiXSA9IDgyXSA9IFwiS2V5UlwiO1xuICAgIEtleXNbS2V5c1tcIktleVNcIl0gPSA4M10gPSBcIktleVNcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlUXCJdID0gODRdID0gXCJLZXlUXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5VVwiXSA9IDg1XSA9IFwiS2V5VVwiO1xuICAgIEtleXNbS2V5c1tcIktleVZcIl0gPSA4Nl0gPSBcIktleVZcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlXXCJdID0gODddID0gXCJLZXlXXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5WFwiXSA9IDg4XSA9IFwiS2V5WFwiO1xuICAgIEtleXNbS2V5c1tcIktleVlcIl0gPSA4OV0gPSBcIktleVlcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlaXCJdID0gOTBdID0gXCJLZXlaXCI7XG4gICAgS2V5c1tLZXlzW1wiTnVtcGFkRGVjaW1hbFwiXSA9IDExMF0gPSBcIk51bXBhZERlY2ltYWxcIjtcbiAgICBLZXlzW0tleXNbXCJQYWdlRG93blwiXSA9IDM0XSA9IFwiUGFnZURvd25cIjtcbiAgICBLZXlzW0tleXNbXCJQYWdlVXBcIl0gPSAzM10gPSBcIlBhZ2VVcFwiO1xuICAgIEtleXNbS2V5c1tcIlNoaWZ0XCJdID0gMTZdID0gXCJTaGlmdFwiO1xuICAgIEtleXNbS2V5c1tcIlNwYWNlXCJdID0gMzJdID0gXCJTcGFjZVwiO1xuICAgIEtleXNbS2V5c1tcIlRhYlwiXSA9IDldID0gXCJUYWJcIjtcbn0pKEtleXMgfHwgKEtleXMgPSB7fSkpO1xuXG5jbGFzcyBQcmV2ZW50YWJsZUV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJldmVudHMgdGhlIGRlZmF1bHQgYWN0aW9uIGZvciBhIHNwZWNpZmllZCBldmVudC5cbiAgICAgKiBJbiB0aGlzIHdheSwgdGhlIHNvdXJjZSBjb21wb25lbnQgc3VwcHJlc3Nlc1xuICAgICAqIHRoZSBidWlsdC1pbiBiZWhhdmlvciB0aGF0IGZvbGxvd3MgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICB0aGlzLnByZXZlbnRlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBldmVudCB3YXMgcHJldmVudGVkXG4gICAgICogYnkgYW55IG9mIGl0cyBzdWJzY3JpYmVycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgZGVmYXVsdCBhY3Rpb24gd2FzIHByZXZlbnRlZC5cbiAgICAgKiBPdGhlcndpc2UsIHJldHVybnMgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBpc0RlZmF1bHRQcmV2ZW50ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZlbnRlZDtcbiAgICB9XG59XG5cbi8qKlxuICogR2VuZXJhdGVkIGJ1bmRsZSBpbmRleC4gRG8gbm90IGVkaXQuXG4gKi9cblxuZXhwb3J0IHsgUmVzaXplU2VydmljZSwgUHJldmVudGFibGVFdmVudCwgRHJhZ2dhYmxlRGlyZWN0aXZlLCBEcmFnZ2FibGVNb2R1bGUsIGNsb3Nlc3RJblNjb3BlLCBjbG9zZXN0LCBjb250YWlucywgZmluZEVsZW1lbnQsIGZpbmRGb2N1c2FibGVDaGlsZCwgZmluZEZvY3VzYWJsZSwgaGFzQ2xhc3NlcywgaXNGb2N1c2FibGVXaXRoVGFiS2V5LCBpc0ZvY3VzYWJsZSwgaXNWaXNpYmxlLCBtYXRjaGVzQ2xhc3NlcywgbWF0Y2hlc05vZGVOYW1lLCBydGxTY3JvbGxQb3NpdGlvbiwgRXZlbnRzT3V0c2lkZUFuZ3VsYXJEaXJlY3RpdmUsIEV2ZW50c01vZHVsZSwgUmVzaXplU2Vuc29yQ29tcG9uZW50LCBSZXNpemVCYXRjaFNlcnZpY2UsIFJlc2l6ZUNvbXBhdFNlcnZpY2UsIFJlc2l6ZU9ic2VydmVyU2VydmljZSwgUmVzaXplU2Vuc29yTW9kdWxlLCBLZW5kb0lucHV0LCBpc0RvY3VtZW50QXZhaWxhYmxlLCBpc0NoYW5nZWQsIGFueUNoYW5nZWQsIGhhc09ic2VydmVycywgZ3VpZCwgS2V5cyB9O1xuIl19