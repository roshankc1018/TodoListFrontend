/**-----------------------------------------------------------------------------------------
* Copyright © 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var kendo_angular_common_1 = require("@progress/kendo-angular-common");
var kendo_common_1 = require("@progress/kendo-common");
var focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;
/**
 * @hidden
 */
exports.match = function (element, selector) {
    var matcher = element.matches || element.msMatchesSelector || element.webkitMatchesSelector;
    if (!matcher) {
        return false;
    }
    return matcher.call(element, selector);
};
/**
 * @hidden
 */
exports.closestWithMatch = function (element, selector) {
    if (!document.documentElement.contains(element)) {
        return null;
    }
    var parent = element;
    while (parent !== null && parent.nodeType === 1) {
        if (exports.match(parent, selector)) {
            return parent;
        }
        parent = parent.parentElement || parent.parentNode;
    }
    return null;
};
/**
 * @hidden
 */
exports.noop = function () { };
/**
 * @hidden
 */
exports.isPresent = function (value) { return value !== null && value !== undefined; };
/**
 * @hidden
 */
exports.isBlank = function (value) { return value === null || value === undefined; };
/**
 * @hidden
 */
exports.isArray = function (value) { return Array.isArray(value); };
/**
 * @hidden
 */
exports.isNullOrEmptyString = function (value) { return exports.isBlank(value) || value.trim().length === 0; };
/**
 * @hidden
 */
exports.isBoolean = function (value) { return typeof value === 'boolean'; };
/**
 * @hidden
 */
exports.closestNode = function (element) {
    var selector = 'li.k-treeview-item';
    if (!kendo_angular_common_1.isDocumentAvailable()) {
        return null;
    }
    if (element.closest) {
        return element.closest(selector);
    }
    else {
        return exports.closestWithMatch(element, selector);
    }
};
/**
 * @hidden
 */
exports.isFocusable = function (element) {
    if (element.tagName) {
        var tagName = element.tagName.toLowerCase();
        var tabIndex = element.getAttribute('tabIndex');
        var skipTab = tabIndex === '-1';
        var focusable = tabIndex !== null && !skipTab;
        if (focusableRegex.test(tagName)) {
            focusable = !element.disabled && !skipTab;
        }
        return focusable;
    }
    return false;
};
/**
 * @hidden
 */
exports.isContent = function (element) {
    var scopeSelector = '.k-in:not(.k-treeview-load-more-button),.k-treeview-item,.k-treeview';
    if (!kendo_angular_common_1.isDocumentAvailable()) {
        return null;
    }
    var node = element;
    while (node && !exports.match(node, scopeSelector)) {
        node = node.parentNode;
    }
    if (node) {
        return exports.match(node, '.k-in:not(.k-treeview-load-more-button)');
    }
};
/**
 * @hidden
 *
 * Returns the nested .k-in:not(.k-treeview-load-more-button) element.
 * If the passed parent item is itself a content node, it is returned.
 */
exports.getContentElement = function (parent) {
    if (!exports.isPresent(parent)) {
        return null;
    }
    var selector = '.k-in:not(.k-treeview-load-more-button)';
    if (exports.match(parent, selector)) {
        return parent;
    }
    return parent.querySelector(selector);
};
/**
 * @hidden
 */
exports.isLoadMoreButton = function (element) {
    return exports.isPresent(exports.closestWithMatch(element, '.k-in.k-treeview-load-more-button'));
};
/**
 * @hidden
 */
exports.closest = function (node, predicate) {
    while (node && !predicate(node)) {
        node = node.parentNode;
    }
    return node;
};
/**
 * @hidden
 */
exports.hasParent = function (element, container) {
    return Boolean(exports.closest(element, function (node) { return node === container; }));
};
/**
 * @hidden
 */
exports.focusableNode = function (element) { return element.nativeElement.querySelector('li[tabindex="0"]'); };
/**
 * @hidden
 */
exports.hasActiveNode = function (target, node) {
    var closestItem = node || exports.closestNode(target);
    return closestItem && (closestItem === target || target.tabIndex < 0);
};
/**
 * @hidden
 */
exports.nodeId = function (node) { return node ? node.getAttribute('data-treeindex') : ''; };
/**
 * @hidden
 */
exports.nodeIndex = function (item) { return (item || {}).index; };
/**
 * @hidden
 */
exports.dataItemsEqual = function (first, second) {
    if (!exports.isPresent(first) && !exports.isPresent(second)) {
        return true;
    }
    return exports.isPresent(first) && exports.isPresent(second) && first.item.dataItem === second.item.dataItem;
};
/**
 * @hidden
 */
exports.getDataItem = function (lookup) {
    if (!exports.isPresent(lookup)) {
        return lookup;
    }
    return lookup.item.dataItem;
};
/**
 * @hidden
 */
exports.isArrayWithAtLeastOneItem = function (v) { return v && Array.isArray(v) && v.length !== 0; };
/**
 * @hidden
 * A recursive tree-filtering algorithm that returns:
 * - all child nodes of matching nodes
 * - a chain parent nodes from the match to the root node
 */
exports.filterTree = function (items, term, _a, textField, depth) {
    var operator = _a.operator, ignoreCase = _a.ignoreCase, mode = _a.mode;
    if (depth === void 0) { depth = 0; }
    var field = typeof textField === "string" ? textField : textField[depth];
    items.forEach(function (wrapper) {
        var matcher = typeof operator === "string" ? matchByFieldAndCase(field, operator, ignoreCase) : operator;
        var isMatch = matcher(wrapper.dataItem, term);
        wrapper.isMatch = isMatch;
        wrapper.visible = isMatch;
        wrapper.containsMatches = false;
        if (isMatch) {
            setParentChain(wrapper.parent);
        }
        if (wrapper.children && wrapper.children.length > 0) {
            if (mode === "strict" || !isMatch) {
                exports.filterTree(wrapper.children, term, { operator: operator, ignoreCase: ignoreCase, mode: mode }, textField, depth + 1);
            }
            else {
                makeAllVisible(wrapper.children);
            }
        }
    });
};
var setParentChain = function (node) {
    if (!exports.isPresent(node)) {
        return;
    }
    node.containsMatches = true;
    node.visible = true;
    if (exports.isPresent(node.parent) && !node.parent.containsMatches) {
        setParentChain(node.parent);
    }
};
var ɵ0 = setParentChain;
exports.ɵ0 = ɵ0;
var makeAllVisible = function (nodes) {
    nodes.forEach(function (node) {
        node.visible = true;
        if (node.children) {
            makeAllVisible(node.children);
        }
    });
};
var ɵ1 = makeAllVisible;
exports.ɵ1 = ɵ1;
var ɵ2 = function (a, b) { return a.indexOf(b) >= 0; }, ɵ3 = function (a, b) { return a.indexOf(b) === -1; }, ɵ4 = function (a, b) { return a.lastIndexOf(b, 0) === 0; }, ɵ5 = function (a, b) { return a.lastIndexOf(b, 0) === -1; }, ɵ6 = function (a, b) { return a.indexOf(b, a.length - b.length) >= 0; }, ɵ7 = function (a, b) { return a.indexOf(b, a.length - b.length) < 0; };
exports.ɵ2 = ɵ2;
exports.ɵ3 = ɵ3;
exports.ɵ4 = ɵ4;
exports.ɵ5 = ɵ5;
exports.ɵ6 = ɵ6;
exports.ɵ7 = ɵ7;
var operators = {
    contains: ɵ2,
    doesnotcontain: ɵ3,
    startswith: ɵ4,
    doesnotstartwith: ɵ5,
    endswith: ɵ6,
    doesnotendwith: ɵ7
};
var matchByCase = function (matcher, ignoreCase) { return function (a, b) {
    if (ignoreCase) {
        return matcher(a.toLowerCase(), b.toLowerCase());
    }
    return matcher(a, b);
}; };
var ɵ8 = matchByCase;
exports.ɵ8 = ɵ8;
var matchByFieldAndCase = function (field, operator, ignoreCase) { return function (dataItem, term) { return matchByCase(operators[operator], ignoreCase)(kendo_common_1.getter(field)(dataItem), term); }; };
var ɵ9 = matchByFieldAndCase;
exports.ɵ9 = ɵ9;
/**
 * @hidden
 */
exports.buildTreeIndex = function (parentIndex, itemIndex) {
    return [parentIndex, itemIndex].filter(function (part) { return exports.isPresent(part); }).join('_');
};
/**
 * @hidden
 */
exports.buildTreeItem = function (dataItem, currentLevelIndex, parentIndex) {
    if (!exports.isPresent(dataItem)) {
        return null;
    }
    return {
        dataItem: dataItem,
        index: exports.buildTreeIndex(parentIndex, currentLevelIndex)
    };
};
/**
 * @hidden
 *
 * Retrieves all descendant nodes' lookups which are currently registered in the provided lookup item as a flat array.
 */
exports.fetchLoadedDescendants = function (lookup, filterExpression) {
    if (!exports.isPresent(lookup) || lookup.children.length === 0) {
        return [];
    }
    var descendants = lookup.children;
    if (exports.isPresent(filterExpression)) {
        descendants = descendants.filter(filterExpression);
    }
    descendants.forEach(function (child) {
        return descendants = descendants.concat(exports.fetchLoadedDescendants(child, filterExpression));
    });
    return descendants;
};
/**
 * @hidden
 *
 * Compares two arrays to determine whether all unique elements in one, are present in the other.
 * Important:
 *  - it disregards the element order
 *  - it disregards element repetitions - sameValues([1, 1, 2], [1, 2, 2]) will return true
 */
exports.sameValues = function (a, b) {
    if (a.length !== b.length) {
        return false;
    }
    var values = new Set(b);
    return a.every(function (v) { return values.has(v); });
};
