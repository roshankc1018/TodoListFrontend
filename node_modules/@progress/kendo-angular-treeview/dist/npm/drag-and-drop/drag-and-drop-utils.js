/**-----------------------------------------------------------------------------------------
* Copyright © 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var kendo_angular_common_1 = require("@progress/kendo-angular-common");
var utils_1 = require("../utils");
var models_1 = require("./models");
var ɵ0 = function () {
    if (!(kendo_angular_common_1.isDocumentAvailable() && utils_1.isPresent(document.body))) {
        return false;
    }
    var top = 10;
    var parent = document.createElement("div");
    parent.style.transform = "matrix(10, 0, 0, 10, 0, 0)";
    parent.innerHTML = "<div style=\"position: fixed; top: " + top + "px;\">child</div>";
    document.body.appendChild(parent);
    var isDifferent = parent.children[0].getBoundingClientRect().top !== top;
    document.body.removeChild(parent);
    return isDifferent;
};
exports.ɵ0 = ɵ0;
/**
 * Checks if the browser supports relative stacking context.
 * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context
 */
var hasRelativeStackingContext = memoize(ɵ0);
/**
 * Stores the result of the passed function's first invokation and returns it instead of invoking it again afterwards.
 */
function memoize(fn) {
    var result;
    var called = false;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (called) {
            return result;
        }
        result = fn.apply(void 0, args);
        called = true;
        return result;
    };
}
/**
 * @hidden
 *
 * Gets the offset of the parent element if the latter has the `transform` CSS prop applied.
 * Transformed parents create new stacking context and the `fixed` children must be position based on the transformed parent.
 * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context
 *
 * If no parent container is `transform`-ed the function will return `{ left: 0, top: 0 }`;
 */
exports.getContainerOffset = function (element) {
    if (!(element && hasRelativeStackingContext())) {
        return { left: 0, top: 0 };
    }
    var offsetParent = element.parentElement;
    while (offsetParent) {
        if (window.getComputedStyle(offsetParent).transform !== 'none') {
            break;
        }
        offsetParent = offsetParent.parentElement;
    }
    if (offsetParent) {
        var rect = offsetParent.getBoundingClientRect();
        return {
            left: rect.left - offsetParent.scrollLeft,
            top: rect.top - offsetParent.scrollTop
        };
    }
    return { left: 0, top: 0 };
};
/**
 * @hidden
 */
exports.getDropAction = function (dropPosition, dropTarget) {
    if (!(utils_1.isPresent(dropPosition) && utils_1.isPresent(dropTarget))) {
        return models_1.DropAction.Invalid;
    }
    switch (dropPosition) {
        case models_1.DropPosition.Over:
            return models_1.DropAction.Add;
        case models_1.DropPosition.Before:
            return utils_1.isPresent(utils_1.closestNode(dropTarget).previousElementSibling) ? models_1.DropAction.InsertMiddle : models_1.DropAction.InsertTop;
        case models_1.DropPosition.After:
            return utils_1.isPresent(utils_1.closestNode(dropTarget).nextElementSibling) ? models_1.DropAction.InsertMiddle : models_1.DropAction.InsertBottom;
        default:
            return models_1.DropAction.Invalid;
    }
};
/**
 * @hidden
 */
exports.getDropPosition = function (draggedItem, target, clientY, targetTreeView, containerOffset) {
    if (!(utils_1.isPresent(draggedItem) && utils_1.isPresent(target) && utils_1.isPresent(targetTreeView) && utils_1.isPresent(containerOffset))) {
        return;
    }
    // the .k-mid element starts just after the checkbox/expand arrow and stretches till the end of the treeview on the right
    var item = utils_1.closestWithMatch(target, '.k-mid');
    if (!utils_1.isPresent(item)) {
        return;
    }
    // the content element (.k-in:not(.k-treeview-load-more-button)) holds just the treeview item text
    var content = utils_1.getContentElement(item);
    var targetChildOfDraggedItem = utils_1.hasParent(item, utils_1.closestNode(draggedItem));
    if (!utils_1.isPresent(content) || (content === draggedItem) || targetChildOfDraggedItem) {
        return;
    }
    var itemViewPortCoords = content.getBoundingClientRect();
    /*
        if the user is hovering a treeview item, split the item height into four parts:
            - dropping into the top quarter should insert the dragged item before the drop target
            - dropping into the bottom quarter should insert the dragged item after the drop target
            - dropping into the second or third quarter should add the item as child node of the drop target

        if the user is NOT hovering a treeview item (he's dragging somewhere on the right), split the item height to just two parts:
            - dropping should insert before or after
    */
    var itemDivisionHeight = itemViewPortCoords.height / (utils_1.isContent(target) ? 4 : 2);
    // clear any possible container offset created by parent elements with `transform` css property set
    var pointerPosition = clientY - containerOffset.top;
    var itemTop = itemViewPortCoords.top - containerOffset.top;
    if (pointerPosition < itemTop + itemDivisionHeight) {
        return models_1.DropPosition.Before;
    }
    if (pointerPosition >= itemTop + itemViewPortCoords.height - itemDivisionHeight) {
        return models_1.DropPosition.After;
    }
    return models_1.DropPosition.Over;
};
/**
 * @hidden
 */
exports.treeItemFromEventTarget = function (treeView, dropTarget) {
    if (!(utils_1.isPresent(treeView) && utils_1.isPresent(dropTarget))) {
        return null;
    }
    var node = utils_1.closestNode(dropTarget);
    var index = utils_1.nodeId(node);
    var lookup = treeView.itemLookup(index);
    if (!(utils_1.isPresent(lookup) && utils_1.isPresent(lookup.item.dataItem))) {
        return null;
    }
    return lookup;
};
/**
 * @hidden
 *
 * Emits `collapse` on the specified TreeView node if the latter is left empty after its last child node was dragged out.
 */
exports.collapseEmptyParent = function (parent, parentNodes, treeview) {
    if (utils_1.isPresent(parent) && parentNodes.length === 0 && treeview.isExpanded(parent.item.dataItem, parent.item.index)) {
        treeview.collapseNode(parent.item.dataItem, parent.item.index);
    }
};
/**
 * @hidden
 *
 * Expands the node if it's dropped into and it's not yet expanded.
 */
exports.expandDropTarget = function (dropTarget, treeView) {
    if (!treeView.isExpanded(dropTarget.item.dataItem, dropTarget.item.index)) {
        treeView.expandNode(dropTarget.item.dataItem, dropTarget.item.index);
    }
};
/**
 * @hidden
 *
 * Extracts the event target from the viewport coords. Required for touch devices
 * where the `event.target` of a `pointermove` event is always the initially dragged item.
 */
exports.getDropTarget = function (event) {
    if (!(kendo_angular_common_1.isDocumentAvailable() && utils_1.isPresent(document.elementFromPoint))) {
        return event.target;
    }
    return document.elementFromPoint(event.clientX, event.clientY);
};
/**
 * @hidden
 *
 * Checks if the original index is before the new one and corrects the new one by decrementing the index for the level, where the original item stood.
 */
exports.updateMovedItemIndex = function (newIndex, originalIndex) {
    var movedItemNewIndexParts = newIndex.split('_');
    var originalItemIndexParts = originalIndex.split('_');
    // if the original item was moved from a deeper level, there's no need for index correction
    // e.g. 4_0_1 is moved to 5_0 => removing 4_0_1 will not cause 5_0 to be moved
    if (movedItemNewIndexParts.length < originalItemIndexParts.length) {
        return newIndex;
    }
    // check if the parent item paths are the same - index correction is not required when the original item path differs from the path of the moved item - they belong to different hierarchies
    // e.g. 4_1 is moved to 5_1 - the parent item paths are differen (4 compared to 5) => removing 4_1 will not cause 5_1 to be moved
    // e.g 4_1 is moved to 4_3 - the parent paths are the same (both 4) => removing 4_1 will cause 4_3 to be moved
    var originalItemParentPathLength = originalItemIndexParts.length - 1;
    var originalItemParentPath = originalItemIndexParts.slice(0, originalItemParentPathLength).join('_');
    var movedItemParentPath = movedItemNewIndexParts.slice(0, originalItemParentPathLength).join('_');
    // check if the the index of the level where the original item is taken from is greater than the one of the moved item
    // e.g. 4_5 is moved to 4_1 (comapre 5 and 1) => removing 4_5 will not cause 4_1 to be moved
    // e.g. 4_1 is moved to 4_5 (comapre 1 and 5) => removing 4_1 will cause 4_5 to be moved
    var originalItemIndexLevel = originalItemIndexParts.length - 1;
    var originalItemLevelIndex = Number(originalItemIndexParts[originalItemIndexLevel]);
    var movedItemLevelIndex = Number(movedItemNewIndexParts[originalItemIndexLevel]);
    if ((originalItemParentPath === movedItemParentPath) && (movedItemLevelIndex > originalItemLevelIndex)) {
        // if the removed item causes the dropped item to be moved a position up - decrement the index at that level
        movedItemNewIndexParts[originalItemIndexLevel] = String(movedItemLevelIndex - 1);
        return movedItemNewIndexParts.join('_');
    }
    return newIndex;
};
/**
 * @hidden
 */
var SCROLLBAR_REG_EXP = new RegExp('(auto|scroll)');
/**
 * @hidden
 *
 * Retrives the first scrollable element starting the search from the provided one, traversing to the top of the DOM tree.
 */
exports.getScrollableContainer = function (node) {
    while (utils_1.isPresent(node) && node.nodeName !== 'HTML') {
        var hasOverflow = node.scrollHeight > node.clientHeight;
        var hasScrollbar = SCROLLBAR_REG_EXP.test(getComputedStyle(node).overflowY);
        if (hasOverflow && hasScrollbar) {
            return node;
        }
        node = node.parentNode;
    }
    return node;
};
/**
 * @hidden
 *
 * Checks if the top of the scrollable element is reached.
 * Floors the scrollTop value.
 */
var isTopReached = function (element) { return Math.floor(element.scrollTop) <= 0; };
var ɵ1 = isTopReached;
exports.ɵ1 = ɵ1;
/**
 * @hidden
 *
 * Checks if the bottom of the scrollable element is reached.
 * Ceils the scrollTop value.
 */
var isBottomReached = function (element) { return Math.ceil(element.scrollTop) >= element.scrollHeight - element.clientHeight; };
var ɵ2 = isBottomReached;
exports.ɵ2 = ɵ2;
/**
 * @hidden
 *
 * Scrolls the element in the given direction by the provided step.
 *
 * If the targeted scroll incrementation doesn't yield any result due to device pixel ratio issues (https://github.com/dimitar-pechev/RenderingIndependentScrollOffsets#readme),
 * increments the step with 1px and again attempts to change the scrollTop of the element, until the content is actually scrolled.
 *
 * Cuts the operation short after 20 unsuccessful attempts to prevent infinite loops in possible corner-case scenarios.
 */
exports.scrollElementBy = function (element, step, direction) {
    if (!(utils_1.isPresent(element) && kendo_angular_common_1.isDocumentAvailable())) {
        return;
    }
    var initialScrollTop = element.scrollTop;
    var currentStep = step;
    var iterations = 0;
    while (initialScrollTop === element.scrollTop &&
        !(direction === models_1.ScrollDirection.Up && isTopReached(element)) &&
        !(direction === models_1.ScrollDirection.Down && isBottomReached(element)) &&
        iterations < 20 // as the bulgarian saying goes - to ties our underpants
    ) {
        element.scrollTop += (currentStep * direction);
        currentStep += 1;
        iterations += 1;
    }
};
