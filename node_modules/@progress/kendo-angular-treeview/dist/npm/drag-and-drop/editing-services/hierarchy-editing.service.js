/**-----------------------------------------------------------------------------------------
* Copyright Â© 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var kendo_common_1 = require("@progress/kendo-common");
var models_1 = require("../models");
var drag_and_drop_utils_1 = require("../drag-and-drop-utils");
var load_more_utils_1 = require("../../load-more/load-more-utils");
var utils_1 = require("../../utils");
/**
 * @hidden
 */
var HierarchyEditingService = /** @class */ (function () {
    function HierarchyEditingService(hierarchyBinding) {
        this.hierarchyBinding = hierarchyBinding;
    }
    HierarchyEditingService.prototype.add = function (_a) {
        var sourceItem = _a.sourceItem, destinationItem = _a.destinationItem, dropPosition = _a.dropPosition, sourceTree = _a.sourceTree, destinationTree = _a.destinationTree;
        // shallow clone the item as not to mistake it for its 'older' version when the remove handler kicks in to splice the item at its old position
        var clonedSourceDataItem = Object.assign({}, utils_1.getDataItem(sourceItem));
        if (dropPosition === models_1.DropPosition.Over) {
            // expand the item that was dropped into
            drag_and_drop_utils_1.expandDropTarget(destinationItem, destinationTree);
            var destinationChildren = this.childrenFor(utils_1.getDataItem(destinationItem));
            // add the moved node just before the load more button if load more is enabled
            var targetIndex = utils_1.isPresent(destinationTree.loadMoreService) ?
                Math.min(destinationTree.loadMoreService.getGroupSize(utils_1.getDataItem(destinationItem)), destinationChildren.length) : // the page size might be greater than the actual children array length
                destinationChildren.length;
            destinationChildren.splice(targetIndex, 0, clonedSourceDataItem);
            kendo_common_1.setter(this.hierarchyBinding.childrenField)(utils_1.getDataItem(destinationItem), destinationChildren);
            this.movedItemNewIndex = utils_1.buildTreeIndex(destinationItem.item.index, targetIndex);
        }
        else {
            var destinationParentNodes = this.getParentNodes(destinationItem, destinationTree);
            var shiftIndex = dropPosition === models_1.DropPosition.After ? 1 : 0;
            var targetIndex = destinationParentNodes.indexOf(utils_1.getDataItem(destinationItem)) + shiftIndex;
            destinationParentNodes.splice(targetIndex, 0, clonedSourceDataItem);
            var parentIndex = destinationItem.parent ? destinationItem.parent.item.index : null;
            this.movedItemNewIndex = utils_1.buildTreeIndex(parentIndex, targetIndex);
        }
        // increment the parent page size => an item is moved into it
        var updatedParent = dropPosition === models_1.DropPosition.Over ? utils_1.getDataItem(destinationItem) : utils_1.getDataItem(destinationItem.parent);
        load_more_utils_1.incrementPageSize(destinationTree, updatedParent);
        // the page sizes are stored by data-item reference => copy the old item ref page size to the new item reference
        load_more_utils_1.copyPageSize(destinationTree, utils_1.getDataItem(sourceItem), clonedSourceDataItem);
        // the source tree nodes are reloaded on `removeItem` - reload the destination tree nodes if the soruce and the destination tree are different
        if (sourceTree !== destinationTree && !destinationTree.loadOnDemand) {
            destinationTree.preloadChildNodes();
        }
        // if the source and destination trees are the same, focusing the moved item here will not have the desired effect
        // as the `remove` handler has not yet kicked-in to remove the item from its old position
        if (sourceTree !== destinationTree) {
            // ensure the focus target is rendered and registered
            destinationTree.changeDetectorRef.detectChanges();
            destinationTree.focus(this.movedItemNewIndex);
        }
    };
    HierarchyEditingService.prototype.remove = function (_a) {
        var sourceItem = _a.sourceItem, sourceTree = _a.sourceTree, destinationTree = _a.destinationTree;
        var sourceParentNodes = this.getParentNodes(sourceItem, sourceTree);
        var sourceItemIndex = sourceParentNodes.indexOf(utils_1.getDataItem(sourceItem));
        sourceParentNodes.splice(sourceItemIndex, 1);
        // emit collapse for the parent node if its last child node was spliced
        drag_and_drop_utils_1.collapseEmptyParent(sourceItem.parent, sourceParentNodes, sourceTree);
        // decrement source item parent page size => an item has been removed from it
        load_more_utils_1.decrementPageSize(sourceTree, utils_1.getDataItem(sourceItem.parent));
        // reload the treeview nodes
        if (!sourceTree.loadOnDemand) {
            sourceTree.preloadChildNodes();
        }
        // if the source and destination trees are different we want to focus only the moved item in the destination tree
        if (sourceTree === destinationTree) {
            // ensure the focus target is rendered and registered
            destinationTree.changeDetectorRef.detectChanges();
            // after the source item is removed from its original position, the candidate index might have to be corrected
            var index = drag_and_drop_utils_1.updateMovedItemIndex(this.movedItemNewIndex, sourceItem.item.index);
            destinationTree.focus(index);
        }
    };
    HierarchyEditingService.prototype.getParentNodes = function (node, treeView) {
        return utils_1.isPresent(node.parent) ?
            this.childrenFor(utils_1.getDataItem(node.parent)) :
            treeView.nodes;
    };
    HierarchyEditingService.prototype.childrenFor = function (dataItem) {
        return kendo_common_1.getter(this.hierarchyBinding.childrenField)(dataItem) || [];
    };
    return HierarchyEditingService;
}());
exports.HierarchyEditingService = HierarchyEditingService;
