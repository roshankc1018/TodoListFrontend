/**-----------------------------------------------------------------------------------------
* Copyright © 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { IndexBuilderService } from '../index-builder.service';
import { isPresent } from '../utils';
var safe = function (node) { return (node || {}); };
var ɵ0 = safe;
var safeChildren = function (node) { return (safe(node).children || []); };
var ɵ1 = safeChildren;
var lastVisibleNode = function (nodes) {
    if (!Array.isArray(nodes) || nodes.length === 0) {
        return null;
    }
    var nodesCount = nodes.length;
    var lastIndex = nodesCount - 1;
    for (var index = lastIndex; index >= 0; index -= 1) {
        var node = nodes[index];
        if (node.visible) {
            return node;
        }
    }
    return null;
};
var ɵ2 = lastVisibleNode;
/**
 * @hidden
 */
var NavigationModel = /** @class */ (function () {
    function NavigationModel() {
        this.ib = new IndexBuilderService();
        this.nodes = [];
    }
    NavigationModel.prototype.firstVisibleNode = function () {
        return (this.nodes || []).find(function (node) { return node.visible; });
    };
    NavigationModel.prototype.lastVisibleNode = function () {
        var node = lastVisibleNode(this.nodes);
        while (isPresent(node) && safeChildren(node).length > 0) {
            var children = safeChildren(node);
            var lastVisibleChild = lastVisibleNode(children);
            if (!isPresent(lastVisibleChild)) {
                return node;
            }
            node = lastVisibleChild;
        }
        return node;
    };
    NavigationModel.prototype.closestNode = function (index) {
        var prev = safe(this.findNode(index)).prev;
        var sibling = prev || this.firstVisibleNode();
        return safe(sibling).index === index ? this.visibleSibling(sibling, 1) : sibling;
    };
    NavigationModel.prototype.firstFocusableNode = function () {
        return this.nodes.find(function (node) {
            return !node.disabled && node.visible;
        });
    };
    NavigationModel.prototype.findNode = function (index) {
        return this.find(index, this.nodes);
    };
    NavigationModel.prototype.findParent = function (index) {
        var parentLevel = this.ib.level(index) - 1;
        return this.findNode(this.ib.indexForLevel(index, parentLevel));
    };
    NavigationModel.prototype.findVisibleChild = function (index) {
        var node = this.findNode(index);
        var children = safeChildren(node);
        return children.find(function (child) { return child.visible; });
    };
    NavigationModel.prototype.findVisiblePrev = function (item) {
        var index = item.index;
        var parent = this.findParent(index);
        var levelIndex = this.ib.lastLevelIndex(index);
        var prevNodes = this.container(parent).slice(0, levelIndex);
        var prevNodesHidden = prevNodes.every(function (node) { return !node.visible; });
        if (levelIndex === 0 || prevNodesHidden) {
            return parent;
        }
        var currentNode = this.findNode(index);
        var prev = this.visibleSibling(currentNode, -1);
        if (prev) {
            var children = this.container(prev);
            while (children.length > 0 && children.some(function (node) { return node.visible; })) {
                prev = lastVisibleNode(children);
                children = this.container(prev);
            }
        }
        return prev;
    };
    NavigationModel.prototype.findVisibleNext = function (item) {
        var children = this.container(item);
        var hasVisibleChildren = children.some(function (child) { return child.visible; });
        if (children.length === 0 || !hasVisibleChildren) {
            return this.visibleSibling(item, 1);
        }
        return children.find(function (child) { return child.visible; });
    };
    NavigationModel.prototype.registerItem = function (id, index, disabled, loadMoreButton, visible) {
        if (loadMoreButton === void 0) { loadMoreButton = false; }
        if (visible === void 0) { visible = true; }
        var children = [];
        var level = this.ib.level(index);
        var parent = this.findParent(index);
        if (parent || level === 1) {
            var node = { id: id, children: children, index: index, parent: parent, disabled: disabled, loadMoreButton: loadMoreButton, visible: visible };
            this.insert(node, parent);
        }
    };
    NavigationModel.prototype.unregisterItem = function (id, index) {
        var node = this.find(index, this.nodes);
        if (!node || node.id !== id) {
            return;
        }
        var children = this.container(node.parent);
        children.splice(children.indexOf(node), 1);
    };
    NavigationModel.prototype.childLevel = function (nodes) {
        var children = nodes.filter(function (node) { return isPresent(node); });
        if (!children || !children.length) {
            return 1;
        }
        return this.ib.level(children[0].index);
    };
    NavigationModel.prototype.container = function (node) {
        return node ? node.children : this.nodes;
    };
    NavigationModel.prototype.find = function (index, nodes) {
        var childLevel = this.childLevel(nodes);
        var indexToMatch = this.ib.indexForLevel(index, childLevel);
        var isLeaf = childLevel === this.ib.level(index);
        var node = nodes.find(function (n) { return n && n.index === indexToMatch; });
        if (!node) {
            return null;
        }
        return isLeaf ? node : this.find(index, node.children);
    };
    NavigationModel.prototype.insert = function (node, parent) {
        var nodes = this.container(parent);
        nodes.splice(this.ib.lastLevelIndex(node.index), 0, node);
    };
    NavigationModel.prototype.visibleSibling = function (node, offset) {
        if (!node) {
            return null;
        }
        var parent = this.findParent(node.index);
        var container = this.container(parent);
        var nextItemIndex = container.indexOf(node) + offset;
        var nextItem = container[nextItemIndex];
        while (isPresent(nextItem)) {
            if (nextItem.visible) {
                return nextItem;
            }
            nextItemIndex += offset;
            nextItem = container[nextItemIndex];
        }
        return this.visibleSibling(parent, offset);
    };
    return NavigationModel;
}());
export { NavigationModel };
export { ɵ0, ɵ1, ɵ2 };
