/**-----------------------------------------------------------------------------------------
* Copyright © 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { isEqual } from '@progress/kendo-date-math';
import { IntlService } from '@progress/kendo-angular-intl';
import { MIDNIGHT_DATE } from '../../defaults';
import { range, setMilliseconds } from '../../util';
var MILLISECONDS_IN_SECOND = 1000;
var clampToRange = function (rangeValue) { return function (value) { return value % rangeValue; }; };
var ɵ0 = clampToRange;
var clamp = clampToRange(MILLISECONDS_IN_SECOND);
var stepper = function (start, step) { return function (idx) { return clamp(start + (idx * step)); }; };
var ɵ1 = stepper;
var distanceFromMin = function (value, min) { return clamp(MILLISECONDS_IN_SECOND + value - min); };
var ɵ2 = distanceFromMin;
var limit = function (borderValue) { return function (barrier, value) {
    var useBarrier = !value ||
        (barrier.getHours() === value.getHours() &&
            barrier.getMinutes() === value.getMinutes() &&
            barrier.getSeconds() === value.getSeconds());
    return useBarrier ? barrier : setMilliseconds(barrier, borderValue);
}; };
var ɵ3 = limit;
var limitDown = limit(0);
var limitUp = limit(MILLISECONDS_IN_SECOND - 1);
/**
 * @hidden
 */
var MillisecondsService = /** @class */ (function () {
    function MillisecondsService(intl) {
        this.intl = intl;
        this.insertUndividedMax = false;
    }
    MillisecondsService.prototype.apply = function (value, candidate) {
        return setMilliseconds(value, candidate.getMilliseconds());
    };
    MillisecondsService.prototype.configure = function (settings) {
        var _this = this;
        var _a = settings.insertUndividedMax, insertUndividedMax = _a === void 0 ? this.insertUndividedMax : _a, _b = settings.min, min = _b === void 0 ? this.min : _b, _c = settings.max, max = _c === void 0 ? this.max : _c, _d = settings.step, step = _d === void 0 ? this.step : _d;
        this.insertUndividedMax = insertUndividedMax;
        this.toListItem = function (millisecond) {
            var date = setMilliseconds(MIDNIGHT_DATE, millisecond);
            return {
                text: _this.intl.formatDate(date, "SSS"),
                value: date
            };
        };
        this.min = min;
        this.max = max;
        this.step = step;
    };
    MillisecondsService.prototype.data = function (selectedValue) {
        var _this = this;
        var min = this.range(selectedValue)[0];
        var getMillisecond = stepper(min, this.step);
        var convertToItem = function (idx) { return (_this.toListItem(getMillisecond(idx))); };
        var data = range(0, this.countFromMin(selectedValue)).map(convertToItem);
        this.addLast(data);
        this.addMissing(data, selectedValue);
        return data;
    };
    MillisecondsService.prototype.isRangeChanged = function (min, max) {
        return !isEqual(this.min, min) || !isEqual(this.max, max);
    };
    MillisecondsService.prototype.limitRange = function (min, max, value) {
        return [limitDown(min, value), limitUp(max, value)];
    };
    MillisecondsService.prototype.total = function (value) {
        var last = this.insertUndividedMax && this.isLastMissing(value) ? 1 : 0;
        var missing = this.isMissing(value) ? 1 : 0;
        return this.countFromMin(value) + missing + last;
    };
    MillisecondsService.prototype.selectedIndex = function (value) {
        return Math.ceil(this.divideByStep(value));
    };
    MillisecondsService.prototype.valueInList = function (value) {
        if (!value) {
            return true;
        }
        var matchMax = this.insertUndividedMax && this.lastMillisecond(value) === value.getMilliseconds();
        return matchMax || !this.isMissing(value);
    };
    MillisecondsService.prototype.divideByStep = function (value) {
        return distanceFromMin(value.getMilliseconds(), this.min.getMilliseconds()) / this.step;
    };
    MillisecondsService.prototype.addLast = function (data, value) {
        if (this.insertUndividedMax && this.isLastMissing(value)) {
            data.push(this.toListItem(this.lastMillisecond(value)));
        }
        return data;
    };
    MillisecondsService.prototype.addMissing = function (data, value) {
        if (this.valueInList(value)) {
            return data;
        }
        var missingItem = this.toListItem(value.getMilliseconds());
        data.splice(this.selectedIndex(value), 0, missingItem);
        return data;
    };
    MillisecondsService.prototype.countFromMin = function (value) {
        var _a = this.range(value), min = _a[0], max = _a[1];
        return Math.floor(distanceFromMin(max, min) / this.step) + 1; /* include min */
    };
    MillisecondsService.prototype.isMissing = function (value) {
        if (!value) {
            return false;
        }
        return this.selectedIndex(value) !== this.divideByStep(value);
    };
    MillisecondsService.prototype.isLastMissing = function (value) {
        return this.isMissing(setMilliseconds(this.max, this.lastMillisecond(value)));
    };
    MillisecondsService.prototype.lastMillisecond = function (value) {
        return this.range(value)[1];
    };
    MillisecondsService.prototype.range = function (value) {
        var _a = this.limitRange(this.min, this.max, value), min = _a[0], max = _a[1];
        return [min.getMilliseconds(), max.getMilliseconds()];
    };
    MillisecondsService = tslib_1.__decorate([
        Injectable(),
        tslib_1.__metadata("design:paramtypes", [IntlService])
    ], MillisecondsService);
    return MillisecondsService;
}());
export { MillisecondsService };
export { ɵ0, ɵ1, ɵ2, ɵ3 };
