/**-----------------------------------------------------------------------------------------
* Copyright Â© 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
/* tslint:disable:component-selector-name  component-selector-type */
import { Component, ChangeDetectionStrategy, ChangeDetectorRef, EventEmitter, HostBinding, Input, Output, TemplateRef, ElementRef, Renderer2 } from '@angular/core';
import { cloneDate } from '@progress/kendo-date-math';
import { BusViewService } from './services/bus-view.service';
import { WeekNamesService } from './services/weeknames.service';
import { IntlService } from '@progress/kendo-angular-intl';
import { Action } from './models/navigation-action.enum';
import { CalendarViewEnum } from './models/view.enum';
import { MIN_DATE, MAX_DATE } from '../defaults';
import { dateInRange, hasChange } from '../util';
import { isDocumentAvailable } from '@progress/kendo-angular-common';
import { isPresent } from '../common/utils';
const DEFAULT_VIEWS_LENGTH = 2;
/**
 * @hidden
 */
let HorizontalViewListComponent = class HorizontalViewListComponent {
    constructor(bus, intl, weekService, cdr, element, renderer) {
        this.bus = bus;
        this.intl = intl;
        this.weekService = weekService;
        this.cdr = cdr;
        this.element = element;
        this.renderer = renderer;
        this.activeView = CalendarViewEnum.month;
        this.isActive = true;
        this.min = new Date(MIN_DATE);
        this.max = new Date(MAX_DATE);
        this.selectedDates = [];
        this.views = DEFAULT_VIEWS_LENGTH;
        this.showViewHeader = false;
        this.animateNavigation = false;
        this.cellClick = new EventEmitter();
        this.weekNumberCellClick = new EventEmitter();
        this.cellEnter = new EventEmitter();
        this.cellLeave = new EventEmitter();
        this.activeDateChange = new EventEmitter();
        this.getComponentClass = true;
        this.weekNames = [];
        this.dates = [];
        this.intlSubscription = this.intl.changes.subscribe(this.intlChange.bind(this));
    }
    get weekNumber() {
        return this.showWeekNumbers && this.isMonthView();
    }
    set weekNumber(showWeekNumbers) {
        this.showWeekNumbers = showWeekNumbers;
    }
    get getComponentMonthClass() {
        return this.activeView === CalendarViewEnum.month;
    }
    get getComponentYearClass() {
        return this.activeView === CalendarViewEnum.year;
    }
    get getComponentDecadeClass() {
        return this.activeView === CalendarViewEnum.decade;
    }
    get getComponentCenturyClass() {
        return this.activeView === CalendarViewEnum.century;
    }
    ngOnChanges(changes) {
        this.initService();
        if (this.weekNames.length === 0 || changes.weekNumber) {
            this.weekNames = this.weekService.getWeekNames(this.weekNumber);
        }
        if (!this.service) {
            return;
        }
        this.views = this.views || DEFAULT_VIEWS_LENGTH;
        const focusedDate = this.focusedDate;
        const viewDate = this.clampDate(this.service.viewDate(focusedDate, this.max, this.views));
        this.skip = this.service.skip(viewDate, this.min);
        this.total = this.service.total(this.min, this.max);
        const activeViewChanged = hasChange(changes, 'activeView');
        const viewsHasChanged = this.views > 0 && hasChange(changes, 'views');
        if (activeViewChanged || !this.isInDates(focusedDate) || viewsHasChanged || !this.activeDate) {
            this.dates = this.service.datesList(viewDate, this.getTake(this.skip));
            this.activeDate = cloneDate(this.dates[0]);
            this.activeDateChange.emit(this.activeDate);
        }
    }
    ngAfterViewInit() {
        // make the calendar look the same in the different browsers
        // which also smoothens the navigation animation
        if (this.views === 1) {
            this.setTableMinWidth();
        }
    }
    ngOnDestroy() {
        this.intlSubscription.unsubscribe();
    }
    initService() {
        this.service = this.bus.service(this.activeView);
    }
    isMonthView() {
        return this.activeView === CalendarViewEnum.month;
    }
    getCaptionTitle(date) {
        return this.service.title(date);
    }
    getCaptionClass() {
        return this.isMonthView() ? 'k-month-header' : 'k-meta-header';
    }
    animateView(action) {
        const container = this.element.nativeElement;
        const table = container.querySelector('table');
        // the whole width excluding padding/margin
        const initialContainerWidth = parseFloat(getComputedStyle(container).width);
        // table width
        const tableWidth = parseFloat(getComputedStyle(table).width);
        this.renderer.setStyle(container, 'width', `${initialContainerWidth}px`);
        this.renderer.setStyle(container, 'overflow', 'visible');
        // initialize an additional view for the animation
        if (action === Action.NextView) {
            // animating Action.NextView requires adding an additional view before the rendered views
            this.nextAnimationDate = cloneDate(this.dates[0]);
        }
        else {
            // animating Action.PrevView requires adding an additional view after the rendered views
            this.prevAnimationDate = cloneDate(this.dates[this.dates.length - 1]);
        }
        // run cdr to render the additional view
        this.cdr.detectChanges();
        container.querySelectorAll('table').forEach(table => {
            this.renderer.setStyle(table, 'width', `${tableWidth}px`);
            if (this.views === 1) {
                this.renderer.setStyle(table, 'min-width', `${initialContainerWidth}px`);
            }
        });
        // we always slide by the width of 1 table
        // cross-browser compatibility is ensured by measuring the client rectangle and substracting the gap
        const tabRect = table.getBoundingClientRect();
        const containerGap = parseFloat(getComputedStyle(container).columnGap);
        const start = action === Action.NextView ? 'translateX(0)' : `translateX(-${tabRect.width + containerGap}px)`;
        const end = action === Action.NextView ? `translateX(-${tabRect.width + containerGap}px)` : 'translateX(0)';
        if (!this.animation) {
            this.animation = container.animate([
                { transform: start },
                { transform: end }
            ], {
                duration: 500,
                easing: 'ease-out'
            });
            this.animation.oncancel = this.animation.onfinish = () => {
                // clear all inline styles
                this.renderer.removeStyle(container, 'width');
                this.renderer.removeStyle(container, 'overflow');
                container.querySelectorAll('table').forEach(table => {
                    this.renderer.removeStyle(table, 'width');
                });
                // clear the animation and the animation view
                this.animation = null;
                this.nextAnimationDate = null;
                this.prevAnimationDate = null;
                // run cdr to remove additional animation view from the markup
                this.cdr.detectChanges();
            };
        }
        else {
            // if animation is already running, cancel it and show the end navigation result on multiple prev/next button clicks
            this.animation.cancel();
        }
    }
    navigate(action) {
        if (this.animateNavigation && isDocumentAvailable() && isPresent(this.element.nativeElement.animate)) {
            this.animateView(action);
        }
        const candidate = this.move(action);
        const list = this.service.datesList(candidate, this.getTake(this.skip));
        if (this.isListInRange(list)) {
            this.dates = list;
        }
        this.activeDate = cloneDate(this.dates[0]);
        this.focusedDate = cloneDate(candidate);
        this.cdr.markForCheck();
        this.activeDateChange.emit(this.activeDate);
        return cloneDate(candidate);
    }
    canNavigate(action) {
        if (!this.service) {
            return false;
        }
        return this.isListInRange(this.service.datesList(this.move(action), this.getTake(this.skip)));
    }
    setTableMinWidth() {
        const container = this.element.nativeElement;
        const table = container.querySelector('table');
        if (table) {
            const containerWidth = parseFloat(getComputedStyle(container).width);
            this.renderer.setStyle(table, 'min-width', `${containerWidth}px`);
        }
    }
    intlChange() {
        this.weekNames = this.weekService.getWeekNames(this.weekNumber);
        this.cdr.markForCheck();
    }
    clampDate(value) {
        return dateInRange(value, this.min, this.max);
    }
    move(action) {
        return this.service.move(this.dates[0] || this.focusedDate, action);
    }
    isListInRange(list) {
        const lowerBound = this.service.beginningOfPeriod(this.min);
        const upperBound = this.service.beginningOfPeriod(this.service.addToDate(this.max, 1));
        return lowerBound <= list[0] && list[list.length - 1] < upperBound;
    }
    isInDates(value) {
        return this.service.isInArray(value, this.dates);
    }
    getTake(skip) {
        return Math.min(this.total - skip, this.views);
    }
};
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", TemplateRef)
], HorizontalViewListComponent.prototype, "cellTemplateRef", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", TemplateRef)
], HorizontalViewListComponent.prototype, "weekNumberTemplateRef", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], HorizontalViewListComponent.prototype, "activeRangeEnd", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number)
], HorizontalViewListComponent.prototype, "activeView", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], HorizontalViewListComponent.prototype, "cellUID", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Date)
], HorizontalViewListComponent.prototype, "focusedDate", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], HorizontalViewListComponent.prototype, "isActive", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Date)
], HorizontalViewListComponent.prototype, "min", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Date)
], HorizontalViewListComponent.prototype, "max", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object)
], HorizontalViewListComponent.prototype, "selectionRange", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Array)
], HorizontalViewListComponent.prototype, "selectedDates", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number)
], HorizontalViewListComponent.prototype, "views", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], HorizontalViewListComponent.prototype, "showViewHeader", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], HorizontalViewListComponent.prototype, "animateNavigation", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [Boolean])
], HorizontalViewListComponent.prototype, "weekNumber", null);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], HorizontalViewListComponent.prototype, "cellClick", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], HorizontalViewListComponent.prototype, "weekNumberCellClick", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], HorizontalViewListComponent.prototype, "cellEnter", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], HorizontalViewListComponent.prototype, "cellLeave", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], HorizontalViewListComponent.prototype, "activeDateChange", void 0);
tslib_1.__decorate([
    HostBinding("class.k-calendar-view"),
    HostBinding("class.k-justify-align-start"),
    tslib_1.__metadata("design:type", Boolean)
], HorizontalViewListComponent.prototype, "getComponentClass", void 0);
tslib_1.__decorate([
    HostBinding("class.k-calendar-monthview"),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [])
], HorizontalViewListComponent.prototype, "getComponentMonthClass", null);
tslib_1.__decorate([
    HostBinding("class.k-calendar-yearview"),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [])
], HorizontalViewListComponent.prototype, "getComponentYearClass", null);
tslib_1.__decorate([
    HostBinding("class.k-calendar-decadeview"),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [])
], HorizontalViewListComponent.prototype, "getComponentDecadeClass", null);
tslib_1.__decorate([
    HostBinding("class.k-calendar-centuryview"),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [])
], HorizontalViewListComponent.prototype, "getComponentCenturyClass", null);
HorizontalViewListComponent = tslib_1.__decorate([
    Component({
        changeDetection: ChangeDetectionStrategy.OnPush,
        selector: 'kendo-calendar-horizontal',
        template: `
        <ng-template #tableTemplate let-date="date" let-class="className">
            <table
                class="k-content k-calendar-content k-calendar-table"
                [ngClass]="class"
            >
                <caption *ngIf="showViewHeader" [ngClass]="getCaptionClass()">{{ getCaptionTitle(date) }}</caption>
                <thead *ngIf="isMonthView()" class="k-calendar-thead">
                    <tr class="k-calendar-tr" role="row">
                        <th *ngFor="let name of weekNames" class="k-calendar-th">{{name}}</th>
                    </tr>
                </thead>
                <tbody
                    class="k-calendar-tbody"
                    kendoCalendarView
                    role="rowgroup"
                    direction="horizontal"
                    [activeView]="activeView"
                    [isActive]="isActive"
                    [min]="min"
                    [max]="max"
                    [cellUID]="cellUID"
                    [focusedDate]="focusedDate"
                    [selectedDates]="selectedDates"
                    [selectionRange]="selectionRange"
                    [activeRangeEnd]="activeRangeEnd"
                    [weekNumber]="weekNumber"
                    [templateRef]="cellTemplateRef"
                    [weekNumberTemplateRef]="weekNumberTemplateRef"
                    [viewDate]="date"
                    (cellClick)="cellClick.emit($event)"
                    (weekNumberCellClick)="weekNumberCellClick.emit($event)"
                    (cellEnter)="cellEnter.emit($event)"
                    (cellLeave)="cellLeave.emit($event)"
                >
                </tbody>
            </table>
        </ng-template>

        <!-- When Next is clicked a placeholder table is rendered before the Main Table -->
        <ng-template
            *ngIf="nextAnimationDate"
            [ngTemplateOutlet]="tableTemplate"
            [ngTemplateOutletContext]="{
                date: nextAnimationDate,
                className: 'k-pointer-events-none'
            }"
        >
        </ng-template>

        <ng-template
            *kFor="let date of dates"
            [ngTemplateOutlet]="tableTemplate"
            [ngTemplateOutletContext]="{
                date: date
            }"
        >
        </ng-template>

        <!-- When Prev is clicked a placeholder table is rendered after the Main Table -->
        <ng-template
            *ngIf="prevAnimationDate"
            [ngTemplateOutlet]="tableTemplate"
            [ngTemplateOutletContext]="{
                date: prevAnimationDate,
                className: 'k-pointer-events-none'
            }"
        >
        </ng-template>
    `
    }),
    tslib_1.__metadata("design:paramtypes", [BusViewService,
        IntlService,
        WeekNamesService,
        ChangeDetectorRef,
        ElementRef,
        Renderer2])
], HorizontalViewListComponent);
export { HorizontalViewListComponent };
